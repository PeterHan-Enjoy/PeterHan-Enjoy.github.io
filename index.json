[
{
	"uri": "https://peterhan-enjoy.github.com/utils/markdown/",
	"title": "Markdown使用",
	"tags": [],
	"description": "",
	"content": " Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n一、标题 在想要设置为标题的文字前面加#来表示\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。\n示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题  效果如下： 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二、字体 加粗\n要加粗的文字左右分别用两个*号包起来\n斜体\n要倾斜的文字左右分别用一个*号包起来\n斜体加粗\n要倾斜和加粗的文字左右分别用三个*号包起来\n删除线\n要加删除线的文字左右分别用两个~~号包起来\n示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~  效果如下： 这是加粗的文字\n这是倾斜的文字`\n这是斜体加粗的文字\n这是加删除线的文字\n三、分割线 三个或者三个以上的 - 或者 * 都可以。\n示例：  --- ---- *** *****  效果如下： 可以看到，显示效果是一样的。\n四、图片 语法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加  示例： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419\u0026amp;fm=27\u0026amp;gp=0.jpg \u0026quot;区块链\u0026quot;)  效果如下： 五、超链接 语法： [超链接名](超链接地址 \u0026quot;超链接title\u0026quot;) title可加可不加  示例： [简书](http://jianshu.com) [百度](http://baidu.com)  效果如下： 简书\n百度\n注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。\n\u0026lt;a href=\u0026quot;超链接地址\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;超链接名\u0026lt;/a\u0026gt; 示例 \u0026lt;a href=\u0026quot;https://www.jianshu.com/u/1f5ac0cf6a8b\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;简书\u0026lt;/a\u0026gt;  六、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  有序列表 语法： 数字加点 1. 列表内容 2. 列表内容 3. 列表内容 注意：序号跟内容之间要有空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  七、表格 语法： 表头|表头|表头 :-:|:-:|:-: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略  示例： 姓名|技能|排行 :-:|:-:|:-: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟  效果如下：    姓名 技能 排行     刘备 哭 大哥   关羽 打 二哥   张飞 骂 三弟    八、代码 语法： 单行代码：代码之间分别用一个反引号包起来\n `代码内容`  代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n(```) 代码... 代码... 代码... (```)  注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n示例： 单行代码\n`create database hero;`  代码块\n(```) function fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun(); (```)  效果如下： 单行代码\ncreate database hero;\n代码块\nfunction fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun();  九、问题 行末两个空格 在Hugo编写Markdown文件时，如果行末没有两个空格是不会换行的。\n高亮 在Markdown中，==可以用作高亮，但是hugo则不行\n代码 在hugo中，三个反引号和代码放一行是不会渲染出代码结构的，除非换行。\n转义 \u0026gt; =\u0026gt; \u0026amp;gt;  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/",
	"title": "工具类",
	"tags": [],
	"description": "",
	"content": " 工具使用 "
},
{
	"uri": "https://peterhan-enjoy.github.com/",
	"title": "规范",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/lambda/",
	"title": "1. Lambda 表达式",
	"tags": [],
	"description": "",
	"content": " 语法 lambda 表达式的语法格式如下：\n(parameters) -\u0026gt; expression 或 (parameters) -\u0026gt;{ statements; }  以下是lambda表达式的重要特征:\n 可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。 可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。 可选的大括号：如果主体包含了一个语句，就不需要使用大括号。 可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。  Lambda 表达式实例 Lambda 表达式的简单例子:\n// 1. 不需要参数,返回值为 5 () -\u0026gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -\u0026gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -\u0026gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -\u0026gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -\u0026gt; System.out.print(s)  使用 Lambda 表达式需要注意以下两点：\n Lambda 表达式主要用来定义行内执行的方法类型接口。 Lambda 表达式免去了使用匿名方法的麻烦，并且给予Java简单但是强大的函数化的编程能力。\n变量作用域 lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 lambda 内部修改定义在域外的局部变量，否则会编译错误。\npublic class Java8Tester { final static String salutation = \u0026quot;Hello! \u0026quot;; public static void main(String args[]){ GreetingService greetService1 = message -\u0026gt; System.out.println(salutation + message); greetService1.sayMessage(\u0026quot;Runoob\u0026quot;); } interface GreetingService { void sayMessage(String message); } }   执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester Hello! Runoob  我们也可以直接在 lambda 表达式中访问外层的局部变量：\npublic class Java8Tester { public static void main(String args[]) { final int num = 1; Converter\u0026lt;Integer, String\u0026gt; s = (param) -\u0026gt; System.out.println(String.valueOf(param + num)); s.convert(2); // 输出结果为 3 } public interface Converter\u0026lt;T1, T2\u0026gt; { void convert(int i); } }  lambda 表达式的局部变量可以不用声明为 final，但是必须不可被后面的代码修改（即隐性的具有 final 的语义）\nint num = 1; Converter\u0026lt;Integer, String\u0026gt; s = (param) -\u0026gt; System.out.println(String.valueOf(param + num)); s.convert(2); num = 5; //报错信息：Local variable num defined in an enclosing scope must be final or effectively final  在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量。\n String first = \u0026quot;\u0026quot;; Comparator\u0026lt;String\u0026gt; comparator = (first, second) -\u0026gt; Integer.compare(first.length(), second.length()); //编译会出错  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/method/",
	"title": "2. 方法引用",
	"tags": [],
	"description": "",
	"content": "方法引用是用来直接访问类或者实例的已经存在的方法或者构造方法。方法引用提供了一种引用而不执行方法的方式，它需要由兼容的函数式接口构成的目标类型上下文。计算时，方法引用会创建函数式接口的一个实例。\n当Lambda表达式中只是执行一个方法调用时，不用Lambda表达式，直接通过方法引用的形式可读性更高一些。方法引用是一种更简洁易懂的Lambda表达式。\n注意方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号\u0026rdquo;::\u0026ldquo;。\n============================================================================\n简单地说，就是一个Lambda表达式。在Java 8中，我们会使用Lambda表达式创建匿名方法，但是有时候，我们的Lambda表达式可能仅仅调用一个已存在的方法，而不做任何其它事，对于这种情况，通过一个方法名字来引用这个已存在的方法会更加清晰，Java 8的方法引用允许我们这样做。方法引用是一个更加紧凑，易读的Lambda表达式，注意方法引用是一个Lambda表达式，其中方法引用的操作符是双冒号\u0026rdquo;::\u0026ldquo;。\n+ 构造器引用：它的语法是Class::new，或者更一般的Class\u0026lt; T \u0026gt;::new实例如下：\nfinal Car car = Car.create( Car::new ); final List\u0026lt; Car \u0026gt; cars = Arrays.asList( car );   静态方法引用：它的语法是Class::static_method，实例如下：\ncars.forEach( Car::collide );  特定类的任意对象的方法引用：它的语法是Class::method实例如下：\ncars.forEach( Car::repair );  +特定对象的方法引用：它的语法是instance::method实例如下：\nfinal Car police = Car.create( Car::new ); cars.forEach( police::follow );   "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/functioninterface/",
	"title": "3. 函数式接口",
	"tags": [],
	"description": "",
	"content": " 函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口。\n函数式接口可以被隐式转换为 lambda 表达式。\nLambda 表达式和方法引用（实际上也可认为是Lambda表达式）上。\n如定义了一个函数式接口如下：\n@FunctionalInterface interface GreetingService { void sayMessage(String message); }  那么就可以使用Lambda表达式来表示该接口的一个实现(注：JAVA 8 之前一般是用匿名类实现的)：\nGreetingService greetService1 = message -\u0026gt; System.out.println(\u0026quot;Hello \u0026quot; + message);  函数式接口可以对现有的函数友好地支持 lambda。\nJDK 1.8 之前已有的函数式接口:\n java.lang.Runnable java.util.concurrent.Callable java.security.PrivilegedAction java.util.Comparator java.io.FileFilter java.nio.file.PathMatcher java.lang.reflect.InvocationHandler java.beans.PropertyChangeListener java.awt.event.ActionListener javax.swing.event.ChangeListener\n  JDK 1.8 新增加的函数接口：\n java.util.function\n  java.util.function 它包含了很多类，用来支持 Java的 函数式编程，该包中的函数式接口有：\n   序号 接口 \u0026amp; 描述     1 BiConsumer 代表了一个接受两个输入参数的操作，并且不返回任何结果   2 BiFunction代表了一个接受两个输入参数的方法，并且返回一个结果   3 BinaryOperator代表了一个作用于于两个同类型操作符的操作，并且返回了操作符同类型的结果   4 BiPredicate代表了一个两个参数的boolean值方法   5 BooleanSupplier代表了boolean值结果的提供方   6 Consumer代表了接受一个输入参数并且无返回的操作   7 DoubleBinaryOperator代表了作用于两个double值操作符的操作，并且返回了一个double值的结果。   8 DoubleConsumer代表一个接受double值参数的操作，并且不返回结果。   9 DoubleFunction代表接受一个double值参数的方法，并且返回结果   10 DoublePredicate代表一个拥有double值参数的boolean值方法   11 DoubleSupplier代表一个double值结构的提供方   12 DoubleToIntFunction接受一个double类型输入，返回一个int类型结果。   13 DoubleToLongFunction接受一个double类型输入，返回一个long类型结果   14 DoubleUnaryOperator接受一个参数同为类型double,返回值类型也为double 。   15 Function接受一个输入参数，返回一个结果。   16 IntBinaryOperator接受两个参数同为类型int,返回值类型也为int 。   17 IntConsumer接受一个int类型的输入参数，无返回值 。   18 IntFunction接受一个int类型输入参数，返回一个结果 。   19 IntPredicate：接受一个int输入参数，返回一个布尔值的结果。   20 IntSupplier无参数，返回一个int类型结果。   21 IntToDoubleFunction接受一个int类型输入，返回一个double类型结果 。   22 IntToLongFunction接受一个int类型输入，返回一个long类型结果。   23 IntUnaryOperator接受一个参数同为类型int,返回值类型也为int 。   24 LongBinaryOperator接受两个参数同为类型long,返回值类型也为long。   25 LongConsumer接受一个long类型的输入参数，无返回值。   26 LongFunction接受一个long类型输入参数，返回一个结果。   27 LongPredicateR接受一个long输入参数，返回一个布尔值类型结果。   28 LongSupplier无参数，返回一个结果long类型的值。   29 LongToDoubleFunction接受一个long类型输入，返回一个double类型结果。   30 LongToIntFunction接受一个long类型输入，返回一个int类型结果。   31 LongUnaryOperator接受一个参数同为类型long,返回值类型也为long。   32 ObjDoubleConsumer接受一个object类型和一个double类型的输入参数，无返回值。   33 ObjIntConsumer接受一个object类型和一个int类型的输入参数，无返回值。   34 ObjLongConsumer接受一个object类型和一个long类型的输入参数，无返回值。   35 Predicate接受一个输入参数，返回一个布尔值结果。   36 Supplier无参数，返回一个结果。   37 ToDoubleBiFunction接受两个输入参数，返回一个double类型结果   38 ToDoubleFunction接受一个输入参数，返回一个double类型结果   39 ToIntBiFunction接受两个输入参数，返回一个int类型结果。   40 ToIntFunction接受一个输入参数，返回一个int类型结果。   41 ToLongBiFunction接受两个输入参数，返回一个long类型结果。   42 ToLongFunction接受一个输入参数，返回一个long类型结果。   43 UnaryOperator接受一个参数为类型T,返回值类型也为T。    函数式接口实例 Predicate  接口是一个函数式接口，它接受一个输入参数 T，返回一个布尔值结果。\n该接口包含多种默认方法来将Predicate组合成其他复杂的逻辑（比如：与，或，非）。\n该接口用于测试对象是 true 或 false。\n我们可以通过以下实例（Java8Tester.java）来了解函数式接口 Predicate  的使用：\nimport java.util.Arrays; import java.util.List; import java.util.function.Predicate; public class Java8Tester { public static void main(String args[]){ List\u0026lt;Integer\u0026gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); // Predicate\u0026lt;Integer\u0026gt; predicate = n -\u0026gt; true // n 是一个参数传递到 Predicate 接口的 test 方法 // n 如果存在则 test 方法返回 true System.out.println(\u0026quot;输出所有数据:\u0026quot;); // 传递参数 n eval(list, n-\u0026gt;true); // Predicate\u0026lt;Integer\u0026gt; predicate1 = n -\u0026gt; n%2 == 0 // n 是一个参数传递到 Predicate 接口的 test 方法 // 如果 n%2 为 0 test 方法返回 true System.out.println(\u0026quot;输出所有偶数:\u0026quot;); eval(list, n-\u0026gt; n%2 == 0 ); // Predicate\u0026lt;Integer\u0026gt; predicate2 = n -\u0026gt; n \u0026gt; 3 // n 是一个参数传递到 Predicate 接口的 test 方法 // 如果 n 大于 3 test 方法返回 true System.out.println(\u0026quot;输出大于 3 的所有数字:\u0026quot;); eval(list, n-\u0026gt; n \u0026gt; 3 ); } public static void eval(List\u0026lt;Integer\u0026gt; list, Predicate\u0026lt;Integer\u0026gt; predicate) { for(Integer n: list) { if(predicate.test(n)) { System.out.println(n + \u0026quot; \u0026quot;); } } } /* private static void eval(List\u0026lt;Integer\u0026gt; list, Predicate\u0026lt;Integer\u0026gt; predicate) { list.stream().filter(predicate).forEach(System.out::println); } */ }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester 输出所有数据: 1 2 3 4 5 6 7 8 9 输出所有偶数: 2 4 6 8 输出大于 3 的所有数字: 4 5 6 7 8 9  Java 8为函数式接口引入了一个新注解@FunctionalInterface，主要用于编译级错误检查，加上该注解，当你写的接口不符合函数式接口定义的时候，编译器会报错。\n提醒：加不加 @FunctionalInterface 对于接口是不是函数式接口没有影响，该注解只是提醒编译器去检查该接口是否仅包含一个抽象方法\n 函数式接口里允许定义默认方法  函数式接口里是可以包含默认方法，因为默认方法不是抽象方法，其有一个默认实现，所以是符合函数式接口的定义的； 如下代码不会报错：\n@FunctionalInterface interface GreetingService { void sayMessage(String message); default void doSomeMoreWork1() { // Method body } default void doSomeMoreWork2() { // Method body } }   函数式接口里允许定义静态方法  函数式接口里是可以包含静态方法，因为静态方法不能是抽象方法，是一个已经实现了的方法，所以是符合函数式接口的定义的； 如下代码不会报错：\n@FunctionalInterface interface GreetingService { void sayMessage(String message); static void printHello(){ System.out.println(\u0026quot;Hello\u0026quot;); } }   函数式接口里允许定义 java.lang.Object 里的 public 方法  函数式接口里是可以包含Object里的public方法，这些方法对于函数式接口来说，不被当成是抽象方法（虽然它们是抽象方法）；因为任何一个函数式接口的实现，默认都继承了 Object 类，包含了来自 java.lang.Object 里对这些抽象方法的实现； 如下代码不会报错：\n@FunctionalInterface interface GreetingService { void sayMessage(String message); @Override boolean equals(Object obj); }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/defaultmethod/",
	"title": "4. 默认方法",
	"tags": [],
	"description": "",
	"content": "Java 8 新增了接口的默认方法。\n简单说，默认方法就是接口可以有实现方法，而且不需要实现类去实现其方法。\n我们只需在方法名前面加个 default 关键字即可实现默认方法。\n为什么要有这个特性？\n首先，之前的接口是个双刃剑，好处是面向抽象而不是面向具体编程，缺陷是，当需要修改接口时候，需要修改全部实现该接口的类，目前的 java 8 之前的集合框架没有 foreach 方法，通常能想到的解决办法是在JDK里给相关的接口添加新的方法及实现。然而，对于已经发布的版本，是没法在给接口添加新方法的同时不影响已有的实现。所以引进的默认方法。他们的目的是为了解决接口的修改与现有的实现不兼容的问题。\n语法 默认方法语法格式如下：\npublic interface Vehicle { default void print(){ System.out.println(\u0026quot;我是一辆车!\u0026quot;); } }  多个默认方法 一个接口有默认方法，考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法，以下实例说明了这种情况的解决方法：\npublic interface Vehicle { default void print(){ System.out.println(\u0026quot;我是一辆车!\u0026quot;); } } public interface FourWheeler { default void print(){ System.out.println(\u0026quot;我是一辆四轮车!\u0026quot;); } }  第一个解决方案是创建自己的默认方法，来覆盖重写接口的默认方法：\npublic class Car implements Vehicle, FourWheeler { default void print(){ System.out.println(\u0026quot;我是一辆四轮汽车!\u0026quot;); } }  第二种解决方案可以使用 super 来调用指定接口的默认方法：\npublic class Car implements Vehicle, FourWheeler { public void print(){ Vehicle.super.print(); } }  静态默认方法 Java 8 的另一个特性是接口可以声明（并且可以提供实现）静态方法。例如：\npublic interface Vehicle { default void print(){ System.out.println(\u0026quot;我是一辆车!\u0026quot;); } // 静态方法 static void blowHorn(){ System.out.println(\u0026quot;按喇叭!!!\u0026quot;); } }  默认方法实例 我们可以通过以下代码来了解关于默认方法的使用，可以将代码放入 Java8Tester.java 文件中：\nJava8Tester.java 文件 public class Java8Tester { public static void main(String args[]){ Vehicle vehicle = new Car(); vehicle.print(); } } interface Vehicle { default void print(){ System.out.println(\u0026quot;我是一辆车!\u0026quot;); } static void blowHorn(){ System.out.println(\u0026quot;按喇叭!!!\u0026quot;); } } interface FourWheeler { default void print(){ System.out.println(\u0026quot;我是一辆四轮车!\u0026quot;); } } class Car implements Vehicle, FourWheeler { public void print(){ Vehicle.super.print(); FourWheeler.super.print(); Vehicle.blowHorn(); System.out.println(\u0026quot;我是一辆汽车!\u0026quot;); } }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester 我是一辆车! 我是一辆四轮车! 按喇叭!!! 我是一辆汽车!  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/stream/",
	"title": "5. Stream",
	"tags": [],
	"description": "",
	"content": " Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。\nStream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。\nStream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。\n这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。\n元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。\n Stream（流）是一个来自数据源的元素队列并支持聚合操作 元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。 数据源 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。 聚合操作 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。 和以前的Collection操作不同， Stream操作还有两个基础的特征：\n Pipelining: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。\n 内部迭代： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。\n生成流 在 Java 8 中, 集合接口有两个方法来生成流：\n stream() − 为集合创建串行流。\n parallelStream() − 为集合创建并行流。\nList\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;); List\u0026lt;String\u0026gt; filtered = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.toList());  forEach Stream 提供了新的方法 \u0026lsquo;forEach\u0026rsquo; 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：\nRandom random = new Random(); random.ints().limit(10).forEach(System.out::println);  map map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取对应的平方数 List\u0026lt;Integer\u0026gt; squaresList = numbers.stream().map( i -\u0026gt; i*i).distinct().collect(Collectors.toList());  filter filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：\nList\u0026lt;String\u0026gt;strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;); // 获取空字符串的数量 int count = strings.stream().filter(string -\u0026gt; string.isEmpty()).count();  limit limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：\nRandom random = new Random(); random.ints().limit(10).forEach(System.out::println);  sorted sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：\nRandom random = new Random(); random.ints().limit(10).sorted().forEach(System.out::println);  并行（parallel）程序 parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：\nList\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;); // 获取空字符串的数量 int count = strings.parallelStream().filter(string -\u0026gt; string.isEmpty()).count();  我们可以很容易的在顺序运行和并行直接切换。\n  Collectors Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：\nList\u0026lt;String\u0026gt;strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;); List\u0026lt;String\u0026gt; filtered = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(\u0026quot;筛选列表: \u0026quot; + filtered); String mergedString = strings.stream().filter(string -\u0026gt; !string.isEmpty()).collect(Collectors.joining(\u0026quot;, \u0026quot;)); System.out.println(\u0026quot;合并字符串: \u0026quot; + mergedString);  统计 另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。\nList\u0026lt;Integer\u0026gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics stats = numbers.stream().mapToInt((x) -\u0026gt; x).summaryStatistics(); System.out.println(\u0026quot;列表中最大的数 : \u0026quot; + stats.getMax()); System.out.println(\u0026quot;列表中最小的数 : \u0026quot; + stats.getMin()); System.out.println(\u0026quot;所有数之和 : \u0026quot; + stats.getSum()); System.out.println(\u0026quot;平均数 : \u0026quot; + stats.getAverage());  Stream 完整实例 将以下代码放入 Java8Tester.java 文件中：\nJava8Tester.java 文件 import java.util.ArrayList; import java.util.Arrays; import java.util.IntSummaryStatistics; import java.util.List; import java.util.Random; import java.util.stream.Collectors; import java.util.Map; public class Java8Tester { public static void main(String args[]){ System.out.println(\u0026quot;使用 Java 7: \u0026quot;); // 计算空字符串 List\u0026lt;String\u0026gt; strings = Arrays.asList(\u0026quot;abc\u0026quot;, \u0026quot;\u0026quot;, \u0026quot;bc\u0026quot;, \u0026quot;efg\u0026quot;, \u0026quot;abcd\u0026quot;,\u0026quot;\u0026quot;, \u0026quot;jkl\u0026quot;); System.out.println(\u0026quot;列表: \u0026quot; +strings); long count = getCountEmptyStringUsingJava7(strings); System.out.println(\u0026quot;空字符数量为: \u0026quot; + count); count = getCountLength3UsingJava7(strings); System.out.println(\u0026quot;字符串长度为 3 的数量为: \u0026quot; + count); // 删除空字符串 List\u0026lt;String\u0026gt; filtered = deleteEmptyStringsUsingJava7(strings); System.out.println(\u0026quot;筛选后的列表: \u0026quot; + filtered); // 删除空字符串，并使用逗号把它们合并起来 String mergedString = getMergedStringUsingJava7(strings,\u0026quot;, \u0026quot;); System.out.println(\u0026quot;合并字符串: \u0026quot; + mergedString); List\u0026lt;Integer\u0026gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取列表元素平方数 List\u0026lt;Integer\u0026gt; squaresList = getSquares(numbers); System.out.println(\u0026quot;平方数列表: \u0026quot; + squaresList); List\u0026lt;Integer\u0026gt; integers = Arrays.asList(1,2,13,4,15,6,17,8,19); System.out.println(\u0026quot;列表: \u0026quot; +integers); System.out.println(\u0026quot;列表中最大的数 : \u0026quot; + getMax(integers)); System.out.println(\u0026quot;列表中最小的数 : \u0026quot; + getMin(integers)); System.out.println(\u0026quot;所有数之和 : \u0026quot; + getSum(integers)); System.out.println(\u0026quot;平均数 : \u0026quot; + getAverage(integers)); System.out.println(\u0026quot;随机数: \u0026quot;); // 输出10个随机数 Random random = new Random(); for(int i=0; i \u0026lt; 10; i++){ System.out.println(random.nextInt()); } System.out.println(\u0026quot;使用 Java 8: \u0026quot;); System.out.println(\u0026quot;列表: \u0026quot; +strings); count = strings.stream().filter(string-\u0026gt;string.isEmpty()).count(); System.out.println(\u0026quot;空字符串数量为: \u0026quot; + count); count = strings.stream().filter(string -\u0026gt; string.length() == 3).count(); System.out.println(\u0026quot;字符串长度为 3 的数量为: \u0026quot; + count); filtered = strings.stream().filter(string -\u0026gt;!string.isEmpty()).collect(Collectors.toList()); System.out.println(\u0026quot;筛选后的列表: \u0026quot; + filtered); mergedString = strings.stream().filter(string -\u0026gt;!string.isEmpty()).collect(Collectors.joining(\u0026quot;, \u0026quot;)); System.out.println(\u0026quot;合并字符串: \u0026quot; + mergedString); squaresList = numbers.stream().map( i -\u0026gt;i*i).distinct().collect(Collectors.toList()); System.out.println(\u0026quot;Squares List: \u0026quot; + squaresList); System.out.println(\u0026quot;列表: \u0026quot; +integers); IntSummaryStatistics stats = integers.stream().mapToInt((x) -\u0026gt;x).summaryStatistics(); System.out.println(\u0026quot;列表中最大的数 : \u0026quot; + stats.getMax()); System.out.println(\u0026quot;列表中最小的数 : \u0026quot; + stats.getMin()); System.out.println(\u0026quot;所有数之和 : \u0026quot; + stats.getSum()); System.out.println(\u0026quot;平均数 : \u0026quot; + stats.getAverage()); System.out.println(\u0026quot;随机数: \u0026quot;); random.ints().limit(10).sorted().forEach(System.out::println); // 并行处理 count = strings.parallelStream().filter(string -\u0026gt; string.isEmpty()).count(); System.out.println(\u0026quot;空字符串的数量为: \u0026quot; + count); } private static int getCountEmptyStringUsingJava7(List\u0026lt;String\u0026gt; strings){ int count = 0; for(String string: strings){ if(string.isEmpty()){ count++; } } return count; } private static int getCountLength3UsingJava7(List\u0026lt;String\u0026gt; strings){ int count = 0; for(String string: strings){ if(string.length() == 3){ count++; } } return count; } private static List\u0026lt;String\u0026gt; deleteEmptyStringsUsingJava7(List\u0026lt;String\u0026gt; strings){ List\u0026lt;String\u0026gt; filteredList = new ArrayList\u0026lt;String\u0026gt;(); for(String string: strings){ if(!string.isEmpty()){ filteredList.add(string); } } return filteredList; } private static String getMergedStringUsingJava7(List\u0026lt;String\u0026gt; strings, String separator){ StringBuilder stringBuilder = new StringBuilder(); for(String string: strings){ if(!string.isEmpty()){ stringBuilder.append(string); stringBuilder.append(separator); } } String mergedString = stringBuilder.toString(); return mergedString.substring(0, mergedString.length()-2); } private static List\u0026lt;Integer\u0026gt; getSquares(List\u0026lt;Integer\u0026gt; numbers){ List\u0026lt;Integer\u0026gt; squaresList = new ArrayList\u0026lt;Integer\u0026gt;(); for(Integer number: numbers){ Integer square = new Integer(number.intValue() * number.intValue()); if(!squaresList.contains(square)){ squaresList.add(square); } } return squaresList; } private static int getMax(List\u0026lt;Integer\u0026gt; numbers){ int max = numbers.get(0); for(int i=1;i \u0026lt; numbers.size();i++){ Integer number = numbers.get(i); if(number.intValue() \u0026gt; max){ max = number.intValue(); } } return max; } private static int getMin(List\u0026lt;Integer\u0026gt; numbers){ int min = numbers.get(0); for(int i=1;i \u0026lt; numbers.size();i++){ Integer number = numbers.get(i); if(number.intValue() \u0026lt; min){ min = number.intValue(); } } return min; } private static int getSum(List numbers){ int sum = (int)(numbers.get(0)); for(int i=1;i \u0026lt; numbers.size();i++){ sum += (int)numbers.get(i); } return sum; } private static int getAverage(List\u0026lt;Integer\u0026gt; numbers){ return getSum(numbers) / numbers.size(); } } 执行以上脚本，输出结果为： $ javac Java8Tester.java $ java Java8Tester 使用 Java 7: 列表: [abc, , bc, efg, abcd, , jkl] 空字符数量为: 2 字符串长度为 3 的数量为: 3 筛选后的列表: [abc, bc, efg, abcd, jkl] 合并字符串: abc, bc, efg, abcd, jkl 平方数列表: [9, 4, 49, 25] 列表: [1, 2, 13, 4, 15, 6, 17, 8, 19] 列表中最大的数 : 19 列表中最小的数 : 1 所有数之和 : 85 平均数 : 9 随机数: -393170844 -963842252 447036679 -1043163142 -881079698 221586850 -1101570113 576190039 -1045184578 1647841045 使用 Java 8: 列表: [abc, , bc, efg, abcd, , jkl] 空字符串数量为: 2 字符串长度为 3 的数量为: 3 筛选后的列表: [abc, bc, efg, abcd, jkl] 合并字符串: abc, bc, efg, abcd, jkl Squares List: [9, 4, 49, 25] 列表: [1, 2, 13, 4, 15, 6, 17, 8, 19] 列表中最大的数 : 19 列表中最小的数 : 1 所有数之和 : 85 平均数 : 9.444444444444445 随机数: -1743813696 -1301974944 -1299484995 -779981186 136544902 555792023 1243315896 1264920849 1472077135 1706423674 空字符串的数量为: 2  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/optional/",
	"title": "6. Optional",
	"tags": [],
	"description": "",
	"content": " Optional 类是一个可以为null的容器对象。如果值存在则isPresent()方法会返回true，调用get()方法会返回该对象。\nOptional 是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。\nOptional 类的引入很好的解决空指针异常。\n类声明 以下是一个 java.util.Optional 类的声明：\npublic final class Optional\u0026lt;T\u0026gt; extends Object  类方法    序号 方法 \u0026amp; 描述     1 static  Optional empty()返回空的 Optional 实例。   2 boolean equals(Object obj)判断其他对象是否等于 Optional。   3 Optional filter(Predicate\u0026lt;? super  predicate)如果值存在，并且这个值匹配给定的 predicate，返回一个Optional用以描述这个值，否则返回一个空的Optional。   4  Optional flatMap(Function\u0026lt;? super T,Optional\u0026gt; mapper)如果值存在，返回基于Optional包含的映射方法的值，否则返回一个空的Optional   5 T get()如果在这个Optional中包含这个值，返回值，否则抛出异常：NoSuchElementException   6 int hashCode()返回存在值的哈希码，如果值不存在 返回 0。   7 void ifPresent(Consumer\u0026lt;? super T\u0026gt; consumer)如果值存在则使用该值调用 consumer , 否则不做任何事情。   8 boolean isPresent()如果值存在则方法会返回true，否则返回 false。   9 Optional map(Function\u0026lt;? super T,? extends U\u0026gt; mapper)如果有值，则对其执行调用映射函数得到返回值。如果返回值不为 null，则创建包含映射返回值的Optional作为map方法返回值，否则返回空Optional。   10 static  Optional of(T value)返回一个指定非null值的Optional。   11 static  Optional ofNullable(T value)如果为非空，返回 Optional 描述的指定值，否则返回空的 Optional。   12 T orElse(T other)如果存在该值，返回值， 否则返回 other。   13 T orElseGet(Supplier\u0026lt;? extends T\u0026gt; other)如果存在该值，返回值， 否则触发 other，并返回 other 调用的结果。   14 T orElseThrow(Supplier\u0026lt;? extends X\u0026gt; exceptionSupplier)如果存在该值，返回包含的值，否则抛出由 Supplier 继承的异常   15 String toString()返回一个Optional的非空字符串，用来调试    注意： 这些方法是从 java.lang.Object 类继承来的。\nOptional 实例 我们可以通过以下实例来更好的了解 Optional 类的使用：\nJava8Tester.java 文件\nimport java.util.Optional; public class Java8Tester { public static void main(String args[]){ Java8Tester java8Tester = new Java8Tester(); Integer value1 = null; Integer value2 = new Integer(10); // Optional.ofNullable - 允许传递为 null 参数 Optional\u0026lt;Integer\u0026gt; a = Optional.ofNullable(value1); // Optional.of - 如果传递的参数是 null，抛出异常 NullPointerException Optional\u0026lt;Integer\u0026gt; b = Optional.of(value2); System.out.println(java8Tester.sum(a,b)); } public Integer sum(Optional\u0026lt;Integer\u0026gt; a, Optional\u0026lt;Integer\u0026gt; b){ // Optional.isPresent - 判断值是否存在 System.out.println(\u0026quot;第一个参数值存在: \u0026quot; + a.isPresent()); System.out.println(\u0026quot;第二个参数值存在: \u0026quot; + b.isPresent()); // Optional.orElse - 如果值存在，返回它，否则返回默认值 Integer value1 = a.orElse(new Integer(0)); //Optional.get - 获取值，值需要存在 Integer value2 = b.get(); return value1 + value2; } }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester 第一个参数值存在: false 第二个参数值存在: true 10  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/nashorn/",
	"title": "7. Nashorn JavaScript",
	"tags": [],
	"description": "",
	"content": " Nashorn 一个 javascript 引擎。\n从JDK 1.8开始，Nashorn取代Rhino(JDK 1.6, JDK1.7)成为Java的嵌入式JavaScript引擎。Nashorn完全支持ECMAScript 5.1规范以及一些扩展。它使用基于JSR 292的新语言特性，其中包含在JDK 7中引入的 invokedynamic，将JavaScript编译成Java字节码。\n与先前的Rhino实现相比，这带来了2到10倍的性能提升。\njjs jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。\n例如，我们创建一个具有如下内容的sample.js文件：\nprint('Hello World!');  打开控制台，输入以下命令：\n$ jjs sample.js  以上程序输出结果为：\nHello World!  jjs 交互式编程 打开控制台，输入以下命令：\n$ jjs jjs\u0026gt; print(\u0026quot;Hello, World!\u0026quot;) Hello, World! jjs\u0026gt; quit() \u0026gt;\u0026gt;  传递参数 打开控制台，输入以下命令：\n$ jjs -- a b c jjs\u0026gt; print('字母: ' +arguments.join(\u0026quot;, \u0026quot;)) 字母: a, b, c jjs\u0026gt;  Java 中调用 JavaScript 使用 ScriptEngineManager, JavaScript 代码可以在 Java 中执行，实例如下：\nJava8Tester.java 文件\nimport javax.script.ScriptEngineManager; import javax.script.ScriptEngine; import javax.script.ScriptException; public class Java8Tester { public static void main(String args[]){ ScriptEngineManager scriptEngineManager = new ScriptEngineManager(); ScriptEngine nashorn = scriptEngineManager.getEngineByName(\u0026quot;nashorn\u0026quot;); String name = \u0026quot;Runoob\u0026quot;; Integer result = null; try { nashorn.eval(\u0026quot;print('\u0026quot; + name + \u0026quot;')\u0026quot;); result = (Integer) nashorn.eval(\u0026quot;10 + 2\u0026quot;); }catch(ScriptException e){ System.out.println(\u0026quot;执行脚本错误: \u0026quot;+ e.getMessage()); } System.out.println(result.toString()); } }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester Runoob 12  JavaScript 中调用 Java 以下实例演示了如何在 JavaScript 中引用 Java 类：\nvar BigDecimal = Java.type('java.math.BigDecimal'); function calculate(amount, percentage) { var result = new BigDecimal(amount).multiply( new BigDecimal(percentage)).divide(new BigDecimal(\u0026quot;100\u0026quot;), 2, BigDecimal.ROUND_HALF_EVEN); return result.toPlainString(); } var result = calculate(568000000000000000023,13.9); print(result);  我们使用 jjs 命令执行以上脚本，输出结果如下：\n$ jjs sample.js 78952000000000002017.94  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/dateapi/",
	"title": "8. 日期时间 API",
	"tags": [],
	"description": "",
	"content": " Java 8通过发布新的Date-Time API (JSR 310)来进一步加强对日期与时间的处理。\n在旧版的 Java 中，日期时间 API 存在诸多问题，其中有：\n 非线程安全 − java.util.Date 是非线程安全的，所有的日期类都是可变的，这是Java日期类最大的问题之一。\n 设计很差 − Java的日期/时间类的定义并不一致，在java.util和java.sql的包中都有日期类，此外用于格式化和解析的类在java.text包中定义。java.util.Date同时包含日期和时间，而java.sql.Date仅包含日期，将其纳入java.sql包并不合理。另外这两个类都有相同的名字，这本身就是一个非常糟糕的设计。\n 时区处理麻烦 − 日期类并不提供国际化，没有时区支持，因此Java引入了java.util.Calendar和java.util.TimeZone类，但他们同样存在上述所有的问题。\n  Java 8 在 java.time 包下提供了很多新的 API。以下为两个比较重要的 API：\n Local(本地) − 简化了日期时间的处理，没有时区的问题。\n Zoned(时区) − 通过制定的时区处理日期时间。\n  新的java.time包涵盖了所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作。\n本地化日期时间 API LocalDate/LocalTime 和 LocalDateTime 类可以在处理时区不是必须的情况。代码如下：\nJava8Tester.java 文件 import java.time.LocalDate; import java.time.LocalTime; import java.time.LocalDateTime; import java.time.Month; public class Java8Tester { public static void main(String args[]){ Java8Tester java8tester = new Java8Tester(); java8tester.testLocalDateTime(); } public void testLocalDateTime(){ // 获取当前的日期时间 LocalDateTime currentTime = LocalDateTime.now(); System.out.println(\u0026quot;当前时间: \u0026quot; + currentTime); LocalDate date1 = currentTime.toLocalDate(); System.out.println(\u0026quot;date1: \u0026quot; + date1); Month month = currentTime.getMonth(); int day = currentTime.getDayOfMonth(); int seconds = currentTime.getSecond(); System.out.println(\u0026quot;月: \u0026quot; + month +\u0026quot;, 日: \u0026quot; + day +\u0026quot;, 秒: \u0026quot; + seconds); LocalDateTime date2 = currentTime.withDayOfMonth(10).withYear(2012); System.out.println(\u0026quot;date2: \u0026quot; + date2); // 12 december 2014 LocalDate date3 = LocalDate.of(2014, Month.DECEMBER, 12); System.out.println(\u0026quot;date3: \u0026quot; + date3); // 22 小时 15 分钟 LocalTime date4 = LocalTime.of(22, 15); System.out.println(\u0026quot;date4: \u0026quot; + date4); // 解析字符串 LocalTime date5 = LocalTime.parse(\u0026quot;20:15:30\u0026quot;); System.out.println(\u0026quot;date5: \u0026quot; + date5); } }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester 当前时间: 2016-04-15T16:55:48.668 date1: 2016-04-15 月: APRIL, 日: 15, 秒: 48 date2: 2012-04-10T16:55:48.668 date3: 2014-12-12 date4: 22:15 date5: 20:15:30  使用时区的日期时间API 如果我们需要考虑到时区，就可以使用时区的日期时间API：\nJava8Tester.java 文件 import java.time.ZonedDateTime; import java.time.ZoneId; public class Java8Tester { public static void main(String args[]){ Java8Tester java8tester = new Java8Tester(); java8tester.testZonedDateTime(); } public void testZonedDateTime(){ // 获取当前时间日期 ZonedDateTime date1 = ZonedDateTime.parse(\u0026quot;2015-12-03T10:15:30+05:30[Asia/Shanghai]\u0026quot;); System.out.println(\u0026quot;date1: \u0026quot; + date1); ZoneId id = ZoneId.of(\u0026quot;Europe/Paris\u0026quot;); System.out.println(\u0026quot;ZoneId: \u0026quot; + id); ZoneId currentZone = ZoneId.systemDefault(); System.out.println(\u0026quot;当期时区: \u0026quot; + currentZone); } }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester date1: 2015-12-03T10:15:30+08:00[Asia/Shanghai] ZoneId: Europe/Paris 当期时区: Asia/Shanghai  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/base64/",
	"title": "9. Base64",
	"tags": [],
	"description": "",
	"content": " 在Java 8中，Base64编码已经成为Java类库的标准。\nJava 8 内置了 Base64 编码的编码器和解码器。\nBase64工具类提供了一套静态方法获取下面三种BASE64编解码器：\n 基本：输出被映射到一组字符A-Za-z0-9+/，编码不添加任何行标，输出的解码仅支持A-Za-z0-9+/。 URL：输出映射到一组字符A-Za-z0-9+_,输出是URL和文件。 MIME：输出隐射到MIME友好格式。输出每行不超过76字符，并且使用\u0026rsquo;\\r\u0026rsquo;并跟随\u0026rsquo;\\n\u0026rsquo;作为分割。编码输出最后没有行分割。\n内嵌类    序号 内嵌类 \u0026amp; 描述     1 static class Base64.Decoder该类实现一个解码器用于，使用 Base64 编码来解码字节数据。   2 static class Base64.Encoder该类实现一个编码器，使用 Base64 编码来编码字节数据。     方法    序号 方法名 \u0026amp; 描述     1 static Base64.Decoder getDecoder()返回一个 Base64.Decoder ，解码使用基本型 base64 编码方案。   2 static Base64.Encoder getEncoder()返回一个 Base64.Encoder ，编码使用基本型 base64 编码方案。   3 static Base64.Decoder getMimeDecoder()返回一个 Base64.Decoder ，解码使用 MIME 型 base64 编码方案。   4 static Base64.Encoder getMimeEncoder()返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案。   5 static Base64.Encoder getMimeEncoder(int lineLength, byte[] lineSeparator)返回一个 Base64.Encoder ，编码使用 MIME 型 base64 编码方案，可以通过参数指定每行的长度及行的分隔符。   6 static Base64.Decoder getUrlDecoder()返回一个 Base64.Decoder ，解码使用 URL 和文件名安全型 base64 编码方案。   7 static Base64.Encoder getUrlEncoder()返回一个 Base64.Encoder ，编码使用 URL 和文件名安全型 base64 编码方案。    注意：Base64 类的很多方法从 java.lang.Object 类继承。\nBase64 实例 以下实例演示了 Base64 的使用:\nJava8Tester.java 文件 import java.util.Base64; import java.util.UUID; import java.io.UnsupportedEncodingException; public class Java8Tester { public static void main(String args[]){ try { // 使用基本编码 String base64encodedString = Base64.getEncoder().encodeToString(\u0026quot;runoob?java8\u0026quot;.getBytes(\u0026quot;utf-8\u0026quot;)); System.out.println(\u0026quot;Base64 编码字符串 (基本) :\u0026quot; + base64encodedString); // 解码 byte[] base64decodedBytes = Base64.getDecoder().decode(base64encodedString); System.out.println(\u0026quot;原始字符串: \u0026quot; + new String(base64decodedBytes, \u0026quot;utf-8\u0026quot;)); base64encodedString = Base64.getUrlEncoder().encodeToString(\u0026quot;TutorialsPoint?java8\u0026quot;.getBytes(\u0026quot;utf-8\u0026quot;)); System.out.println(\u0026quot;Base64 编码字符串 (URL) :\u0026quot; + base64encodedString); StringBuilder stringBuilder = new StringBuilder(); for (int i = 0; i \u0026lt; 10; ++i) { stringBuilder.append(UUID.randomUUID().toString()); } byte[] mimeBytes = stringBuilder.toString().getBytes(\u0026quot;utf-8\u0026quot;); String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes); System.out.println(\u0026quot;Base64 编码字符串 (MIME) :\u0026quot; + mimeEncodedString); }catch(UnsupportedEncodingException e){ System.out.println(\u0026quot;Error :\u0026quot; + e.getMessage()); } } }  执行以上脚本，输出结果为：\n$ javac Java8Tester.java $ java Java8Tester 原始字符串: runoob?java8 Base64 编码字符串 (URL) :VHV0b3JpYWxzUG9pbnQ_amF2YTg= Base64 编码字符串 (MIME) :M2Q4YmUxMTEtYWRkZi00NzBlLTgyZDgtN2MwNjgzOGY2NGFlOTQ3NDYyMWEtZDM4ZS00YWVhLTkz OTYtY2ZjMzZiMzFhNmZmOGJmOGI2OTYtMzkxZi00OTJiLWEyMTQtMjgwN2RjOGI0MTBmZWUwMGNk NTktY2ZiZS00MTMxLTgzODctNDRjMjFkYmZmNGM4Njg1NDc3OGItNzNlMC00ZWM4LTgxNzAtNjY3 NTgyMGY3YzVhZWQyMmNiZGItOTIwZi00NGUzLTlkMjAtOTkzZTI1MjUwMDU5ZjdkYjg2M2UtZTJm YS00Y2Y2LWIwNDYtNWQ2MGRiOWQyZjFiMzJhMzYxOWQtNDE0ZS00MmRiLTk3NDgtNmM4NTczYjMx ZDIzNGRhOWU4NDAtNTBiMi00ZmE2LWE0M2ItZjU3MWFiNTI2NmQ2NTlmMTFmZjctYjg1NC00NmE1 LWEzMWItYjk3MmEwZTYyNTdk  "
},
{
	"uri": "https://peterhan-enjoy.github.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/dae2gltf/",
	"title": "Dae转换Gltf",
	"tags": [],
	"description": "",
	"content": "下载地址 提取码：e4aq\n系统启动时生成启动文件\n import com.nuclear_Project.common.bean.SystemConfig; import org.apache.commons.lang3.BooleanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationEvent; import org.springframework.context.ApplicationListener; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.context.event.ContextClosedEvent; import org.springframework.context.event.ContextRefreshedEvent; import org.springframework.core.env.Environment; import org.springframework.stereotype.Service; import java.io.BufferedWriter; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStreamWriter; /** * 启动监听器\u0026lt;br /\u0026gt; * 1,初始化系统参数 * */ @Service @Configuration @PropertySource(\u0026quot;classpath:system.properties\u0026quot;) public class SystemStartLister implements ApplicationListener\u0026lt;ApplicationEvent\u0026gt; { @Autowired private Environment env; @Override public void onApplicationEvent(ApplicationEvent event) { try { String path = System.getProperty(\u0026quot;Nuclear_Project.root\u0026quot;); String collpath = path+\u0026quot;\\\\daetogltf\\\\COLLADA2GLTF-v2.1.4-windows-Release-x64\u0026quot;; String batpath = path+\u0026quot;\\\\daetogltf\\\\test.bat\u0026quot;; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\u0026quot;cd /d \u0026quot;+collpath); stringBuilder.append(System.getProperty(\u0026quot;line.separator\u0026quot;)); stringBuilder.append(collpath+\u0026quot;\\\\COLLADA2GLTF-bin.exe \u0026quot;); stringBuilder.append(\u0026quot;-f %1 -e\u0026quot;); stringBuilder.append(System.getProperty(\u0026quot;line.separator\u0026quot;)); stringBuilder.append(\u0026quot;exit\u0026quot;); File file = new File(batpath); OutputStreamWriter write = new OutputStreamWriter(new FileOutputStream(file), \u0026quot;GBK\u0026quot;); BufferedWriter writer = new BufferedWriter(write); writer.write(stringBuilder.toString()); writer.close(); write.close(); SystemConfig.batpath = batpath; }catch (Exception e){ e.printStackTrace(); } } } }  执行调用\npackage com.nuclear_Project.common.util; import com.nuclear_Project.common.bean.SystemConfig; import com.nuclear_Project.common.service.FileService; import com.nuclear_Project.model.bean.Model; import java.io.File; /** * @Auther: Han Youqi * @Date: 2019/5/7 15:42 * @Description: */ public class GltfUitl { public static Model daeToGltf(Model model){ String path = model.getModelUrl(); //将dae转化为gltf Process process = null; try { Runtime runtime = Runtime.getRuntime(); process = runtime.exec(\u0026quot;cmd /k start \u0026quot;+ SystemConfig.batpath +\u0026quot; \u0026quot;+path); Thread.sleep(3000); String finalPath = path.replace(\u0026quot;.dae\u0026quot;,\u0026quot;.gltf\u0026quot;); StringBuilder sb = new StringBuilder(finalPath); sb.insert(finalPath.lastIndexOf(\u0026quot;\\\\\u0026quot;),\u0026quot;\\\\output\u0026quot;); int index = sb.toString().indexOf(\u0026quot;upload\u0026quot;); String filePath = sb.toString().substring(index); String url = filePath.replaceAll(\u0026quot;\\\\\\\\\u0026quot;,\u0026quot;/\u0026quot;); model.setModelUrl(url); } catch (Exception e) { e.printStackTrace(); }finally { if (process != null){ process.destroy(); } } return model; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/web/es6/",
	"title": "ES6",
	"tags": [],
	"description": "",
	"content": " hello-es6 1.ES6怎么来的  ECMAScript 和 JavaScript\n ECMA 是标准，JS 是实现 ECMAScript 简称 ECMA 或 ES  历史版本\n 1996, ES1.0 Netscape 将 JS 提交给 ECMA 组织，ES 正式出现 1999, ES3.0 被广泛支持 2011, ES5.1 成为 ISO 国际标准 2015, ES6.0 正式发布   2.ES6兼容性  ES6(ES2015) 支持的环境 IE10+, Chrome, FireFox, 移动端, NodeJS 解决不兼容办法，编译、转换\n 在线转换 或者提前编译  Babel 中文网\n Babel 入门教程 阮一峰 Babel 是一个 JavaScript 编译器 一个广泛使用的转码器，可以将ES6代码转为ES5代码，从而在现有环境执行 现在就用 ES6 编写程序，而不用担心现有环境是否支持   3.变量 let 和 常量 const  var 的问题\n 可以重复声明，没有报错和警告 无法限制修改 没有块级作用域， { }  let 和 const\n 不能重复声明 都是块级作用域, { } 块内声明的，块外无效 let 是变量，可以修改 const 是常量，不能修改  块级作用域举例\n 原来用 var 的方式，结果弹出的都是 3 或者将变量 封装到函数里，限制作用域，但比较麻烦 用 let 最简单，直接 var 改 let，解决作用域问题   \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; window.onload= function () { /* var aBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;) for (var i=0; i \u0026lt; aBtn.length; i++) { aBtn[i].onclick = function () { alert(i) } }*/ var aBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;) for (let i = 0; i \u0026lt; aBtn.length; i++) { aBtn[i].onclick = function () { alert(i) } } /* var aBtn = document.getElementsByTagName(\u0026#39;input\u0026#39;) for (var i = 0; i \u0026lt; aBtn.length; i++) { // 封装到函数里，限制作用域 (function (i) { aBtn[i].onclick = function () { alert(i) } })(i) }*/ } \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;按钮1\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;按钮2\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;按钮3\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 4.函数-箭头函数  箭头函数，就是函数的简写  如果只有一个参数，() 可以省 如果只有一个return，{}可以省   // 普通函数 function name() { } // 箭头函数，去掉 function， 加上 =\u0026gt; () =\u0026gt; { } let show1 = function () { console.log(\u0026#39;abc\u0026#39;) } let show2 = () =\u0026gt; { console.log(\u0026#39;abc\u0026#39;) } show1() // 调用函数 show2() let show4 = function (a) { return a*2 } let show5 = a =\u0026gt; a * 2 //简洁，类似python lambda 函数  console.log(show4(10)) console.log(show5(10))  5.函数-参数  参数扩展／展开 ...args  收集剩余的参数，必须当到最后一个参数位置 展开数组，简写，效果和直接把数组的内容写在这儿一样  默认参数  function show(a, b, ...args) { console.log(a) console.log(b) console.log(args) } console.log(show(1, 2, 3, 4, 5)) let arr1 = [1, 2, 3] let arr2 = [4, 5, 6] let arr3 = [...arr1, ...arr2] console.log(arr3) function show2(a, b=5, c=8) { console.log(a, b, c) } show2(88, 12)  6.解构赋值 let [a, b, c] = [1, 2, 3] console.log(a, b, c) let {x, y, z} = {x: 1, y: 2, z: 3} console.log(x, y, z) let [json, arr, num, str] = [{ a: 1, b: 2 }, [1, 2, 3], 8, \u0026#39;str\u0026#39;] console.log(json, arr, num, str)   解构赋值  左右两个边结构必须一样 右边必须是个东西 声明和赋值赋值不能分开，必须在一句话里   7.数组  新增4个方法 map 映射 一个对一个  let arr = [12, 5, 8] let result = arr.map(function (item) { return item*2 }) let result2 = arr.map(item=\u0026gt;item*2) // 简写 console.log(result) console.log(result2) let score = [18, 86, 88, 24] let result3 = score.map(item =\u0026gt; item \u0026gt;= 60 ? \u0026#39;及格\u0026#39; : \u0026#39;不及格\u0026#39;) console.log(result3) // 结果 [ 24, 10, 16 ] [ 24, 10, 16 ] [ \u0026#39;不及格\u0026#39;, \u0026#39;及格\u0026#39;, \u0026#39;及格\u0026#39;, \u0026#39;不及格\u0026#39; ]   reduce 汇总 一堆出来一个  用于比如，算个总数，算个平均   var arr = [1, 3, 5, 7] var result = arr.reduce(function (tmp, item, index) { //tmp 上次结果，item当前数，index次数1开始  console.log(tmp, item, index) return tmp + item }) console.log(result) var arr = [1, 3, 5, 7] var result = arr.reduce(function (tmp, item, index) { if (index != arr.length - 1) { // 不是最后一次  return tmp + item } else { return (tmp + item)/arr.length } }) console.log(result) // 平均值   filter 过滤器 保留为true的  var arr = [12, 4, 8, 9] var result = arr.filter(item =\u0026gt; (item % 3 === 0) ? true : false) console.log(result) var result = arr.filter(item =\u0026gt; item % 3 === 0) console.log(result) var arr = [ { title: \u0026#39;苹果\u0026#39;, price: 10 }, { title: \u0026#39;西瓜\u0026#39;, price: 20 }, ] var result = arr.filter(json =\u0026gt; json.price \u0026gt;= 20) console.log(result)   forEach 循环迭代  var arr = [12, 4, 8, 9] var result = arr.forEach(item =\u0026gt; console.log(item)) var result = arr.forEach((item, index)=\u0026gt;console.log(item, index))  8.字符串  多了两个新方法  startsWith endsWith   var url = \u0026#39;http://qq.com\u0026#39; console.log(url.startsWith(\u0026#39;http\u0026#39;)) console.log(url.endsWith(\u0026#39;com\u0026#39;)) // 都是 true   字符串模版  使用反引号，${变量} 可以折行   let a = 12 let str1 = `asdf${a}` console.log(str1) let title = \u0026#39;标题\u0026#39; let content = \u0026#39;内容\u0026#39; let str = `\u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;${title}\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;${content}\u0026lt;/p\u0026gt; ` console.log(str) \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;内容\u0026lt;/p\u0026gt;  9.面向对象-基础  原来写法  类和构造函数一样 属性和方法分开写的   // 老版本 function User(name, pass) { this.name = name this.pass = pass } User.prototype.showName = function () { console.log(this.name) } User.prototype.showPass = function () { console.log(this.pass) } var u1 = new User(\u0026#39;able\u0026#39;, \u0026#39;1233\u0026#39;) u1.showName() u1.showPass() // 老版本继承 function VipUser(name, pass, level) { User.call(this, name, pass) this.level = level } VipUser.prototype = new User() VipUser.prototype.constructor = VipUser VipUser.prototype.showLevel = function () { console.log(this.level) } var v1 = new VipUser(\u0026#39;blue\u0026#39;, \u0026#39;1234\u0026#39;, 3) v1.showName() v1.showLevel()   新版面向对象  有了 class 关键字、构造器 class 里面直接加方法 继承，super 超类==父类   class User { constructor(name, pass) { this.name = name this.pass = pass } showName() { console.log(this.name) } showPass() { console.log(this.pass) } } var u1 = new User(\u0026#39;able2\u0026#39;, \u0026#39;111\u0026#39;) u1.showName() u1.showPass() // 新版本继承 class VipUser extends User { constructor(name, pass, level) { super(name, pass) this.level = level } showLevel(){ console.log(this.level) } } v1 = new VipUser(\u0026#39;blue\u0026#39;, \u0026#39;123\u0026#39;, 3) v1.showLevel()  10.面向对象应用  React  用于构建用户界面的 JavaScript 库 组件化，一个组件就是一个 class JSX == bable == browser.js   11.json  JSON 格式\n JavaScript Object Notation 的缩写，是一种用于数据交换的文本格式 JSON 是 JS对象 的严格子集 JSON 的标准写法 只能用双引号 所有的key都必须用双引号包起来  JSON 对象\n JSON 对象是 JavaScript 的原生对象，用来处理 JSON 格式数据，有两个静态方法 JSON.parse(string) ：接受一个 JSON 字符串并将其转换成一个 JavaScript 对象。 JSON.stringify(obj) ：接受一个 JavaScript 对象并将其转换为一个 JSON 字符串。   var json = {a: 12, b: 5} var str = \u0026#39;hi,\u0026#39; + JSON.stringify(json) var url = \u0026#39;http://www.xx.com/\u0026#39; + encodeURIComponent(JSON.stringify(json)) console.log(str) console.log(url) var str = \u0026#39;{\u0026#34;a\u0026#34;: 12, \u0026#34;b\u0026#34;: 4, \u0026#34;c\u0026#34;: \u0026#34;abc\u0026#34;}\u0026#39; var json = JSON.parse(str) console.log(json) hi,{\u0026#34;a\u0026#34;:12,\u0026#34;b\u0026#34;:5} http://www.xx.com/%7B%22a%22%3A12%2C%22b%22%3A5%7D { a: 12, b: 4, c: \u0026#39;abc\u0026#39; }   对象（object）\n 是 JavaScript 语言的核心概念，也是最重要的数据类型 对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合 对象的所有键名都是字符串, 所以加不加引号都可以 如果键名是数值，会被自动转为字符串 对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型 如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用 in 运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值 for\u0026hellip;in循环用来遍历一个对象的全部属性  对象 简写\n key-value 一样时可以简写 里面函数可以简写, 去掉   var a = 12, b = 5 console.log({a:a, b:b}) console.log({a, b}) console.log({a, b, c:\u0026#34;c\u0026#34;}) console.log({ a, b, show(){ console.log(\u0026#39;a\u0026#39;) }}) { a: 12, b: 5 } { a: 12, b: 5 } { a: 12, b: 5, c: \u0026#39;c\u0026#39; } { a: 12, b: 5, show: [Function: show] }  12.Promise  异步和同步\n 异步，操作之间没有关系，同时执行多个操作， 代码复杂 同步，同时只能做一件事，代码简单  Promise 对象\n 用同步的方式来书写异步代码 Promise 让异步操作写起来，像在写同步操作的流程，不必一层层地嵌套回调函数 改善了可读性，对于多层嵌套的回调函数很方便 充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口  Promise 也是一个构造函数\n 接受一个回调函数f1作为参数，f1里面是异步操作的代码 返回的p1就是一个 Promise 实例 所有异步任务都返回一个 Promise 实例 Promise 实例有一个then方法，用来指定下一步的回调函数   function f1(resolve, reject) { // 异步代码... } var p1 = new Promise(f1); p1.then(f2); // f1的异步操作执行完成，就会执行f2。   Promise 使得异步流程可以写成同步流程  // 传统写法 step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // ...  }); }); }); }); // Promise 的写法 (new Promise(step1)) .then(step2) .then(step3) .then(step4);   Promise.all(promiseArray)方法  将多个Promise对象实例包装，生成并返回一个新的Promise实例 promise数组中所有的promise实例都变为resolve的时候，该方法才会返回 并将所有结果传递results数组中 promise数组中任何一个promise为reject的话，则整个Promise.all调用会立即终止，并返回一个reject的新的promise对象   var p1 = Promise.resolve(1), p2 = Promise.resolve(2), p3 = Promise.resolve(3); Promise.all([p1, p2, p3]).then(function (results) { console.log(results); // [1, 2, 3] });   Promise.race([p1, p2, p3])  Promse.race就是赛跑的意思 哪个结果获得的快，就返回那个结果 不管结果本身是成功状态还是失败状态   13.generator-认识生成器函数  generator 生成器函数  普通函数，一路到底 generator函数，中间可以停，到哪停呢，用 yield 配合，交出执行权 yield 有 放弃、退让、退位的意思 需要调用next()方法启动执行，需要遇到 yield 停, 踹一脚走一步 generator函数前面加一个 * 两边可以有空格，或靠近函数或function 背后实际生成多个小函数，实现走走停停   function show() { console.log(\u0026#39;a\u0026#39;) console.log(\u0026#39;b\u0026#39;) } show() // 普通函数  function *show2() { console.log(\u0026#39;1\u0026#39;) yield console.log(\u0026#39;2\u0026#39;) } let genObj = show2() genObj.next() // 1 genObj.next() // 2 genObj.next() // 最后了，没有结果  14.generator-yield是啥  yield\n 既可传参，又可以返回 第一个next()传参无效，只用来启动  如果函数前漏掉 *\n 就是普通函数 如果有yield会报错， ReferenceError: yield is not defined yield 只能在Generator函数内部使用   function * show() { console.log(\u0026#39;1\u0026#39;) var a = yield console.log(\u0026#39;2\u0026#39;) console.log(a) } // yield 传参 var gen = show() gen.next() // 1 gen.next() // 2 和 undefined 因为没有传参，yield没有返回值 var gen = show() gen.next(10) // 1 第一次执行到yield，但没有执行赋值 gen.next(20) // 2 和 20  function* show2() { console.log(\u0026#39;1\u0026#39;) yield 10 console.log(\u0026#39;2\u0026#39;) } // yield 返回 var gen = show2() var res1 = gen.next() console.log(res1) // { value: 10, done: false } var res2 = gen.next() console.log(res2) // { value: undefined, done: true } 最后的value需要return返回  15.generator-实例  Promise 适合一次读一组 generator 适合逻辑性的  // 带逻辑-generator runner(function * () { let userData = yield $.ajax({url: \u0026#39;getUserData\u0026#39;}) if (userData.type == \u0026#39;VIP\u0026#39;) { let items = yield $.ajax({url: \u0026#39;getVIPItems\u0026#39;}) } else { let items = yield $.ajax({url: \u0026#39;getItems\u0026#39;}) } }) // yield 实例，用同步方式写异步 server.use(function * () { let data = yield db.query(`select * from user_table`) this.body = data })  16.ES7 预览  数组  arr.includes() 数组是否包含某个东西 数组的 arr.keys(), arr,entries() for \u0026hellip; in 遍历数组 下标 key for \u0026hellip; of 遍历数组 值 value, 不能用于json   let arr = [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] console.log(arr.includes(1)) for (let i in arr) { console.log(i) // 循环的时下标 key } for (let i of arr) { console.log(i) // 循环的是值 value } for (let i of arr.keys()) { console.log(\u0026#39;\u0026gt;\u0026#39;+i) } for (let [key, value] of arr.entries()) { console.log(\u0026#39;\u0026gt;\u0026#39; + key + value) } let json = { a: 12, b: 5, c: 7 } for (let i in json) { console.log(i) }   字符串  padStart()/padEnd() 指定宽度，不够就补空格或指定字符   console.log(\u0026#39;=\u0026#39; + \u0026#39;abcd\u0026#39;.padStart(6, \u0026#39;0\u0026#39;) + \u0026#39;=\u0026#39;) console.log(\u0026#39;=\u0026#39; + \u0026#39;abcd\u0026#39;.padEnd(6, \u0026#39;0\u0026#39;) + \u0026#39;=\u0026#39;) =00abcd= =abcd00=   容忍度\n [1, 2, 3,] 老版数组最后不能有逗号，新的可以有 函数参数最后多的逗号也可以  async await\n 和 generator yield 类似 generator 不可以写成箭头函数， async 可以   async function show() { console.log(1) await console.log(2) } "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/excelutil/",
	"title": "Excel工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Type; import java.util.ArrayList; import java.util.Date; import java.util.List; import org.apache.poi.hssf.usermodel.HSSFCell; import org.apache.poi.hssf.usermodel.HSSFRow; import org.apache.poi.hssf.usermodel.HSSFSheet; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.poifs.filesystem.NotOLE2FileException; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.CreationHelper; import org.apache.poi.ss.usermodel.DateUtil; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.xssf.usermodel.XSSFCell; import org.apache.poi.xssf.usermodel.XSSFRow; import org.apache.poi.xssf.usermodel.XSSFSheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; /** * 将Excel文件读入到一个List集合中，必须给出“属性”(fields)，会按照给定的属性列表遍历该属性\u0026lt;br /\u0026gt; * 然后调用该属性的set方法赋值 ， 并添加到List集合中 \u0026lt;br /\u0026gt; * 注意:给出的属性应和Excel文件的列一一对应，否则会出现异常 * */ public class ExcelUtil\u0026lt;T\u0026gt; { private File file; private InputStream inputStream; private int ignoreRow = 1;// 忽略的行数 private Class\u0026lt;T\u0026gt; entityClass = null; private String[] fields;// 要写入的字段 private String[] header; private String sheetName = \u0026quot;sheet1\u0026quot;; private String par = \u0026quot;yyyy-MM-dd\u0026quot;; private static final String HSSF = \u0026quot;application/vnd.ms-excel\u0026quot;; private static final String XSSF = \u0026quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026quot;; /** * * @param className * 传入类的包名+类名 * @param fileToBeRead * 要读取的文件 * * @param fields * 要写入的目标类的哪些字段，请按照excel的列的顺序 * @throws ClassNotFoundException * @throws FileNotFoundException */ public ExcelUtil(Class\u0026lt;T\u0026gt; clazz, String filePath, String... fields) throws ClassNotFoundException, FileNotFoundException { init(clazz, new File(filePath), fields); } public ExcelUtil(Class\u0026lt;T\u0026gt; clazz, File file, String... fields) throws ClassNotFoundException, FileNotFoundException { init(clazz, file, fields); } public ExcelUtil(Class\u0026lt;T\u0026gt; clazz, String... fields) throws FileNotFoundException { this.entityClass = clazz; this.fields = fields; } private void init(Class\u0026lt;T\u0026gt; clazz, File file, String... fields) throws FileNotFoundException { this.entityClass = clazz; this.file = file; this.inputStream = new FileInputStream(this.file); this.fields = fields; } /** * 设置工作薄名称 * * @param sheetName */ public void setSheetName(String sheetName) { this.sheetName = sheetName; } /** * 设置头部 * * @param header */ public void setHeader(String[] header) { this.header = header; } public List\u0026lt;T\u0026gt; convertToList() { List\u0026lt;T\u0026gt; list = null; try { list = toList2003(); } catch (Exception e2) { e2.printStackTrace(); try { list = toList2007(); } catch (Exception e1) { e1.printStackTrace(); } } return list; } public List\u0026lt;T\u0026gt; convertToList(String fileType) throws FileNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NotOLE2FileException { List\u0026lt;T\u0026gt; list = null; try { if (fileType != null \u0026amp;\u0026amp; fileType.equals(HSSF)) { list = toList2003(); } else if (fileType != null \u0026amp;\u0026amp; fileType.equals(XSSF)) { list = toList2007(); } } catch (Exception e) { e.printStackTrace(); } finally { if (inputStream != null) { inputStream.close(); } } return list; } /** * 设置忽略的行数，默认忽略第一行 * * @param ignoreRow * 要忽略的行数，默认忽略第一行 */ public void setIgnoreRow(int ignoreRow) { this.ignoreRow = ignoreRow; } /** * 将excel文件按照用户给定的字段，封装到对象中，并返回一个list集合 适用于2003版本 * * @throws IOException * @throws FileNotFoundException * @throws SecurityException * @throws NoSuchMethodException * @throws InvocationTargetException * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InstantiationException * */ public List\u0026lt;T\u0026gt; toList2003() throws FileNotFoundException, IOException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 创建对工作表的引用。 HSSFWorkbook workbook = new HSSFWorkbook(this.inputStream); HSSFSheet sheet = workbook.getSheetAt(0); // 在Excel文档中，第一张工作表的缺省索引是0， // 用于存储目标对象，excel每一行都是一个实体对象 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); // 创建泛类的实例对象 Constructor\u0026lt;T\u0026gt; constructor = entityClass.getConstructor(); // Field[] objField = entityClass.getFields(); Method[] methods = entityClass.getMethods(); // 读取左上端单元 HSSFRow row = null; for (int i = ignoreRow; sheet.getRow(i) != null; i++) { // 指针指向第i行 row = sheet.getRow(i); T instance = constructor.newInstance(); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; for (Method method : methods) { String methodName = method.getName(); String prefix = methodName.substring(0, 3); String suffix = methodName.substring(3); if (prefix.equals(\u0026quot;set\u0026quot;) \u0026amp;\u0026amp; suffix.equalsIgnoreCase(field)) { HSSFCell cell = null; cell = row.getCell(j); if (cell == null) { continue; } // 单元格类型 int cellType = cell.getCellType(); if (cellType == Cell.CELL_TYPE_NUMERIC) { double value = row.getCell(j).getNumericCellValue(); if (DateUtil.isCellDateFormatted(cell)) { // 日期 Date date = org.apache.poi.ss.usermodel.DateUtil.getJavaDate(value); method.invoke(instance, date); continue; } setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_STRING) { String value = row.getCell(j).getStringCellValue(); setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_FORMULA) { // 公式型 try { double value = cell.getNumericCellValue(); setValue(method, instance, value); } catch (IllegalStateException e) { String value = String.valueOf(cell.getRichStringCellValue()); setValue(method, instance, value); } } } } } list.add(instance); } workbook.close(); return list; } public List\u0026lt;T\u0026gt; toList2007() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, FileNotFoundException, IOException, NoSuchMethodException, SecurityException, InstantiationException { // 创建对工作表的引用。 XSSFWorkbook workbook = new XSSFWorkbook(this.inputStream); XSSFSheet sheet = workbook.getSheetAt(0); // 在Excel文档中，第一张工作表的缺省索引是0， // 用于存储目标对象，excel每一行都是一个实体对象 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); // 创建泛类的实例对象 Constructor\u0026lt;T\u0026gt; constructor = entityClass.getConstructor(); // Field[] objField = entityClass.getFields(); Method[] methods = entityClass.getMethods(); // 读取左上端单元 XSSFRow row = null; for (int i = ignoreRow; sheet.getRow(i) != null; i++) { // 指针指向第i行 row = sheet.getRow(i); T instance = constructor.newInstance(); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; for (Method method : methods) { String methodName = method.getName(); String prefix = methodName.substring(0, 3); String suffix = methodName.substring(3); if (prefix.equals(\u0026quot;set\u0026quot;) \u0026amp;\u0026amp; suffix.equalsIgnoreCase(field)) { XSSFCell cell = null; cell = row.getCell(j); if (cell == null) { continue; } int cellType = cell.getCellType(); if (cellType == Cell.CELL_TYPE_NUMERIC) { double value = row.getCell(j).getNumericCellValue(); if (DateUtil.isCellDateFormatted(cell)) { // 日期 Date date = org.apache.poi.ss.usermodel.DateUtil.getJavaDate(value); method.invoke(instance, date); continue; } setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_STRING) { String value = row.getCell(j).getStringCellValue(); setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_FORMULA) { // 公式型 try { double value = cell.getNumericCellValue(); setValue(method, instance, value); } catch (IllegalStateException e) { String value = String.valueOf(cell.getRichStringCellValue()); setValue(method, instance, value); } } } } } list.add(instance); } workbook.close(); return list; } /** * * 去掉字符串右边的空格 * * @param str * 要处理的字符串 * * @return 处理后的字符串 */ private static String rlTrim(String str) { // 去除ascii 160 if (str.startsWith(\u0026quot; \u0026quot;)) { int startIndex = str.indexOf(\u0026quot; \u0026quot;); str = str.substring(startIndex + 1, str.length()); } if (str.endsWith(\u0026quot; \u0026quot;)) { int endIndex = str.lastIndexOf(\u0026quot; \u0026quot;); str = str.substring(0, endIndex); } // 去除ascii 32 return str.trim(); } /** * 注入值 * * @param method * @param instance * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ private void setValue(Method method, T instance, double value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { Class\u0026lt;?\u0026gt;[] parameterTypes = method.getParameterTypes(); Class\u0026lt;?\u0026gt; class1 = parameterTypes[0]; if (class1.equals(String.class)) { method.invoke(instance, rlTrim(value + \u0026quot;\u0026quot;)); } else if (class1.equals(int.class)) { method.invoke(instance, (int) value); } else if (class1.equals(Integer.class)) { method.invoke(instance, (int) value); } else if (class1.equals(double.class)) { method.invoke(instance, value); } else { method.invoke(instance, value); } } /** * 注入值 * * @param method * @param instance * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ private void setValue(Method method, T instance, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { Class\u0026lt;?\u0026gt;[] parameterTypes = method.getParameterTypes(); Class\u0026lt;?\u0026gt; class1 = parameterTypes[0]; if (class1.equals(String.class)) { method.invoke(instance, rlTrim(value)); } else if (class1.equals(int.class)) { method.invoke(instance, Integer.parseInt(value)); } else if (class1.equals(Integer.class)) { method.invoke(instance, Integer.parseInt(value)); } else if (class1.equals(double.class)) { method.invoke(instance, Double.parseDouble(value)); } else { method.invoke(instance, rlTrim(value)); } } private List\u0026lt;T\u0026gt; convertSheetToList(Sheet sheet, Integer ignoreRow, String... fields) throws FileNotFoundException, IOException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, ClassNotFoundException { // 用于存储目标对象，excel每一行都是一个实体对象 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); // 创建泛类的实例对象 Constructor constructor = entityClass.getConstructor(null); Field[] objField = entityClass.getFields(); Method[] methods = entityClass.getMethods(); // 读取左上端单元 Row row = null; for (int i = ignoreRow; sheet.getRow(i) != null; i++) { // 指针指向第i行 row = sheet.getRow(i); T instance = (T) constructor.newInstance(null); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; for (Method method : methods) { String methodName = method.getName(); String prefix = methodName.substring(0, 3); String suffix = methodName.substring(3); if (prefix.equals(\u0026quot;set\u0026quot;) \u0026amp;\u0026amp; suffix.equalsIgnoreCase(field)) { Cell cell = null; cell = row.getCell(j); if (cell == null) { continue; } // 单元格类型 int cellType = cell.getCellType(); if (cellType == HSSFCell.CELL_TYPE_NUMERIC) { double value = row.getCell(j).getNumericCellValue(); Type[] types = method.getGenericParameterTypes(); for (Type type : types) { String parameterName = ((Class) type).getSimpleName(); if (parameterName.equals(\u0026quot;String\u0026quot;)) { method.invoke(instance, rlTrim((int) value + \u0026quot;\u0026quot;)); } else if (parameterName.equals(\u0026quot;int\u0026quot;)) { method.invoke(instance, (int) value); } else if (parameterName.equals(\u0026quot;Integer\u0026quot;)) { method.invoke(instance, (int) value); } else if (parameterName.equalsIgnoreCase(\u0026quot;double\u0026quot;)) { method.invoke(instance, value); } else { method.invoke(instance, value); } } } else if (cellType == HSSFCell.CELL_TYPE_STRING) { String value = row.getCell(j).getStringCellValue(); Type[] types = method.getGenericParameterTypes(); for (Type type : types) { String parameterName = ((Class) type).getSimpleName(); if (parameterName.equals(\u0026quot;String\u0026quot;)) { method.invoke(instance, rlTrim(value)); } else if (parameterName.equals(\u0026quot;int\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else if (parameterName.equals(\u0026quot;Integer\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else if (parameterName.equalsIgnoreCase(\u0026quot;double\u0026quot;)) { method.invoke(instance, Double.parseDouble(value)); } else { method.invoke(instance, rlTrim(value)); } } } else if (cellType == HSSFCell.CELL_TYPE_FORMULA) { // 公式型 String value = \u0026quot;\u0026quot;; try { value = String.valueOf(cell.getNumericCellValue()); } catch (IllegalStateException e) { value = String.valueOf(cell.getRichStringCellValue()); } Type[] types = method.getGenericParameterTypes(); for (Type type : types) { String parameterName = ((Class) type).getSimpleName(); if (parameterName.equals(\u0026quot;String\u0026quot;)) { method.invoke(instance, rlTrim(value)); } else if (parameterName.equals(\u0026quot;int\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else if (parameterName.equals(\u0026quot;Integer\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else { method.invoke(instance, rlTrim(value)); } } } } } } list.add(instance); } return list; } /** * List 转Excel * * @return * @throws SecurityException * @throws NoSuchFieldException * @throws IllegalAccessException * @throws IllegalArgumentException */ public ByteArrayOutputStream convertList2Excel(List\u0026lt;T\u0026gt; list) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(sheetName); // 创建表头 int index = 0; if (header != null) { HSSFRow row = sheet.createRow(index); for (int i = 0; i \u0026lt; header.length; i++) { HSSFCell cell = row.createCell(i); cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue(header[i]); } index++; } for (int i = 0; i \u0026lt; list.size(); i++) { HSSFRow row = sheet.createRow(i + index); T instance = list.get(i); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; Field entityField = entityClass.getDeclaredField(field); if (!entityField.isAccessible()) { entityField.setAccessible(true); } Cell cell = row.createCell(j); Object object = entityField.get(instance); if (object instanceof String) { cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue((String) object); } if (object instanceof Double) { cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC); Double num = (double) object; if (num != 0) { cell.setCellValue(num); } else { cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue(\u0026quot;\u0026quot;); } } if (object instanceof Float) { cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC); cell.setCellValue((float) object); } if (object instanceof Integer) { cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC); cell.setCellValue((int) object); } if (object instanceof Date) { cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue((Date) object); CreationHelper createHelper = workbook.getCreationHelper(); CellStyle cellStyle = workbook.createCellStyle(); cellStyle.setDataFormat(createHelper.createDataFormat().getFormat(par)); cell.setCellStyle(cellStyle); } } } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); try { workbook.write(outputStream); workbook.close(); } catch (IOException e) { e.printStackTrace(); } return outputStream; } public void setPar(String par) { this.par = par; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/exceltohtmlutil/",
	"title": "Excel转换html",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.apache.poi.hssf.usermodel.*; import org.apache.poi.hssf.util.HSSFColor; import org.apache.poi.ss.usermodel.*; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.usermodel.XSSFCellStyle; import org.apache.poi.xssf.usermodel.XSSFColor; import org.apache.poi.xssf.usermodel.XSSFFont; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.text.DecimalFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; /** * @功能描述 POI 读取 Excel 转 HTML 支持 03xls 和 07xlsx 版本 包含样式 * @author Devil * @创建时间 2015/4/19 21:34 */ public class ExcelToHtmlUtil { /** * 程序入口方法 * @param filePath 文件的路径 * @param isWithStyle 是否需要表格样式 包含 字体 颜色 边框 对齐方式 * @return \u0026lt;table\u0026gt;...\u0026lt;/table\u0026gt; 字符串 */ public String readExcelToHtml(String filePath , boolean isWithStyle){ InputStream is = null; String htmlExcel = null; try { File sourcefile = new File(filePath); is = new FileInputStream(sourcefile); Workbook wb = WorkbookFactory.create(is); if (wb instanceof XSSFWorkbook) { XSSFWorkbook xWb = (XSSFWorkbook) wb; htmlExcel = ExcelToHtmlUtil.getExcelInfo(xWb,isWithStyle); }else if(wb instanceof HSSFWorkbook){ HSSFWorkbook hWb = (HSSFWorkbook) wb; htmlExcel = ExcelToHtmlUtil.getExcelInfo(hWb,isWithStyle); } } catch (Exception e) { e.printStackTrace(); }finally{ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } return htmlExcel; } public static String xSSFWorkbookToHtml(HSSFWorkbook wb,boolean isWithStyle) { return ExcelToHtmlUtil.getExcelInfo(wb,isWithStyle); } public static String getExcelInfo(Workbook wb,boolean isWithStyle){ StringBuffer sb = new StringBuffer(); Sheet sheet = wb.getSheetAt(0);//获取第一个Sheet的内容 int lastRowNum = sheet.getLastRowNum(); Map\u0026lt;String, String\u0026gt; map[] = getRowSpanColSpanMap(sheet); sb.append(\u0026quot;\u0026lt;table style='border-collapse:collapse;' width='100%'\u0026gt;\u0026quot;); Row row = null; //兼容 Cell cell = null; //兼容 for (int rowNum = sheet.getFirstRowNum(); rowNum \u0026lt;= lastRowNum; rowNum++) { row = sheet.getRow(rowNum); if (row == null) { sb.append(\u0026quot;\u0026lt;tr\u0026gt;\u0026lt;td \u0026gt; \u0026amp;nbsp;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026quot;); continue; } sb.append(\u0026quot;\u0026lt;tr\u0026gt;\u0026quot;); int lastColNum = row.getLastCellNum(); for (int colNum = 0; colNum \u0026lt; lastColNum; colNum++) { cell = row.getCell(colNum); if (cell == null) { //特殊情况 空白的单元格会返回null sb.append(\u0026quot;\u0026lt;td\u0026gt;\u0026amp;nbsp;\u0026lt;/td\u0026gt;\u0026quot;); continue; } String stringValue = getCellValue(cell); if (map[0].containsKey(rowNum + \u0026quot;,\u0026quot; + colNum)) { String pointString = map[0].get(rowNum + \u0026quot;,\u0026quot; + colNum); map[0].remove(rowNum + \u0026quot;,\u0026quot; + colNum); int bottomeRow = Integer.valueOf(pointString.split(\u0026quot;,\u0026quot;)[0]); int bottomeCol = Integer.valueOf(pointString.split(\u0026quot;,\u0026quot;)[1]); int rowSpan = bottomeRow - rowNum + 1; int colSpan = bottomeCol - colNum + 1; sb.append(\u0026quot;\u0026lt;td rowspan= '\u0026quot; + rowSpan + \u0026quot;' colspan= '\u0026quot;+ colSpan + \u0026quot;' \u0026quot;); } else if (map[1].containsKey(rowNum + \u0026quot;,\u0026quot; + colNum)) { map[1].remove(rowNum + \u0026quot;,\u0026quot; + colNum); continue; } else { sb.append(\u0026quot;\u0026lt;td \u0026quot;); } //判断是否需要样式 if(isWithStyle){ dealExcelStyle(wb, sheet, cell, sb);//处理单元格样式 } sb.append(\u0026quot;\u0026gt;\u0026quot;); if (stringValue == null || \u0026quot;\u0026quot;.equals(stringValue.trim())) { sb.append(\u0026quot; \u0026amp;nbsp; \u0026quot;); } else { // 将ascii码为160的空格转换为html下的空格（\u0026amp;nbsp;） sb.append(stringValue.replace(String.valueOf((char) 160),\u0026quot;\u0026amp;nbsp;\u0026quot;)); } sb.append(\u0026quot;\u0026lt;/td\u0026gt;\u0026quot;); } sb.append(\u0026quot;\u0026lt;/tr\u0026gt;\u0026quot;); } sb.append(\u0026quot;\u0026lt;/table\u0026gt;\u0026quot;); return sb.toString(); } private static Map\u0026lt;String, String\u0026gt;[] getRowSpanColSpanMap(Sheet sheet) { Map\u0026lt;String, String\u0026gt; map0 = new HashMap\u0026lt;String, String\u0026gt;(); Map\u0026lt;String, String\u0026gt; map1 = new HashMap\u0026lt;String, String\u0026gt;(); int mergedNum = sheet.getNumMergedRegions(); CellRangeAddress range = null; for (int i = 0; i \u0026lt; mergedNum; i++) { range = sheet.getMergedRegion(i); int topRow = range.getFirstRow(); int topCol = range.getFirstColumn(); int bottomRow = range.getLastRow(); int bottomCol = range.getLastColumn(); map0.put(topRow + \u0026quot;,\u0026quot; + topCol, bottomRow + \u0026quot;,\u0026quot; + bottomCol); // System.out.println(topRow + \u0026quot;,\u0026quot; + topCol + \u0026quot;,\u0026quot; + bottomRow + \u0026quot;,\u0026quot; + bottomCol); int tempRow = topRow; while (tempRow \u0026lt;= bottomRow) { int tempCol = topCol; while (tempCol \u0026lt;= bottomCol) { map1.put(tempRow + \u0026quot;,\u0026quot; + tempCol, \u0026quot;\u0026quot;); tempCol++; } tempRow++; } map1.remove(topRow + \u0026quot;,\u0026quot; + topCol); } Map[] map = { map0, map1 }; return map; } /** * 获取表格单元格Cell内容 * @param cell * @return */ private static String getCellValue(Cell cell) { String result = new String(); switch (cell.getCellType()) { case Cell.CELL_TYPE_NUMERIC:// 数字类型 if (HSSFDateUtil.isCellDateFormatted(cell)) {// 处理日期格式、时间格式 SimpleDateFormat sdf = null; if (cell.getCellStyle().getDataFormat() == HSSFDataFormat.getBuiltinFormat(\u0026quot;h:mm\u0026quot;)) { sdf = new SimpleDateFormat(\u0026quot;HH:mm\u0026quot;); } else {// 日期 sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); } Date date = cell.getDateCellValue(); result = sdf.format(date); } else if (cell.getCellStyle().getDataFormat() == 58) { // 处理自定义日期格式：m月d日(通过判断单元格的格式id解决，id的值是58) SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); double value = cell.getNumericCellValue(); Date date = org.apache.poi.ss.usermodel.DateUtil .getJavaDate(value); result = sdf.format(date); } else { double value = cell.getNumericCellValue(); CellStyle style = cell.getCellStyle(); DecimalFormat format = new DecimalFormat(); String temp = style.getDataFormatString(); // 单元格设置成常规 if (temp.equals(\u0026quot;General\u0026quot;)) { format.applyPattern(\u0026quot;#\u0026quot;); } result = format.format(value); } break; case Cell.CELL_TYPE_STRING:// String类型 result = cell.getRichStringCellValue().toString(); break; case Cell.CELL_TYPE_BLANK: result = \u0026quot;\u0026quot;; break; default: result = \u0026quot;\u0026quot;; break; } return result; } /** * 处理表格样式 * @param wb * @param sheet * @param cell * @param sb */ private static void dealExcelStyle(Workbook wb,Sheet sheet,Cell cell,StringBuffer sb){ CellStyle cellStyle = cell.getCellStyle(); if (cellStyle != null) { short alignment = cellStyle.getAlignment(); sb.append(\u0026quot;align='\u0026quot; + convertAlignToHtml(alignment) + \u0026quot;' \u0026quot;);//单元格内容的水平对齐方式 short verticalAlignment = cellStyle.getVerticalAlignment(); sb.append(\u0026quot;valign='\u0026quot;+ convertVerticalAlignToHtml(verticalAlignment)+ \u0026quot;' \u0026quot;);//单元格中内容的垂直排列方式 if (wb instanceof XSSFWorkbook) { XSSFFont xf = ((XSSFCellStyle) cellStyle).getFont(); short boldWeight = xf.getBoldweight(); sb.append(\u0026quot;style='\u0026quot;); sb.append(\u0026quot;font-weight:\u0026quot; + boldWeight + \u0026quot;;\u0026quot;); // 字体加粗 sb.append(\u0026quot;font-size: \u0026quot; + xf.getFontHeight() / 2 + \u0026quot;%;\u0026quot;); // 字体大小 int columnWidth = sheet.getColumnWidth(cell.getColumnIndex()) ; sb.append(\u0026quot;width:\u0026quot; + columnWidth + \u0026quot;px;\u0026quot;); XSSFColor xc = xf.getXSSFColor(); if (xc != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(xc)) { sb.append(\u0026quot;color:#\u0026quot; + xc.getARGBHex().substring(2) + \u0026quot;;\u0026quot;); // 字体颜色 } XSSFColor bgColor = (XSSFColor) cellStyle.getFillForegroundColorColor(); //System.out.println(\u0026quot;************************************\u0026quot;); //System.out.println(\u0026quot;BackgroundColorColor: \u0026quot;+cellStyle.getFillBackgroundColorColor()); //System.out.println(\u0026quot;ForegroundColor: \u0026quot;+cellStyle.getFillForegroundColor());//0 //System.out.println(\u0026quot;BackgroundColorColor: \u0026quot;+cellStyle.getFillBackgroundColorColor()); //System.out.println(\u0026quot;ForegroundColorColor: \u0026quot;+cellStyle.getFillForegroundColorColor()); //String bgColorStr = bgColor.getARGBHex(); //System.out.println(\u0026quot;bgColorStr: \u0026quot;+bgColorStr); if (bgColor != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(bgColor)) { sb.append(\u0026quot;background-color:#\u0026quot; + bgColor.getARGBHex().substring(2) + \u0026quot;;\u0026quot;); // 背景颜色 } sb.append(getBorderStyle(0,cellStyle.getBorderTop(), ((XSSFCellStyle) cellStyle).getTopBorderXSSFColor())); sb.append(getBorderStyle(1,cellStyle.getBorderRight(), ((XSSFCellStyle) cellStyle).getRightBorderXSSFColor())); sb.append(getBorderStyle(2,cellStyle.getBorderBottom(), ((XSSFCellStyle) cellStyle).getBottomBorderXSSFColor())); sb.append(getBorderStyle(3,cellStyle.getBorderLeft(), ((XSSFCellStyle) cellStyle).getLeftBorderXSSFColor())); }else if(wb instanceof HSSFWorkbook){ HSSFFont hf = ((HSSFCellStyle) cellStyle).getFont(wb); short boldWeight = hf.getBoldweight(); short fontColor = hf.getColor(); sb.append(\u0026quot;style='\u0026quot;); HSSFPalette palette = ((HSSFWorkbook) wb).getCustomPalette(); // 类HSSFPalette用于求的颜色的国际标准形式 HSSFColor hc = palette.getColor(fontColor); sb.append(\u0026quot;font-weight:\u0026quot; + boldWeight + \u0026quot;;\u0026quot;); // 字体加粗 sb.append(\u0026quot;font-size: \u0026quot; + hf.getFontHeight() / 2 + \u0026quot;%;\u0026quot;); // 字体大小 String fontColorStr = convertToStardColor(hc); if (fontColorStr != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(fontColorStr.trim())) { sb.append(\u0026quot;color:\u0026quot; + fontColorStr + \u0026quot;;\u0026quot;); // 字体颜色 } int columnWidth = sheet.getColumnWidth(cell.getColumnIndex()) ; sb.append(\u0026quot;width:\u0026quot; + columnWidth + \u0026quot;px;\u0026quot;); short bgColor = cellStyle.getFillForegroundColor(); hc = palette.getColor(bgColor); String bgColorStr = convertToStardColor(hc); if (bgColorStr != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(bgColorStr.trim())) { sb.append(\u0026quot;background-color:\u0026quot; + bgColorStr + \u0026quot;;\u0026quot;); // 背景颜色 } sb.append( getBorderStyle(palette,0,cellStyle.getBorderTop(),cellStyle.getTopBorderColor())); sb.append( getBorderStyle(palette,1,cellStyle.getBorderRight(),cellStyle.getRightBorderColor())); sb.append( getBorderStyle(palette,3,cellStyle.getBorderLeft(),cellStyle.getLeftBorderColor())); sb.append( getBorderStyle(palette,2,cellStyle.getBorderBottom(),cellStyle.getBottomBorderColor())); } sb.append(\u0026quot;' \u0026quot;); } } /** * 单元格内容的水平对齐方式 * @param alignment * @return */ private static String convertAlignToHtml(short alignment) { String align = \u0026quot;left\u0026quot;; switch (alignment) { case CellStyle.ALIGN_LEFT: align = \u0026quot;left\u0026quot;; break; case CellStyle.ALIGN_CENTER: align = \u0026quot;center\u0026quot;; break; case CellStyle.ALIGN_RIGHT: align = \u0026quot;right\u0026quot;; break; default: break; } return align; } /** * 单元格中内容的垂直排列方式 * @param verticalAlignment * @return */ private static String convertVerticalAlignToHtml(short verticalAlignment) { String valign = \u0026quot;middle\u0026quot;; switch (verticalAlignment) { case CellStyle.VERTICAL_BOTTOM: valign = \u0026quot;bottom\u0026quot;; break; case CellStyle.VERTICAL_CENTER: valign = \u0026quot;center\u0026quot;; break; case CellStyle.VERTICAL_TOP: valign = \u0026quot;top\u0026quot;; break; default: break; } return valign; } private static String convertToStardColor(HSSFColor hc) { StringBuffer sb = new StringBuffer(\u0026quot;\u0026quot;); if (hc != null) { if (HSSFColor.AUTOMATIC.index == hc.getIndex()) { return null; } sb.append(\u0026quot;#\u0026quot;); for (int i = 0; i \u0026lt; hc.getTriplet().length; i++) { sb.append(fillWithZero(Integer.toHexString(hc.getTriplet()[i]))); } } return sb.toString(); } private static String fillWithZero(String str) { if (str != null \u0026amp;\u0026amp; str.length() \u0026lt; 2) { return \u0026quot;0\u0026quot; + str; } return str; } static String[] bordesr={\u0026quot;border-top:\u0026quot;,\u0026quot;border-right:\u0026quot;,\u0026quot;border-bottom:\u0026quot;,\u0026quot;border-left:\u0026quot;}; static String[] borderStyles={\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;}; private static String getBorderStyle( HSSFPalette palette ,int b,short s, short t){ if(s==0)return bordesr[b]+borderStyles[s]+\u0026quot;#d0d7e5 1px;\u0026quot;;; String borderColorStr = convertToStardColor( palette.getColor(t)); borderColorStr=borderColorStr==null|| borderColorStr.length()\u0026lt;1?\u0026quot;#000000\u0026quot;:borderColorStr; return bordesr[b]+borderStyles[s]+borderColorStr+\u0026quot; 1px;\u0026quot;; } private static String getBorderStyle(int b,short s, XSSFColor xc){ if(s==0)return bordesr[b]+borderStyles[s]+\u0026quot;#d0d7e5 1px;\u0026quot;;; if (xc != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(xc)) { String borderColorStr = xc.getARGBHex();//t.getARGBHex(); borderColorStr=borderColorStr==null|| borderColorStr.length()\u0026lt;1?\u0026quot;#000000\u0026quot;:borderColorStr.substring(2); return bordesr[b]+borderStyles[s]+borderColorStr+\u0026quot; 1px;\u0026quot;; } return \u0026quot;\u0026quot;; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/geoserver/",
	"title": "Geoserver",
	"tags": [],
	"description": "",
	"content": "下载地址提取码：300y 通过geoserver远程发布\n import it.geosolutions.geoserver.rest.GeoServerRESTManager; import it.geosolutions.geoserver.rest.GeoServerRESTPublisher; import it.geosolutions.geoserver.rest.GeoServerRESTReader; import org.apache.commons.httpclient.NameValuePair; import java.io.File; import java.net.MalformedURLException; import java.net.URL; public class GeoServerUtil { public static final String RESTURL; public static final String RESTUSER; public static final String RESTPW; public static final String GS_VERSION; public static java.net.URL URL; public static GeoServerRESTManager manager; public static GeoServerRESTReader reader; public static GeoServerRESTPublisher publisher; // private static ResourceBundle bundle = ResourceBundle.getBundle(\u0026quot;constant\u0026quot;); //初始化用户名密码赋值,发布图集时会进行身份认证 static { RESTURL = getenv(\u0026quot;gsmgr_resturl\u0026quot;, \u0026quot;http://localhost:6060/geoserver/\u0026quot;); RESTUSER = getenv(\u0026quot;gsmgr_restuser\u0026quot;,\u0026quot;admin\u0026quot;); RESTPW = getenv(\u0026quot;gsmgr_restpw\u0026quot;, \u0026quot;geoserver\u0026quot;); GS_VERSION = getenv(\u0026quot;gsmgr_version\u0026quot;, \u0026quot;2.8.2\u0026quot;); try { URL = new URL(RESTURL); manager = new GeoServerRESTManager(URL, RESTUSER, RESTPW); reader = manager.getReader(); publisher = manager.getPublisher(); } catch (MalformedURLException e) { e.printStackTrace(); } } //获取环境信息 private static String getenv(String envName, String envDefault) { String env = System.getenv(envName); String prop = System.getProperty(envName, env); return prop != null ? prop : envDefault; } public static boolean publishShpAndReloadStore(String workspace,String zipFilePath,String coordinateSystem) throws Exception{ //坐标系,判断是否为空 if(ComUtil.isEmpty(coordinateSystem)){ coordinateSystem= GeoServerRESTPublisher.DEFAULT_CRS; } //存在相应的工作区 if(!reader.existsWorkspace(workspace)){ publisher.createWorkspace(workspace); } boolean published; /* if(Constant.AtlasStyleType.ATLAS_STYLE_TYPE_5.equals(styleType)){*/ /* published = publisher.publishShp(workspace, storeName, layerName, new File(zipFilePath),coordinateSystem, new NameValuePair[]{new NameValuePair(\u0026quot;charset\u0026quot;, \u0026quot;GBK\u0026quot;)});*/ //published = publisher.publishGeoTIFF(workspace,storeName,new File(zipFilePath)); String name = new File(zipFilePath).getName(); name = name.substring(0,name.lastIndexOf(\u0026quot;.\u0026quot;)); published = publisher.publishShp(workspace,name,name,new File(zipFilePath),coordinateSystem,new NameValuePair[]{new NameValuePair(\u0026quot;charset\u0026quot;, \u0026quot;ISO8859-1\u0026quot;)}); return published; } public static boolean publishTifAndReloadStore(String workspace,String zipFilePath,String storeName) throws Exception{ //存在相应的工作区 if(!reader.existsWorkspace(workspace)){ publisher.createWorkspace(workspace); } boolean published; published = publisher.publishGeoTIFF(workspace,storeName,new File(zipFilePath)); return published; } public static boolean unPublishShpAndReloadStore(String workspace,String storeName){ return publisher.removeLayer(workspace,storeName); } public static void main(String[] args) { try { //boolean b = GeoServerUtil.publishShpAndReloadStore(\u0026quot;testshp\u0026quot;,\u0026quot;H:\\\\下载\\\\shp矢量文件\\\\test.zip\u0026quot;,\u0026quot;shpstore\u0026quot;,\u0026quot;shplayer\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;EPSG:4326\u0026quot;); boolean b = GeoServerUtil.publishTifAndReloadStore(\u0026quot;testtif\u0026quot;,\u0026quot;C:test.tif\u0026quot;,\u0026quot;tifjava03\u0026quot;); // boolean b = GeoServerUtil.publishShpAndReloadStore(\u0026quot;testshp\u0026quot;,\u0026quot;D:\\\\PeterHan\\\\test.zip\u0026quot;,\u0026quot;shp0123\u0026quot;,\u0026quot;shp0123\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;); // System.out.print(b); } catch (Exception e) { e.printStackTrace(); } //HTTPUtils.post(\u0026quot;http://localhost:8080/geoserver/rest/workspaces/testshp/datastores/shpstore/file.shp\u0026quot;,\u0026quot;\u0026lt;featureType\u0026gt;\u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt;\u0026lt;metadata /\u0026gt;\u0026lt;keywords /\u0026gt;\u0026lt;metadataLinks /\u0026gt;\u0026lt;attributes /\u0026gt;\u0026lt;name\u0026gt;shplayer\u0026lt;/name\u0026gt;\u0026lt;title\u0026gt;shplayer\u0026lt;/title\u0026gt;\u0026lt;srs\u0026gt;EPSG:4326\u0026lt;/srs\u0026gt;\u0026lt;projectionPolicy\u0026gt;FORCE_DECLARED\u0026lt;/projectionPolicy\u0026gt;\u0026lt;/featureType\u0026gt;\u0026quot;,\u0026quot;application/xml\u0026quot;,\u0026quot;admin\u0026quot;,\u0026quot;geoserver\u0026quot;); try { /* String url = XmlUtil.getMapUrl(\u0026quot;bh_bhtb\u0026quot;,\u0026quot;testshp\u0026quot;,\u0026quot;shp\u0026quot;); System.out.print(url);*/ } catch (Exception e) { e.printStackTrace(); } } }  解析发布后信息\n import com.nuclear_Project.image.bean.ImageServer; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.File; import java.io.IOException; import java.math.BigDecimal; import java.util.Iterator; /** * \u0026lt;p\u0026gt; * xml解析工具类 * \u0026lt;/p\u0026gt; * * @author liugh * @since 2018/4/3 */ public class XmlUtil { private static String GEO_SERVER_PATH=\u0026quot;D:\\\\Program Files (x86)\\\\GeoServer 2.8.2\\\\data_dir\\\\workspaces\u0026quot;; private static String BUNDLE_URL = \u0026quot;http://localhost:6060/geoserver/\u0026quot;; private static String XML_ELEMENT_NAME=\u0026quot;latLonBoundingBox\u0026quot;; /*public static void main(String[] args)throws Exception { getMapUrl(\u0026quot;1522723368940\u0026quot;,\u0026quot;unitMap\u0026quot;); }*/ //获取图集发布地址 public static String getMapUrl(String layerId, String workspace, String type, ImageServer server)throws Exception{ File file =new File(GEO_SERVER_PATH+File.separator+workspace); String[] fileList = file.list(); StringBuilder mapUrl = new StringBuilder(); mapUrl.append(BUNDLE_URL+workspace) .append(\u0026quot;/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=\u0026quot;).append(workspace+\u0026quot;:\u0026quot;+layerId).append(\u0026quot;\u0026amp;styles=\u0026amp;bbox=\u0026quot;); if(!ComUtil.isEmpty(fileList)){ for (String fileName:fileList) { if(fileName.equals(layerId)){ String [] coordinates = readXMLDocument(layerId,workspace,type); mapUrl.append(coordinates[0]+\u0026quot;,\u0026quot;+coordinates[2]+\u0026quot;,\u0026quot;+coordinates[1]+\u0026quot;,\u0026quot;+coordinates[3]).append(\u0026quot;\u0026amp;width=768\u0026amp;height=437\u0026amp;srs=\u0026quot;).append(coordinates[4]); server.setNwlong(new BigDecimal(coordinates[0])); server.setNwlat(new BigDecimal(coordinates[2])); server.setSelong(new BigDecimal(coordinates[1])); server.setSelat(new BigDecimal(coordinates[3])); } } }else{ return null; } mapUrl.append(\u0026quot;\u0026amp;format=application/openlayers\u0026quot;); return mapUrl.toString(); } private static String [] readXMLDocument(String layerId, String workspace,String type){ String str=\u0026quot;\u0026quot;; if(type.equalsIgnoreCase(\u0026quot;tif\u0026quot;)||type.equalsIgnoreCase(\u0026quot;tiff\u0026quot;)){ str=\u0026quot;coverage.xml\u0026quot;; }else if(type.equals(\u0026quot;shp\u0026quot;)){ str=\u0026quot;featuretype.xml\u0026quot;; } File file = new File(GEO_SERVER_PATH+File.separator+workspace+ File.separator+layerId+File.separator+layerId+File.separator+str); if (!file.exists()) { try { throw new IOException(\u0026quot;Can't find the path\u0026quot;); } catch (IOException e) { e.printStackTrace(); } } //创建SAXReader对象 SAXReader saxReader = new SAXReader(); Document document; try { //读取文件 转换成Document document = saxReader.read(file); //获取根节点元素对象 遍历当前节点下的所有节点 for (Iterator iter = document.getRootElement().elementIterator(); iter.hasNext();){ //获取节点 Element e1 = (Element) iter.next(); //如果过节点的名称等于beanName那么继续进入循环读取beanName节点下的所有节点 if(e1.getName().equalsIgnoreCase(XML_ELEMENT_NAME)){ String [] ss = new String[5]; int i =0; //遍历beanName当前节点下的所有节点 for (Iterator iter1 = e1.elementIterator(); iter1.hasNext();){ Element e2 = (Element) iter1.next(); ss[i]= e2.getStringValue(); i++; } return ss; } } } catch (DocumentException e) { e.printStackTrace(); return null; } return null; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/",
	"title": "Gis相关工具类",
	"tags": [],
	"description": "",
	"content": " Gis相关工具类 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/html2image/",
	"title": "Html转换Image",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xuwei-k\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;html2image\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import gui.ava.html.image.generator.HtmlImageGenerator; public class Html2Image { public static void main(String[] args){ HtmlImageGenerator imageGenerator = new HtmlImageGenerator(); String htmlstr = \u0026quot;\u0026quot;; imageGenerator.loadHtml(htmlstr); imageGenerator.getBufferedImage(); imageGenerator.saveAsImage(\u0026quot;d:/hello-world.png\u0026quot;); imageGenerator.saveAsHtmlWithMap(\u0026quot;hello-world.html\u0026quot;, \u0026quot;hello-world.png\u0026quot;); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/java8/",
	"title": "Java8新特性",
	"tags": [],
	"description": "",
	"content": " Lambda 表达式 − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。\n 方法引用 − 方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。\n 默认方法 − 默认方法就是一个在接口里面有了一个实现的方法。\n 新工具 − 新的编译工具，如：Nashorn引擎 jjs、 类依赖分析器jdeps。\n Stream API −新添加的Stream API（java.util.stream） 把真正的函数式编程风格引入到Java中。\n Date Time API − 加强对日期与时间的处理。\n Optional 类 − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。\n Nashorn, JavaScript 引擎 − Java 8提供了一个新的Nashorn javascript引擎，它允许我们在JVM上运行特定的javascript应用。\n  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/jsonutil/",
	"title": "Json工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.jackson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-mapper-asl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.codehaus.jackson.map.ObjectMapper; public class JsonUtil { private static ObjectMapper mapper; private static ObjectMapper getMapper(){ if (mapper == null) { mapper = new ObjectMapper(); } return mapper; } public static String toJson(Object obj) { String str = null; try { str = getMapper().writeValueAsString(obj); } catch (Exception e) { e.printStackTrace(); } return str; } public static \u0026lt;T\u0026gt; T toObj(String json,Class\u0026lt;T\u0026gt; clazz) { try { T obj = getMapper().readValue(json, clazz); return obj; } catch (Exception e) { e.printStackTrace(); } return null; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/jvm/",
	"title": "Jvm于虚拟机",
	"tags": [],
	"description": "",
	"content": " 待完善 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/kml%E5%AF%BC%E5%85%A5/",
	"title": "Kml导入",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.micromata.jak\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;JavaAPIforKml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import com.nuclear_Project.common.util.FileUtil; import com.nuclear_Project.specificObjective.bean.KmlLine; import com.nuclear_Project.specificObjective.bean.KmlPoint; import com.nuclear_Project.specificObjective.bean.KmlPolygon; import com.nuclear_Project.specificObjective.bean.KmlProperty; import de.micromata.opengis.kml.v_2_2_0.*; import org.apache.commons.io.FilenameUtils; import org.apache.commons.io.IOUtils; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.*; import java.math.BigDecimal; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ParsingKmlUtil { //以下三行都是自定义的KML类，用于获取名称name、所有点points、样式颜色color private List\u0026lt;KmlPoint\u0026gt; kmlPointList = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;KmlLine\u0026gt; kmlLineList = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;KmlPolygon\u0026gt; kmlPolygonList = new ArrayList\u0026lt;\u0026gt;(); private KmlProperty kmlProperty = new KmlProperty(); /** * 保存kml数据到临时表 * * @param file 上传的文件实体 * @return 自定义的KML文件实体 */ public KmlProperty parseKmlForJAK(File file) throws FileNotFoundException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); BufferedReader reader = new BufferedReader( new FileReader(file)); try { IOUtils.copy(reader,outputStream,\u0026quot;UTF-8\u0026quot;); } catch (IOException e) { e.printStackTrace(); } Kml kml = Kml.unmarshal(outputStream.toString()); Feature feature = kml.getFeature(); parseFeature(feature); kmlProperty.setKmlPoints(kmlPointList); kmlProperty.setKmlLines(kmlLineList); kmlProperty.setKmlPolygons(kmlPolygonList); return kmlProperty; } /** * 解析kml节点信息 * * @param feature 需要解析到要素信息 * @return */ private void parseFeature(Feature feature) { if (feature != null) { //判断根节点是否为Document if (feature instanceof Document) { List\u0026lt;Feature\u0026gt; featureList = ((Document) feature).getFeature(); //遍历已获取的节点信息(节点信息为List)，将list使用forEach进行遍历（同for、while） featureList.forEach(documentFeature -\u0026gt; { //判断遍历节点是否为PlaceMark，否则迭代解析 if (documentFeature instanceof Placemark) { getPlaceMark((Placemark) documentFeature); } else { parseFeature(documentFeature); } } ); } else if (feature instanceof Folder) { //原理同上 List\u0026lt;Feature\u0026gt; featureList = ((Folder) feature).getFeature(); featureList.forEach(documentFeature -\u0026gt; { if (documentFeature instanceof Placemark) { getPlaceMark((Placemark) documentFeature); } { parseFeature(documentFeature); } } ); } } } /** * 解析PlaceMark节点下的信息 * * @return */ private void getPlaceMark(Placemark placemark) { Geometry geometry = placemark.getGeometry(); String name = placemark.getName(); parseGeometry(name, geometry); } /** * 解析PlaceMark节点下的信息 * * @return */ private void parseGeometry(String name, Geometry geometry) { if (geometry != null) { if (geometry instanceof Polygon) { Polygon polygon = (Polygon) geometry; Boundary outerBoundaryIs = polygon.getOuterBoundaryIs(); if (outerBoundaryIs != null) { LinearRing linearRing = outerBoundaryIs.getLinearRing(); if (linearRing != null) { List\u0026lt;Coordinate\u0026gt; coordinates = linearRing.getCoordinates(); if (coordinates != null) { outerBoundaryIs = ((Polygon) geometry).getOuterBoundaryIs(); addPolygonToList(kmlPolygonList, name, outerBoundaryIs); } } } } else if (geometry instanceof LineString) { LineString lineString = (LineString) geometry; List\u0026lt;Coordinate\u0026gt; coordinates = lineString.getCoordinates(); if (coordinates != null) { coordinates = ((LineString) geometry).getCoordinates(); addLineStringToList(kmlLineList, coordinates, name); } } else if (geometry instanceof Point) { Point point = (Point) geometry; List\u0026lt;Coordinate\u0026gt; coordinates = point.getCoordinates(); if (coordinates != null) { coordinates = ((Point) geometry).getCoordinates(); addPointToList(kmlPointList, coordinates, name); } } else if (geometry instanceof MultiGeometry) { List\u0026lt;Geometry\u0026gt; geometries = ((MultiGeometry) geometry).getGeometry(); for (Geometry geometryToMult : geometries) { Boundary outerBoundaryIs; List\u0026lt;Coordinate\u0026gt; coordinates; if (geometryToMult instanceof Point) { coordinates = ((Point) geometryToMult).getCoordinates(); addPointToList(kmlPointList, coordinates, name); } else if (geometryToMult instanceof LineString) { coordinates = ((LineString) geometryToMult).getCoordinates(); addLineStringToList(kmlLineList, coordinates, name); } else if (geometryToMult instanceof Polygon) { outerBoundaryIs = ((Polygon) geometryToMult).getOuterBoundaryIs(); addPolygonToList(kmlPolygonList, name, outerBoundaryIs); } } } } } /** * 将kml中所有面添加到一个list * * @return */ private void addPolygonToList(List\u0026lt;KmlPolygon\u0026gt; kmlPolygonList, String name, Boundary outerBoundaryIs) { LinearRing linearRing; List\u0026lt;Coordinate\u0026gt; coordinates; linearRing = outerBoundaryIs.getLinearRing();//面 coordinates = linearRing.getCoordinates(); KmlPolygon kmlPolygon = new KmlPolygon(); kmlPolygon.setPoints(coordinates); kmlPolygon.setName(name); kmlPolygonList.add(kmlPolygon); } /** * 将kml中所有线添加到一个list * * @return */ private void addLineStringToList(List\u0026lt;KmlLine\u0026gt; kmlLineList, List\u0026lt;Coordinate\u0026gt; coordinates, String name) { KmlLine kmlLine = new KmlLine(); kmlLine.setPoints(coordinates); kmlLine.setName(name); kmlLineList.add(kmlLine); } /** * 将kml中所有点添加到一个list * * @return */ private void addPointToList(List\u0026lt;KmlPoint\u0026gt; kmlPointList, List\u0026lt;Coordinate\u0026gt; coordinates, String name) { KmlPoint kmlPoint = new KmlPoint(); kmlPoint.setName(name); kmlPoint.setPoints(coordinates); kmlPointList.add(kmlPoint); } public static List\u0026lt;KmlPoint\u0026gt; getKmlPoints(String path) throws DocumentException, FileNotFoundException { List\u0026lt;KmlPoint\u0026gt; points = new ArrayList\u0026lt;\u0026gt;(); File xmlFile = new File(path); SAXReader reader = new SAXReader(); org.dom4j.Document document = reader.read(xmlFile); Element rootElement = document.getRootElement(); Iterator rootIt = rootElement.elementIterator(); while (rootIt.hasNext()){ placeMark(points,(Element)rootIt.next()); } return points; } public static void placeMark(List\u0026lt;KmlPoint\u0026gt; points, Element next) { if(next.getName().equals(\u0026quot;Placemark\u0026quot;)){ Iterator it = next.elementIterator(); boolean tag = false; while (it.hasNext()){ Element element = (Element) it.next(); if(element.getName().equals(\u0026quot;LookAt\u0026quot;)){ tag = true; break; } } if(true){ getPoint(points,next); } }else{ Iterator it = next.elementIterator(); while (it.hasNext()){ placeMark(points,(Element)it.next()); } } } private static void getPoint(List\u0026lt;KmlPoint\u0026gt; points, Element placemark) { KmlPoint point = new KmlPoint(); Iterator mark = placemark.elementIterator(); while (mark.hasNext()){ Element element = (Element)mark.next(); if(element.getName().equalsIgnoreCase(\u0026quot;name\u0026quot;)){ point.setName(element.getText()); }else if(element.getName().equalsIgnoreCase(\u0026quot;LookAt\u0026quot;)){ Iterator itc = element.elementIterator(); while (itc.hasNext()){ Element elementc = (Element) itc.next(); if(elementc.getName().equalsIgnoreCase(\u0026quot;longitude\u0026quot;)){ point.setLongitude(new BigDecimal(elementc.getText())); }else if(elementc.getName().equalsIgnoreCase(\u0026quot;latitude\u0026quot;)){ point.setLatitude(new BigDecimal(elementc.getText())); } } } } points.add(point); } public static void main(String[] args) throws DocumentException, FileNotFoundException { //List\u0026lt;KmlPoint\u0026gt; points = getKmlPoints(\u0026quot;D:\\\\PeterHan\\\\test.kml\u0026quot;); List\u0026lt;KmlPoint\u0026gt; points = getKmlPoints(\u0026quot;C:\\\\\\\\java\\\\\\\\idea\\\\\\\\test.kml\u0026quot;); /* KmlProperty kmlProperty; ParsingKmlUtil parsingKmlUtil =new ParsingKmlUtil(); File file = new File(\u0026quot;D:\\\\PeterHan\\\\test.kml\u0026quot;); kmlProperty = parsingKmlUtil.parseKmlForJAK(file); assert kmlProperty != null; if (kmlProperty.getKmlPoints().size() \u0026gt; 0) { for (KmlPoint k : kmlProperty.getKmlPoints()) { System.out.println(k.getName()); } System.out.println(\u0026quot;点\u0026quot;); } if (kmlProperty.getKmlLines().size() \u0026gt; 0) { for (KmlLine k : kmlProperty.getKmlLines()) { System.out.println(k.getName()); } System.out.println(\u0026quot;线\u0026quot;); } if (kmlProperty.getKmlPoints().size() \u0026gt; 0) { for (KmlPoint k : kmlProperty.getKmlPoints()) { System.out.println(k.getPoints()); } System.out.println(\u0026quot;面\u0026quot;); }*/ } }  kmz格式\nFile kmzFile = new File(path); ZipFile zipFile = new ZipFile(kmzFile); ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(kmzFile)); InputStream inputStream = null; ZipEntry entry = null; Document doc = null; List\u0026lt;KmlPoint\u0026gt; points = new ArrayList\u0026lt;\u0026gt;(); while ((entry = zipInputStream.getNextEntry()) != null) { String zipEntryName = entry.getName(); //获取所需文件的节点 if (zipEntryName.equals(\u0026quot;doc.kml\u0026quot;)) {} }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/pdfutil/",
	"title": "Pdf工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.lowagie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itext\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.awt.Color; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.UUID; import com.cnmts.common.service.FileService; import com.cnmts.inspections.bean.RespInspectionTemplateInfo; import com.lowagie.text.Cell; import com.lowagie.text.Document; import com.lowagie.text.DocumentException; import com.lowagie.text.Element; import com.lowagie.text.Font; import com.lowagie.text.PageSize; import com.lowagie.text.Paragraph; import com.lowagie.text.Phrase; import com.lowagie.text.Table; import com.lowagie.text.pdf.BaseFont; import com.lowagie.text.pdf.PdfCopy; import com.lowagie.text.pdf.PdfImportedPage; import com.lowagie.text.pdf.PdfReader; import com.lowagie.text.pdf.PdfWriter; public class PdfUtil { private static final int N = 1; public static String CreatePdf(List\u0026lt;RespInspectionTemplateInfo\u0026gt; list) throws FileNotFoundException, DocumentException { String fileName = UUID.randomUUID().toString() + \u0026quot;.pdf\u0026quot;; String relatiePath = FileService.temp+\u0026quot;/\u0026quot;+DateUtil.getYear() + \u0026quot;/\u0026quot; + DateUtil.getMonth(); relatiePath = relatiePath + \u0026quot;/\u0026quot; + fileName; File file = new File(relatiePath); if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } // 创建一个文档对象纸张大小为A4 Document doc = new Document(PageSize.A4, 40, 40, 40, 40); // 设置要输出到磁盘上的文件名称 PdfWriter writer = PdfWriter.getInstance(doc, new FileOutputStream(new File(relatiePath))); MyEvent event = new MyEvent(); writer.setPageEvent(event); /* * //设置作者信息 doc.addAuthor(\u0026quot;sxyx2008\u0026quot;); //设置文档创建日期 doc.addCreationDate(); */ // 设置标题 doc.addTitle(\u0026quot;iText测试\u0026quot;); // 设置值主题 doc.addSubject(\u0026quot;iText\u0026quot;); // 打开文档开始写内容 doc.open(); // 构建一段落 Paragraph par3 = new Paragraph(\u0026quot;检查记录表\u0026quot;, ChineseFont()); // 设置局中对齐 par3.setAlignment(Element.ALIGN_CENTER); // 添加到文档 doc.add(par3); // 创建一个四列的表格 Table table = new Table(6); // 设置边框 table.setBorder(1); table.setBorderColor(Color.GRAY); table.setWidth(530); float[] widths = { 18, 170, 60, 130, 60, 50 }; table.setWidths(widths); table.setPadding(2); table.setLocked(true); // 创建表头 Cell cell1 = new Cell(new Phrase(\u0026quot;编号\\r\\n#\u0026quot;, ChineseFont())); cell1.setHorizontalAlignment(Element.ALIGN_CENTER); cell1.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell2 = new Cell(new Phrase(\u0026quot;项目\\r\\nItem\u0026quot;, ChineseFont())); cell2.setHorizontalAlignment(Element.ALIGN_CENTER); cell2.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell3 = new Cell(new Phrase(\u0026quot;设备\\r\\nAsset\u0026quot;, ChineseFont())); cell3.setHorizontalAlignment(Element.ALIGN_CENTER); cell3.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell4 = new Cell(new Phrase(\u0026quot;运行状态\\r\\nStatus\u0026quot;, ChineseFont())); cell4.setHorizontalAlignment(Element.ALIGN_CENTER); cell4.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell5 = new Cell(new Phrase(\u0026quot;采取/建议的措施\\r\\nPorposed Action\u0026quot;, ChineseFont())); cell5.setHorizontalAlignment(Element.ALIGN_CENTER); cell5.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell6 = new Cell(new Phrase(\u0026quot;备注\\r\\nRemark\u0026quot;, ChineseFont())); cell6.setHorizontalAlignment(Element.ALIGN_CENTER); cell6.setVerticalAlignment(Element.ALIGN_CENTER); table.addCell(cell1); table.addCell(cell2); table.addCell(cell3); table.addCell(cell4); table.addCell(cell5); table.addCell(cell6); // 添加此代码后每页都会显示表头 table.endHeaders(); // 循环向表格中添加100条记录 100行4列的表格 // 以下代码的作用是创建100行数据,其中每行有四列,列依次为 编号 姓名 性别 备注 for (int i = 0; i \u0026lt; list.size(); i++) { Cell cell11 = new Cell(new Phrase(i + 1 + \u0026quot;\u0026quot;, ChineseFont())); Cell cell22 = new Cell(new Phrase(list.get(i).getItemName(), ChineseFont())); Cell cell33 = new Cell(new Phrase(list.get(i).getAssetName(), ChineseFont())); Cell cell44 = null; if (list.get(i).getConditionMeasure() == 1) { cell44 = new Cell(new Phrase(\u0026quot;一般 不良\u0026quot;, ChineseFont())); } else if (list.get(i).getConditionMeasure() == 2) { cell44 = new Cell(new Phrase(\u0026quot;良好 一般 不良\u0026quot;, ChineseFont())); } else if (list.get(i).getConditionMeasure() == 3) { cell44 = new Cell(new Phrase(\u0026quot;很好 良好 一般 低劣 不良\u0026quot;, ChineseFont())); } else if (list.get(i).getConditionMeasure() == 4) { cell44 = new Cell(new Phrase(\u0026quot;得分( )\u0026quot;, ChineseFont())); } else { cell44 = new Cell(new Phrase(\u0026quot;比例( )\u0026quot;, ChineseFont())); } Cell cell55 = new Cell(new Phrase(\u0026quot;\u0026quot;)); Cell cell66 = new Cell(new Phrase(\u0026quot;\u0026quot;)); // 单元格水平对齐方式 cell11.setHorizontalAlignment(Element.ALIGN_LEFT); // 单元格垂直对齐方式 cell11.setVerticalAlignment(Element.ALIGN_CENTER); cell22.setHorizontalAlignment(Element.ALIGN_LEFT); cell22.setVerticalAlignment(Element.ALIGN_CENTER); cell33.setHorizontalAlignment(Element.ALIGN_LEFT); cell33.setVerticalAlignment(Element.ALIGN_CENTER); cell44.setHorizontalAlignment(Element.ALIGN_LEFT); cell44.setVerticalAlignment(Element.ALIGN_CENTER); cell55.setHorizontalAlignment(Element.ALIGN_LEFT); cell55.setVerticalAlignment(Element.ALIGN_CENTER); cell66.setHorizontalAlignment(Element.ALIGN_LEFT); cell66.setVerticalAlignment(Element.ALIGN_CENTER); table.addCell(cell11); table.addCell(cell22); table.addCell(cell33); table.addCell(cell44); table.addCell(cell55); table.addCell(cell66); } // 将表格添加到新的文档 doc.add(table); doc.close(); writer.close(); return relatiePath; } // pdf文档中文字符处理 public static Font ChineseFont() { BaseFont baseFont = null; try { baseFont = BaseFont.createFont(\u0026quot;c:\\\\windows\\\\fonts\\\\SIMHEI.TTF\u0026quot;, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); } catch (DocumentException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } Font chineseFont = new Font(baseFont, 8, Font.NORMAL, Color.black); return chineseFont; } public static byte[] mergePdfFiles(String[] files) { try { Document document = new Document(new PdfReader(files[0]).getPageSize(1)); ByteArrayOutputStream bos = new ByteArrayOutputStream(); PdfCopy copy = new PdfCopy(document, bos); document.open(); for (int i = 0; i \u0026lt; files.length; i++) { if (files[i] == null || files[i].equals(\u0026quot;\u0026quot;)) { continue; } PdfReader reader = new PdfReader(files[i]); int n = reader.getNumberOfPages(); for (int j = 1; j \u0026lt;= n; j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } } bos.flush(); bos.close(); copy.close(); document.close(); return bos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } catch (DocumentException e) { e.printStackTrace(); } return null; } public static void partitionPdfFile(String filepath) { Document document = null; PdfCopy copy = null; try { PdfReader reader = new PdfReader(filepath); int n = reader.getNumberOfPages(); if (n \u0026lt; N) { System.out.println(\u0026quot;The document does not have \u0026quot; + N + \u0026quot; pages to partition !\u0026quot;); return; } int size = n / N; String staticpath = filepath.substring(0, filepath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1); String savepath = null; ArrayList\u0026lt;String\u0026gt; savepaths = new ArrayList\u0026lt;String\u0026gt;(); for (int i = 1; i \u0026lt;= N; i++) { if (i \u0026lt; 10) { savepath = filepath.substring(filepath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1, filepath.length() - 4); savepath = staticpath + savepath + \u0026quot;0\u0026quot; + i + \u0026quot;.pdf\u0026quot;; savepaths.add(savepath); } else { savepath = filepath.substring(filepath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1, filepath.length() - 4); savepath = staticpath + savepath + i + \u0026quot;.pdf\u0026quot;; savepaths.add(savepath); } } for (int i = 0; i \u0026lt; N - 1; i++) { document = new Document(reader.getPageSize(1)); copy = new PdfCopy(document, new FileOutputStream(savepaths.get(i))); document.open(); for (int j = size * i + 1; j \u0026lt;= size * (i + 1); j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } document.close(); } document = new Document(reader.getPageSize(1)); copy = new PdfCopy(document, new FileOutputStream(savepaths.get(N - 1))); document.open(); for (int j = size * (N - 1) + 1; j \u0026lt;= n; j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } document.close(); } catch (IOException e) { e.printStackTrace(); } catch (DocumentException e) { e.printStackTrace(); } } }  通过Myevent在每页的开始和结尾加标注\n import java.io.IOException; import com.lowagie.text.BadElementException; import com.lowagie.text.Document; import com.lowagie.text.DocumentException; import com.lowagie.text.Image; import com.lowagie.text.pdf.PdfPageEventHelper; import com.lowagie.text.pdf.PdfWriter; public class MyEvent extends PdfPageEventHelper{ Image image; Image image2; Image image3; @Override public void onOpenDocument(PdfWriter writer, Document document) { String fileNameInResource = \u0026quot;/images/1.png\u0026quot;; String fileNameInResource2 =\u0026quot;/images/2.png\u0026quot;; String fileNameInResource3 = \u0026quot;/images/3.png\u0026quot;; try { image = Image.getInstance(fileNameInResource); image.setAbsolutePosition(30, 20); image.setWidthPercentage(10); image2 = Image.getInstance(fileNameInResource2); image2.setAbsolutePosition(470, 25); image3 = Image.getInstance(fileNameInResource3); image3.setAbsolutePosition(30, 800); } catch (BadElementException | IOException e) { e.printStackTrace(); } } @Override public void onEndPage(PdfWriter writer, Document document) { try { writer.getDirectContent().addImage(image); writer.getDirectContent().addImage(image2); } catch (DocumentException e) { e.printStackTrace(); } } @Override public void onStartPage(PdfWriter writer,Document document) { try { writer.getDirectContent().addImage(image3); } catch (DocumentException e) { e.printStackTrace(); } } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/httpclientutil/",
	"title": "Post请求",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import org.apache.http.HttpResponse; import org.apache.http.ParseException; import org.apache.http.client.HttpClient; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.NameValuePair; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.message.BasicNameValuePair; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; public class HttpClientUtils { private static final String userAgent_firefox = \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3\u0026quot;; @SuppressWarnings(\u0026quot;deprecation\u0026quot;) public static String doPost(String url, Map\u0026lt;String, String\u0026gt; params) { return doPost(url, params, null, HTTP.UTF_8); } @SuppressWarnings(\u0026quot;deprecation\u0026quot;) public static String doPost(String url, Map\u0026lt;String, String\u0026gt; params, Map\u0026lt;String, String\u0026gt; header) { return doPost(url, params, header, HTTP.UTF_8); } public static String doPost(String url, Map\u0026lt;String, String\u0026gt; params, Map\u0026lt;String, String\u0026gt; header, String charset) { String result = \u0026quot;\u0026quot;; HttpClient httpClient = getHttpClient(); HttpPost httpPost = getHttpPost(url); setHeader(header, httpPost); List\u0026lt;NameValuePair\u0026gt; nvps = new ArrayList\u0026lt;NameValuePair\u0026gt;(); if (params != null) { Set\u0026lt;String\u0026gt; keySet = params.keySet(); for (String key : keySet) { nvps.add(new BasicNameValuePair(key, params.get(key))); } } try { httpPost.setEntity(new UrlEncodedFormEntity(nvps, charset)); HttpResponse response = httpClient.execute(httpPost); result = EntityUtils.toString(response.getEntity()); } catch (IOException e) { e.printStackTrace(); } catch (ParseException pe) { pe.printStackTrace(); } return result; } public static File downloadFile(String url, File file) { HttpClient httpClient = getHttpClient(); HttpGet httpGet = getHttpGet(url); BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try { if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } InputStream inputStream = httpClient.execute(httpGet).getEntity() .getContent(); bufferedInputStream = new BufferedInputStream(inputStream); bufferedOutputStream = new BufferedOutputStream( new FileOutputStream(file)); byte[] buff = new byte[1024 * 1024]; int length = 0; while ((length = bufferedInputStream.read(buff)) != -1) { bufferedOutputStream.write(buff, 0, length); bufferedOutputStream.flush(); } } catch (Exception e) { e.printStackTrace(); } finally { if (bufferedInputStream != null) { try { bufferedInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if (bufferedOutputStream != null) { try { bufferedOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } return file; } private static HttpClient getHttpClient() { HttpClientBuilder create = HttpClientBuilder.create(); return create.build(); } private static HttpPost getHttpPost(String url) { HttpPost post = new HttpPost(url); post.setHeader(\u0026quot;User-Agent\u0026quot;, userAgent_firefox); return post; } private static HttpGet getHttpGet(String url) { HttpGet httpGet = new HttpGet(url); httpGet.setHeader(\u0026quot;User-Agent\u0026quot;, userAgent_firefox); return httpGet; } private static void setHeader(Map\u0026lt;String, String\u0026gt; header, Object obj) { if (header != null) {// 设置header Set\u0026lt;String\u0026gt; headerKey = header.keySet(); for (Iterator\u0026lt;String\u0026gt; iterator = headerKey.iterator(); iterator .hasNext();) { String key = (String) iterator.next(); String value = header.get(key); if (obj instanceof HttpPost) { ((HttpPost) obj).setHeader(key, value); } if (obj instanceof HttpGet) { ((HttpPost) obj).setHeader(key, value); } } } } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/web/react/",
	"title": "React",
	"tags": [],
	"description": "",
	"content": " 待完善 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/shputil/",
	"title": "Shp工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.geotools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gt-shapefile\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;19.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.geotools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gt-swing\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;19.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.geotools.data.FileDataStore; import org.geotools.data.FileDataStoreFinder; import org.geotools.data.shapefile.ShapefileDataStore; import org.geotools.data.simple.SimpleFeatureCollection; import org.geotools.data.simple.SimpleFeatureIterator; import org.geotools.data.simple.SimpleFeatureSource; import org.opengis.feature.simple.SimpleFeature; import org.opengis.filter.Filter; import java.io.File; import java.io.IOException; import java.nio.charset.Charset; import java.util.List; public class ShpUtil { public static void main(String[] args){ String path1 = \u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot; ; //读取shp SimpleFeatureCollection colls1 = readShp(path1); //拿到所有features SimpleFeatureIterator iters = colls1.features(); //遍历打印 while(iters.hasNext()){ SimpleFeature sf = iters.next(); List\u0026lt;Object\u0026gt; list = sf.getAttributes(); System.out.println(sf.getID() + \u0026quot; , \u0026quot; + sf.getAttributes()); } } public static SimpleFeatureCollection readShp(String path ){ return readShp(path, null); } public static SimpleFeatureCollection readShp(String path , Filter filter){ SimpleFeatureSource featureSource = readStoreByShp(path); if(featureSource == null) return null; try { return filter != null ? featureSource.getFeatures(filter) : featureSource.getFeatures() ; } catch (IOException e) { e.printStackTrace(); } return null ; } public static SimpleFeatureSource readStoreByShp(String path ){ File file = new File(path); FileDataStore store; SimpleFeatureSource featureSource = null; try { store = FileDataStoreFinder.getDataStore(file); ((ShapefileDataStore) store).setCharset(Charset.forName(\u0026quot;UTF-8\u0026quot;)); featureSource = store.getFeatureSource(); } catch (IOException e) { e.printStackTrace(); } return featureSource ; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/springboot/",
	"title": "SpringBoot",
	"tags": [],
	"description": "",
	"content": " 待完善 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/springcloud/",
	"title": "SpringCloud",
	"tags": [],
	"description": "",
	"content": " 一、工程环境搭建 spring cloud版本：Dalston.SR1\nspring boot版本：1.5.19.RELEASE\n1、父工程搭建 新建springcloud-study 父工程\npom文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;packaging\u0026gt;pom\u0026lt;/packaging\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;maven.compiler.source\u0026gt;1.8\u0026lt;/maven.compiler.source\u0026gt; \u0026lt;maven.compiler.target\u0026gt;1.8\u0026lt;/maven.compiler.target\u0026gt; \u0026lt;junit.version\u0026gt;4.12\u0026lt;/junit.version\u0026gt; \u0026lt;log4j.version\u0026gt;1.2.17\u0026lt;/log4j.version\u0026gt; \u0026lt;druid.version\u0026gt;1.1.10\u0026lt;/druid.version\u0026gt; \u0026lt;spring-boot.version\u0026gt;1.5.19.RELEASE\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;Dalston.SR1\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;mysql-connector.version\u0026gt;5.1.47\u0026lt;/mysql-connector.version\u0026gt; \u0026lt;mybatis-starter.version\u0026gt;1.3.3\u0026lt;/mybatis-starter.version\u0026gt; \u0026lt;logback.version\u0026gt;1.2.3\u0026lt;/logback.version\u0026gt; \u0026lt;lombok.version\u0026gt;1.18.6\u0026lt;/lombok.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mysql-connector.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${druid.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${mybatis-starter.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;log4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;log4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${log4j.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${logback.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${junit.version}\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;/project\u0026gt;  2 、构建公共子模块 springcloud-study-api pom文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-api\u0026lt;/artifactId\u0026gt; \u0026lt;/project\u0026gt;  3、构建服务提供者 springcloud-study-provider-dept-8001 pom文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-provider-dept-8001\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mybatis.spring.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  yml文件配置\n#配置服务器信息 server: port: 8001 #context-path: /study 配置根目录 #数据库信息配置 spring: application: name: study-springcloud-dept #应用名称 datasource: url: jdbc:mysql://localhost:3306/study?useUnicode=true\u0026amp;characterEncoding=UTF-8\u0026amp;serverTimezone=UTC\u0026amp;verifyServerCertificate=false\u0026amp;useSSL=false username: root password: root driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource #druid连接池配置 initialSize: 5 minIdle: 5 maxActive: 20 maxWait: 60000 timeBetweenEvictionRunsMillis: 60000 minEvictableIdleTimeMillis: 300000 validationQuery: SELECT 1 FROM DUAL testWhileIdle: true testOnBorrow: false testOnReturn: false poolPreparedStatements: true # 配置监控统计拦截的filters,去掉监控界面sql无法统计，‘wall’用于防火墙 filters: stat,wall,log4j maxPoolPreparedStatementPerConnectionSize: 20 userGlobalDataSourceStat: true connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500 #Mybatis配置 mybatis: mapper-locations: classpath:mapper/*.xml type-aliases-package: com.gxs.springcloud.entities configuration: map-underscore-to-camel-case: true #开启驼峰命名 cache-enabled: true #开启二级缓存  4、构建服务消费者 springcloud-study-consumer-dept-80 pom文件配置\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-consumer-dept-80\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  yml配置\nserver: port: 80  主启动类 @SpringBootApplication public class DeptConsumer80App { public static void main(String[] args) { SpringApplication.run(DeptConsumer80App.class,args); } }  二、Eureka配置 新建springcloud-study-euraka-7001工程，导入相关依赖 pom文件配置\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-euraka-7001\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--eureka-server 服务端--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  yml文件配置\nserver: port: 7001 eureka: instance: hostname: localhost #eureka服务端的实例名称 client: register-with-eureka: false #false表示不向注册中心注册自己 fetch-registry: false #false 表示自己就是注册中心，职责就是维护服务实例，并不需要去检索服务 service-url: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ #设置与eureka server 交互的地址查询服务和注册服务都需要依赖的地址  1、将服务注册进Eureka 8001provider服务中添加配置\n\u0026lt;!--将微服务provider注册进eureka--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  修改8001的yml配置\n#客户端注册进eureka服务列表 eureka: client: service-url: defaultZone: http://localhost:7001/eureka  8001 启动类增加@EnableEurekaClient注解\n@SpringBootApplication @EnableEurekaClient public class DeptProvider8001App { public static void main(String[] args) { SpringApplication.run(DeptProvider8001App.class,args); } }  注册成功，在7001的Eureka服务站中会显示 2、actuator与注册微服务信息完善 actuator：在springboot中主管监控和配置\n主机名称、服务名称修改\n1、修改8001的yml配置 eureka: client: service-url: defaultZone: http://localhost:7001/eureka #服务实例名称修改 instance: instance-id: study-springcloud-dept8001  访问信息有ip信息提示\n修改8001yml配置\n#客户端注册进eureka服务列表 eureka: client: service-url: defaultZone: http://localhost:7001/eureka instance: #服务实例名称修改 instance-id: study-springcloud-dept8001 #访问路径显示IP地址 prefer-ip-address: true  微服务info内容详细信息 1、修改8001的pom文件，增加actuator的配置 \u0026lt;!--actuator监控自信息完善--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  2、父工程pom文件修改，增加build信息 \u0026lt;build\u0026gt; \u0026lt;!--finalName 父工程名称--\u0026gt; \u0026lt;finalName\u0026gt;spring-cloud-study\u0026lt;/finalName\u0026gt; \u0026lt;resources\u0026gt; \u0026lt;resource\u0026gt; \u0026lt;directory\u0026gt;src/main/resources\u0026lt;/directory\u0026gt; \u0026lt;!--过滤开启--\u0026gt; \u0026lt;filtering\u0026gt;true\u0026lt;/filtering\u0026gt; \u0026lt;/resource\u0026gt; \u0026lt;/resources\u0026gt; \u0026lt;!--增加插件--\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.apache.maven.plugins\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;maven-resources-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;!--配置插件解析--\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;delimiters\u0026gt; \u0026lt;delimit\u0026gt;$\u0026lt;/delimit\u0026gt; \u0026lt;/delimiters\u0026gt; \u0026lt;/configuration\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt;  3、修改8001的yml，增加info信息 info: app.name: study-springcloud-micoservices company.name: www.gxs.com build.artifactId: $project.artifactId$ build.version: $project.version$  3、Eureka自我保护机制 Netflix在设置Eureka时，遵循AP原则\n某时刻某一微服务不可用时，eureka不会立刻清理，依旧会对改微服务的信息进行保存。服务失去心跳、名称变更、网络拥堵\n自我保护机制：应对网络异常的安全措施\n默认情况下，如果EurekaServer在一定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销实例（默认90秒）。但是当网络分区故障发生时，微服务与EurekaServer之间无法正常通信，以上行为可能变得非常危险——因为微服务本身其实是健康的，此时本不应该注销这个服务。Eureka通过“自我保护模式”来解决这个问题——当EurekaServer节点再短时间内丢失过多客户端时（可能发生网络故障），那么这个节点就会进入自我保护模式。一旦进去该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据（也即不会注销任何微服务）。当网络故障恢复后，改EurekaServer节点会自动退出自我保护模式。\n宁可保护错误的注册信息，也不盲目注销任何可能健康的微服务实例\n禁用自我保护机制 可以使用eureka.server.enable-self-preservation=false\n4、Eureka服务发现 对于注册进eureka里面的服务，可以通过服务发现获得该服务的信息\n供消费者调用\n1、添加服务发现接口 在8001工程的Controller类中增加DiscoveryClient\n@Autowired private DiscoveryClient discoveryClient;  2、增加自己服务描述的接口 @RequestMapping(value = \u0026quot;/dept/discovery\u0026quot;,method = RequestMethod.GET) public Object discovery(){ List\u0026lt;String\u0026gt; list = discoveryClient.getServices(); List\u0026lt;ServiceInstance\u0026gt; instances = discoveryClient.getInstances(\u0026quot;STUDY-SPRINGCLOUD-DEPT\u0026quot;); for (ServiceInstance element :instances){ System.out.println(element.getServiceId()); System.out.println(element.getHost()); System.out.println(element.getPort()); System.out.println(element.getUri()); } return this.discoveryClient; }  3、8001主启动类中增加 @@EnableDiscoveryClient注解 4、启动，调用http://localhost:8001/dept/discovery 8001需要等待注入一段时间，注入进server\n5、在80消费端中增加相应调用 @RequestMapping(value = \u0026quot;/consumer/dept/discovery\u0026quot;) public Object discovery(){ return restTemplate.getForObject( REST_URL_PREFIX+\u0026quot;/dept/discovery\u0026quot;, Object.class); }  5、Eureka集群配置 1、新建7002、7003Eureka服务项目 复制7001的pom、yml文件\n2、修改域名映射，修改host文件 必须修改，否则不成功 3、台Eureka的yml配置 修改7001、7002、7003对应的yml配置\nservice-url: # 单机版配置defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka #设置与eureka server 交互的地址查询服务和注册服务都需要依赖的地址 #集群配置 defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka  4、在8001配置注册 修改yml中集群的配置，使8001同时注册进7001-3集群环境\neureka: client: service-url: defaultZone: http://localhost:7001/eureka,http://localhost:7002/eureka,http://localhost:7003/eureka  至此有三个eureka集群，一个微服务提供者\n5、Eureka与Zookeeper的区别 CAP理论\nC：consistency 强一致性\nA：Availability 可用性 （HA高可用）\nP：Partition tolerance 分区容错性\nCAP理论\nEureka遵循AP原则\n弱一致性\n各个节点平等，不存在主存，只要有一台就能保证服务可用，但是可能不是最新的\n网络稳定，当前新注册的服务才会同步到其他节点\nZookeeper遵循CP理论\n问题：当master节点由于网络故障，与其他节点失去联系，剩余节点重新进行leader选举。问题在于，选举leader的时间太长，且选举期间zk集群不可用，导致注册服务瘫痪。\n三、Ribbon负载均衡 1、概述 基于Netflix ribbon实现的一套 客户端、负载均衡的工具\n重要功能是提供客户端的软件负载均衡算法，Ribbon客户端组件提供一系列的配置项如链接超时、重试等\n官网资料：github：Netfix/Ribbon\n常见的负载均衡：软件Nginx、LVS 硬件F5\n2、Ribbon初步配置 1、修改consumer-80的配置 修改pom配置，增加相关引用\n\u0026lt;!--Ribbon相关引用，与eureka有关--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  修改application.yml ,追加Eureka的注册服务地址\neureka: client: service-url: defaultZone: eureka7001.com:7001/eureka,http://eureka7002.com:7002/eureka,http://eureka7003.com:7003/eureka register-with-eureka: false  主启动类中增加注解@EnableEurekaClient，\n@SpringBootApplication @EnableEurekaClient public class DeptConsumer80App { public static void main(String[] args) { SpringApplication.run(DeptConsumer80App.class,args); } }  ConfigBean配置中增加@LoadBalance注解，开启客户端负载均衡\n@Configuration public class ConfigBean { /** * 配置RestTemplate * 通过RestTemplate调用提供者服务 ，发送rest请求 * 提供了多种访问http服务的方法， * 针对于访问rest服务\u0026lt;strong\u0026gt;客户端\u0026lt;/strong\u0026gt;的调用的模板类 */ @Bean @LoadBalanced //ribbon实现的一套 ==客户端、负载均衡的工具 public RestTemplate getRestTemplate(){ return new RestTemplate(); } }  修改客户端访问类80的controller，将地址改为微服务名称STUDY-SPRINGCLOUD-DEPT\n/** * 注册再EurekaServer中的微服务名称 */ private static final String REST_URL_PREFIX=\u0026quot;http://STUDY-SPRINGCLOUD-DEPT\u0026quot;;  启动\n先启动Eureka集群，然后启动8001服务注册进eureka，再启动80客户端\n3、Ribbon负载均衡 1、架构说明 2、新建8002、8003服务提供者 复制8001的配置和类\nyml配置中的实例名称application name不能改\n3、总结 Ribbon其实就是一个软辅在均衡的客户端组件，他和其他所有需要请求的客户端结合使用，和Eureka结合只是其中的一个实例。默认采用轮询算法。\n4、Ribbon核心组件IRule IRule：根据特定算法中从服务列表中选取一个要访问的服务\nRibbon采用的负载均衡算法： com.netflix.loadbalancer.RoundRobinRule  轮询：默认\ncom.netflix.loadbalancer.RandomRule  随机\ncom.netflix.loadbalancer.AvailabilityFilteringRule  会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务、还有并发的连接数量超过阈值的服务，然后对剩余的服务列表按照轮询策略进行访问\ncom.netflix.loadbalancer.WeightedResponseTimeRule  根据平均响应时间计算所有服务的权重，响应时间越快的服务权重越大，选中的概率越高。刚启动时如果统计信息不足，则上有RoundRobinRule策略，等统计信息足够，会切换到WeightedResponseTimeRule\ncom.netflix.loadbalancer.RetryRule  先按RoundRobinRule轮询算法获取服务，如果失败则在指定时间内进行重试\ncom.netflix.loadbalancer.BestAvailableRule  会先过滤掉由于多次访问故障而处于断路器跳闸状态的服务，然后选择一个并发量最小的服务\ncom.netflix.loadbalancer.ZoneAvoidanceRule  默认规则，复合判断Server所在区域的性能和Server的可用性选择服务\n配置负载均衡算法 在ConfigBean中显示声明算法,增加bean\n@Bean public IRule myRule(){ //用我们选择的随机算法 return new RandomRule(); }  5、Ribbon自定义 1、主启动类上添加注解@RibbonClient @SpringBootApplication @EnableEurekaClient /** * 在启动该微服务式是能去加载我们定义的Ribbon配置类 */ @RibbonClient(name=\u0026quot;STUDY-SPRINGCLOUD-DEPT\u0026quot;,configuration = MySelfRule.class) public class DeptConsumer80App { public static void main(String[] args) { SpringApplication.run(DeptConsumer80App.class,args); } }  2、配置注意细节 自定义配置类不能放在@ComponentScan所扫描的当前包以及子包下，否则我们自定义的这个配置类就会被所有的Ribbon客户端锁共享，达不到特殊定制化的目的\n3、自定义规则深度解析 /** 继承AbstractLoadBalancerRule 实现 **/ public class MyRandomRule extends AbstractLoadBalancerRule { //实现代码 }  四、Feign负载均衡 1、概述 官网地址：http://cloud.spring.io/spring-cloud-openfeign/single/spring-cloud-openfeign.html\n是一个声明式Webservice客户端，，使得编写web服务客户端变得非常容易\n只需要创建一个接口，然后再上面添加注解即可\n面向接口编程，比如webservice接口\n微服务名称获得调用地址\n通过接口+注解，获得调用服务\n统一面向接口的编程套路—feign\n前面再使用Ribbon+RestTemplate时，利用RestTemplate对http请求的封装处理，形成一套模板化的调用方法，但是在实际的开发中，由于对服务依赖的调用可能不止一处，往往一个接会被多处调用，所以通常会针对每个微服务自行封装一些客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了一些封装，由他来帮助我么定义和实现依赖服务接口的定义。在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它（以前是Dao接口上面标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解即可），即可完成对位服务提供方便的接口绑定，简化了使用Spring Cloud Ribbon时，自动封装服务调用客户端的开发量。\n2、Feign的使用步骤 参考springcloud-study-consumer-dept-80模块，新建springcloud-study-consumer-dept-feign模块\n修改pom文件\n\u0026lt;!--增加Feign的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-feign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  修改主启动类\n修改springcloud-study-api\npom文件修改\n添加Feign支持依赖，与springcloud-study-consumer-dept-feign一致\n新建DeptClientService接口类，并增加注解@FeignClient\n@FeignClient(value = \u0026quot;STUDY-SPRINGCLOUD-DEPT\u0026quot;) public interface DeptClientService { @RequestMapping(value = \u0026quot;/dept/add\u0026quot;,method = RequestMethod.GET) public boolean add( DeptEntity deptEntity); @RequestMapping(value = \u0026quot;/dept/findById/{deptNo}\u0026quot;,method = RequestMethod.GET) public DeptEntity findById(Long deptNo); @RequestMapping(value = \u0026quot;/dept/findAll\u0026quot;,method = RequestMethod.GET) public List findAll(); }  在springcloud-study-consumer-dept-feign修改Controller，修改基于上述配置的接口\n@RestController public class DeptConsumerController { @Autowired private DeptClientService deptClientService; @RequestMapping(value = \u0026quot;/consumer/dept/add\u0026quot;) public boolean add( DeptEntity deptEntity){ //三个参数：url,requestMap ResponseBean.class return deptClientService.add(deptEntity); } @RequestMapping(\u0026quot;/consumer/dept/findById/{deptNo}\u0026quot;) public DeptEntity findById(Long deptNo){ //三个参数：url,requestMap ResponseBean.class return deptClientService.findById(deptNo); } @RequestMapping(\u0026quot;/consumer/dept/findAll\u0026quot;) public List findAll(){ //三个参数：url,requestMap ResponseBean.class return deptClientService.findAll(); } }  修改Feign模块主启动类，增加@EnableFeignClients注解\n@SpringBootApplication @EnableEurekaClient /** * 在启动该微服务式是能去加载我们定义的Feign配置类 */ @EnableFeignClients(basePackages = \u0026quot;com.gxs.springcloud\u0026quot;) @ComponentScan(\u0026quot;com.gxs.springcloud\u0026quot;) public class DeptConsumerFeignApp { public static void main(String[] args) { SpringApplication.run(DeptConsumerFeignApp.class,args); } }  3、Feign集成了Ribbon 利用Ribbon维护了STUDY-SPRINGCLOUD-DEPT的服务列表，并且通过轮询实现了客户端的负载均衡。而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅的而简单的实现了服务调用。\n4、小结 Feign通过接口的方法调用Rest服务（之前是Ribbon+RestTemplate）\n该请求发送给Eureka服务器（http://STUDY-SPRINGCLOUD-DEPT/depe/findAll）通过Feign直接找到服务接口，由于再进行服务调用时候融合了Ribbon技术，所以也支持负载均衡\n五、Hystrix 断路器 1、概述 分布式面临的问题 复杂分布式体系结构复杂的依赖关系，不可避免的存在服务宕机，网络中断的问题\n服务雪崩\n多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的服务，这就是所谓的扇出。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的雪崩效应。\n对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几秒钟内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源的紧张，导致整个系统发生更多的级联故障。这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。\nHystrix介绍 Hystrix是一个用于处理分布式系统的延迟和容错的开源库，在分布式系统中，许多依赖不可避免的会调用失败，比如超时、异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个服务失败，避免级联故障，以提高分布式系统的弹性。\n“断路器”本身是一种开关设置，当某个服务单元发生故障之后，通过断路器的故障监控（类似熔断保险丝），向调用方返回一个符合预期的，可处理的备选响应（FallBack），而不是长时间的等待或者抛出服务方无法处理的异常，这样就保证服务方调用线程不会被长时间、不必要的占用，从而避免故障再分布式系统中的绵延，乃至雪崩。\n功能\n服务降级\n服务熔断\n服务限流\n接近试试的监控\n。。。。。\n官网资料：https://github.com/Netflix/Hystrix/wiki\n2、服务熔断 应对雪崩效应的一种微服务链路保护机制，快速返回错误的响应信息。\n熔断机制的注解：@HystrixCommand\n1、参考springcloud-study-provider-dept-8001新建，springcloud-study-provider-dept-hystrix-8001模块 pom文件新增\n\u0026lt;!--Hystrix依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  yml文件修改实例id\n#服务实例名称修改\ninstance-id: study-springcloud-dept8001-hystrix  修改DeptController\n用HystrixCommand报异常后如何处理\n一旦服务调用失败并抛出错误信息后，会自动调用@HystrixCommand标注好的fallBackMethod调用类中知道的方法\n@RequestMapping(value = \u0026quot;/dept/findById/{deptNo}\u0026quot;,method = RequestMethod.GET) public DeptEntity findById(Long deptNo) { DeptEntity deptEntity = deptService.findById(deptNo); if(null ==deptEntity){ throw new RuntimeException(\u0026quot;该deptNo没有对应的信息\u0026quot;+deptNo); } return deptEntity; } public DeptEntity processHystrixGet(Long deptNo){ return new DeptEntity().setDeptNo(deptNo) .setDeptName(\u0026quot;该deptNo没有对应的信息\u0026quot;) .setDbSource(\u0026quot;没有这个数据库\u0026quot;); }  在主启动类上添加==@EnableCircuitBreaker==\n3、服务降级 整体资源不够了，忍痛将某些服务先关掉，待度过难关后再开启。\n资源的抢占和分配\n所谓降级，一般是从整体负荷考虑，当某个服务熔断后，服务器将不再被调用，此时客户端可以自己准备一个本地的fallback回调，返回一个缺省值，这样做，虽然服务水平下降，好歹能用，比直接改掉要强。\n服务降级是在客户端（消费者）处理完成的，与服务端没关系\n1、修改springcloud-study-api模块 根据已有的com.gxs.springcloud.service.DeptClientService接口，新建一个实现FallBackFactory接口的类\n//@Component 不要忘记添加 //主业务与熔断方法解耦 @Component public class DeptClientServiceFallBackFactory implements FallbackFactory\u0026lt;DeptClientService\u0026gt; { @Override public DeptClientService create(Throwable throwable) { return new DeptClientService() { @Override public boolean add(DeptEntity deptEntity) { return false; } @Override public DeptEntity findById(Long deptNo) { return new DeptEntity().setDeptNo(deptNo) .setDeptName(\u0026quot;该deptNo没有对应的信息，Consumer客户端提供的降级信息，此刻服务provider已经关闭\u0026quot;) .setDbSource(\u0026quot;没有这个数据库\u0026quot;); } @Override public List findAll() { return null; } }; } }  在DeptClientService中的FeignClient注解中添加FallBackfactory属性值\n@FeignClient(value = \u0026quot;STUDY-SPRINGCLOUD-DEPT\u0026quot;,fallbackFactory = DeptClientServiceFallBackFactory.class) public interface DeptClientService {  springcloud-study-consumer-dept-feign修改yml\nfeign: hystrix: enable: ture;  4、HystrixDashboard 1、概述 除了隔离依赖服务的调用以外，Hystrix还提供了准实时的调用监控（Hystrix Dashboard),Hystrix会持续的记录所有通过Hystrix发起的请求的执行信息，并统计报表和图形的形式展示给用户，包括每秒执行多少次清酒，多少成功，多少失败等。Netflix通过Hystrix-metrics-event-stream项目实现了对以上指标的监控。spring cloud 也提供了对Hystrix Dashboard的整合，对监控内容转化成可视化的界面。\n2、构建步骤 构建模块项目springcloud-study-consumer-hystrix-dashboard\npom文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-consumer-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Ribbon相关引用--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-ribbon\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--增加Feign的依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-feign\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--hystrix-dashboard依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix-dashboard\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;junit\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;junit\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  yml文件 ```` server: port: 9001\n 主启动类  @SpringBootApplication @EnableHystrixDashboard public class HystrixDashboardApp { public static void main(String[] args) { SpringApplication.run(HystrixDashboardApp.class,args); } }\n 所有provider微服务提供类（8001、8002、8002）都需要监控依赖配置   org.springframework.boot spring-boot-starter-actuator \n 启动,访问地址http://localhost:9001/hystrix ![1](/image/20190331202643852.png '') 填写监控 ![1](/image/20190331202700840.png '') ## 六、zuul路由网关 ### 1、概述 Zuul包含了对请求的路由和过滤的主要功能： 路由功能 主要负责将外部请求转发到具体的微服务上，是实现外部访问入口的基础 过滤功能 负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础 Zuul与Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同事从Eureka中获得其他微服务的信息，也即以后的微服务访问都是通过Zuul跳转后获得。 ==三大功能----==代理、路由、过滤 ### 2、路由基本配置 新建springcloud-study-zuul-gateway-9527模块 pom文件  \u0026lt;?xml version=\u0026ldquo;1.0\u0026rdquo; encoding=\u0026ldquo;UTF-8\u0026rdquo;?\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-zuul-gateway-9527\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${project.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--zuul依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Hystrix容错--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt;   yml文件\nserver: port: 9527 spring: application: name: springcloud-study-zuul-gateway eureka: instance: instance-id: gateway-9572 prefer-ip-address: true client: service-url: # 单机版配置defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka #设置与eureka server 交互的地址查询服务和注册服务都需要依赖的地址 #集群配置 defaultZone: http://eureka7001.com:7001/eureka/,http://eureka7002.com:7002/eureka/ info: app.name: springcloud-study-zuul-gateway company.name: www.gxs.com build.artifactId: ${project.artifactId} build.version: ${project.version}  host文件修改\n127.0.0.1 myzuul.com  主启动类\n@SpringBootApplication @EnableZuulProxy public class ZuulGatewayApp { public static void main(String[] args) { SpringApplication.run(ZuulGatewayApp.class,args); } }  3、测试 不启用路由：http://localhost:8001/dept/findAll\n启用路由：http://myzuul.com:9527/STUDY-SPRINGCLOUD-DEPT/dept/findAll\n4、路由访问映射规则 1、代理名称 修改yml，增加如下配置\n配置后http://myzuul.com:9527/STUDY-SPRINGCLOUD-DEPT/dept/findAll\n可变为http://myzuul.com:9527/mydept/dept/findAll\nzuul: routes: mydept.serviceId: STUDY-SPRINGCLOUD-DEPT mydept.path: /mydept/*  原真实服务名忽略\nzuul: routes: mydept.serviceId: STUDY-SPRINGCLOUD-DEPT mydept.path: /mydept/* #多个用\u0026quot;*\u0026quot; ignored-services: \u0026quot;*\u0026quot; ignored-services: STUDY-SPRINGCLOUD-DEPT  设置统一公共前缀\nzuul: routes: mydept.serviceId: STUDY-SPRINGCLOUD-DEPT mydept.path: /mydept/* #多个用\u0026quot;*\u0026quot; ignored-services: \u0026quot;*\u0026quot; ignored-services: STUDY-SPRINGCLOUD-DEPT #公共前缀 prefix: /springcloud  七、SpringCloud Config 分布式配置中心 1、概述 分布式系统面临问题，配置问题\n集中式的、动态的配置管理必不可少 Spring colud Config为微服务架构中心的微服务提供集中式的外部配置支持，配置服务器为各个不同的微服务应用提供一个中心化的外部配置\nSpring colud Config分为服务端和客户端两部分\n服务端 也成为分布式配置中心，他是一个独立的微服务应用，用来连接配置服务器并未客户端提供获取配置等访问接口\n客户端 通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取配置，配置服务器默认采用git来存储配置信息。这样有助于对环境配置的版本管理，并且可以通过git客户端访问配置内容\n2、功能 集中管理配置文件\n不同环境不同配置，动态化的配置更新，分环境部署，dev/test/prod/beta/release\n当配置发生变化是，服务不需要重启\n运行期间动态调整配置\n将配置信息以rest接口形式暴露\n与github、svn整合\n3、SpringCloud Config 服务端配置 1、在github上新建springcloud-study-config的repository https://github.com/gongxings/springcloud-study-config.git\n2、在本地硬盘中新建git仓库并clone git clone https://github.com/gongxings/springcloud-study-config.git\n3、在本地git仓库中新建一个application.yml 格式必须是UTF-8的形式保存，否则会有乱码 提交到github\n4、新建module，springcloud-study-config-3344 pom文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-config-3344\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config-server\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--zuul依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Hystrix容错--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  yml文件\nserver: port: 3344 spring: application: name: springcloud-study-config cloud: config: server: git: # uri: git@github.com:gongxings/springcloud-study-config.git uri: https://github.com/gongxings/springcloud-study-config.git search-paths: config-repo username: #账号 password: #密码  主启动类\n@SpringBootApplication @EnableConfigServer public class Config3344App { public static void main(String[] args) { SpringApplication.run(Config3344App.class,args); } }  修改host文件增加映射\n127.0.0.1 config3344.com  启动服务，访问yml\nhttp://config3344.com:3344/application-dev.yml\nhttp://config3344.com:3344/application/dev/master\n4、SpringCloud Config 客户端配置与测试 1、在本地git仓库中新建一个springcolud-study-config.yml  server: port: 8202 spring: profiles: test #开发环境 application: name: springcloud-study-config-client eureka: client: service-url: defaultZone: eureka7001.com:7001/eureka #请保存为UTF-8格式  5、新建springcloud-study-config-client-3355模块 pom文件\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;project xmlns=\u0026quot;http://maven.apache.org/POM/4.0.0\u0026quot; xmlns:xsi=\u0026quot;http://www.w3.org/2001/XMLSchema-instance\u0026quot; xsi:schemaLocation=\u0026quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026quot;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;com.gxs.springcloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-study\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;artifactId\u0026gt;springcloud-study-config-client-3355\u0026lt;/artifactId\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--zuul依赖--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-eureka\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-zuul\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--Hystrix容错--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-hystrix\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;ch.qos.logback\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;logback-core\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!--热部署 修改后立即生效--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;springloaded\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-devtools\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt;  主启动类\n@SpringBootApplication public class ConfigClient3355App { public static void main(String[] args) { SpringApplication.run(ConfigClient3355App.class,args); } }  yml文件\napplication.yml是用户级的资源配置项\nbootstrap.xml是系统级的，优先级更高\nSpringcolud 会创建一个BootStrap Context，作为spring应用的Application Context的父上下文。初始化的时候，BootStrap Context负责从外部资源加载配置属性并解析配置。这两个上下文共享一个外部获取的Environment。BootStrap 属性有高优先级，默认情况下，他们不会被本地配置覆盖。BootStrap Context和Application Context有着不同的约定。\n所以新增一个bootstrap.xml，保证BootStrap Context和Application Context的配置分离。\napplication.yml\nspring: application: name: springcloud-study-config-client  bootstrap.xml\nspring: cloud: config: name: springcloud-study-config-client #需要从github上服务的资源名称，注意没有yml后缀 profile: dev #本次访问的配置项 label: master uri: http://config3344.com:3344 #本次服务启动后，先去找3344服务，通过SpringCloudConfig获取github上的配置  host文件配置\n127.0.0.1 config-client.com  新建rest类，验证是否能从Github上读取配置\n@RestController public class ConfigClientRest { @Value(\u0026quot;${spring.application.name}\u0026quot;) private String applicationName; @Value(\u0026quot;${eureka.client.server-url.defaultZone}\u0026quot;) private String eurekaServers; @Value(\u0026quot;${server.port}\u0026quot;) private String port; @RequestMapping(\u0026quot;/config\u0026quot;) public String getConfig(){ System.out.println(\u0026quot;applicationName:\u0026quot;+this.applicationName +\u0026quot;eurekaServers:\u0026quot;+this.eurekaServers +\u0026quot;port:\u0026quot;+this.port); return \u0026quot;applicationName:\u0026quot;+this.applicationName +\u0026quot;eurekaServers:\u0026quot;+this.eurekaServers +\u0026quot;port:\u0026quot;+this.port; } }  测试\n启动3344、3355\n4、配置实战 config服务端配置测试OK，我们可以和config+github进行配置修改并获得内容\n做一个wureka服务+一个dept访问的微服务，将两个微服务的配置统一由github获得实现统一配置，分布式管理，完成多环境变更。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/wordutil/",
	"title": "Word工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.math.BigInteger; import java.util.List; import org.apache.poi.xwpf.usermodel.ParagraphAlignment; import org.apache.poi.xwpf.usermodel.TextAlignment; import org.apache.poi.xwpf.usermodel.XWPFParagraph; import org.apache.poi.xwpf.usermodel.XWPFRun; import org.apache.poi.xwpf.usermodel.XWPFTable; import org.apache.poi.xwpf.usermodel.XWPFTableCell; import org.apache.poi.xwpf.usermodel.XWPFTableRow; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHpsMeasure; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRPr; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcPr; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTVerticalJc; import org.openxmlformats.schemas.wordprocessingml.x2006.main.STMerge; import org.openxmlformats.schemas.wordprocessingml.x2006.main.STVerticalJc; public class WordUtil { /** * 创建一行，如果有则直接使用 * * @param table * @param rowNum * @return */ public static XWPFTableRow createRow(XWPFTable table, int rowNum) { XWPFTableRow row = table.getRow(rowNum); if (row == null) { row = table.createRow(); } return row; } /** * 创建一列，如果有则使用 * * @param row * 行 * @param cellNum * 列号 * @return */ public static XWPFTableCell createCell(XWPFTableRow row, int cellNum) { XWPFTableCell cell = row.getCell(cellNum); if (cell == null) { cell = row.createCell(); } return cell; } /** * 和并列 * * @param cell * 被合并的列 * @param from * 起始列号 * @param index * 当前列号 * @param to * 结束列号 */ public static void mergeCell(XWPFTableCell cell, int from, int index, int to) { CTTcPr cellCTTcPr = getCellCTTcPr(cell); if (from == index) { cellCTTcPr.addNewHMerge().setVal(STMerge.RESTART); } else { cellCTTcPr.addNewHMerge().setVal(STMerge.CONTINUE); } } /** * 合并行 * * @param cell * 被合并的列 * @param from * 起始行号 * @param index * 当前行号 * @param to * 结束行号 */ public static void mergeRow(XWPFTableCell cell, int from, int index, int to) { CTTcPr cellCTTcPr = getCellCTTcPr(cell); if (from == index) { cellCTTcPr.addNewVMerge().setVal(STMerge.RESTART); } else { cellCTTcPr.addNewVMerge().setVal(STMerge.CONTINUE); } } /** * @Description: 得到Cell的CTTcPr,不存在则新建 * @param cell * @return */ public static CTTcPr getCellCTTcPr(XWPFTableCell cell) { CTTc cttc = cell.getCTTc(); CTTcPr tcPr = cttc.isSetTcPr() ? cttc.getTcPr() : cttc.addNewTcPr(); return tcPr; } /** * 设置单元格垂直对齐 * * @param vAlign * STVerticalJc * @param cell */ public static void setCellVAlign(STVerticalJc.Enum vAlign, XWPFTableCell cell) { CTTcPr cellCTTcPr = getCellCTTcPr(cell); CTVerticalJc vJc = cellCTTcPr.isSetVAlign() ? cellCTTcPr.getVAlign() : cellCTTcPr.addNewVAlign(); vJc.setVal(STVerticalJc.CENTER); } /** * 设置水平对齐方式 * * @param align * ParagraphAlignment * @param cell */ public static void setCellHAlign(ParagraphAlignment align, XWPFTableCell cell) { List\u0026lt;XWPFParagraph\u0026gt; paragraphs = cell.getParagraphs(); for (XWPFParagraph xwpfParagraph : paragraphs) { xwpfParagraph.setAlignment(align); } } /** * @Description: 设置单元格Margin */ public static void setTableCellMargin(XWPFTable table, int top, int left, int bottom, int right) { table.setCellMargins(top, left, bottom, right); } /** * 获得XWPFRun * * @param p * 段落 * @param isInsert * @param isNewLine * @return */ public static XWPFRun getOrAddParagraphFirstRun(XWPFParagraph p, boolean isInsert, boolean isNewLine) { XWPFRun pRun = null; if (isInsert) { pRun = p.createRun(); } else { if (p.getRuns() != null \u0026amp;\u0026amp; p.getRuns().size() \u0026gt; 0) { pRun = p.getRuns().get(0); } else { pRun = p.createRun(); } } if (isNewLine) { pRun.addBreak(); } return pRun; } /** * @Description: 得到XWPFRun的CTRPr */ public static CTRPr getRunCTRPr(XWPFParagraph p, XWPFRun pRun) { CTRPr pRpr = null; if (pRun.getCTR() != null) { pRpr = pRun.getCTR().getRPr(); if (pRpr == null) { pRpr = pRun.getCTR().addNewRPr(); } } else { pRpr = p.getCTP().addNewR().addNewRPr(); } return pRpr; } /** * @Description: 设置段落对齐 */ public static void setParagraphAlignInfo(XWPFParagraph p, ParagraphAlignment pAlign, TextAlignment valign) { if (pAlign != null) { p.setAlignment(pAlign); } if (valign != null) { p.setVerticalAlignment(valign); } } public static void setFontStyle(XWPFParagraph p, XWPFRun pRun, String fontSize, boolean isBlod, boolean isItalic) { CTRPr pRpr = getRunCTRPr(p, pRun); // 设置字体大小 CTHpsMeasure sz = pRpr.isSetSz() ? pRpr.getSz() : pRpr.addNewSz(); sz.setVal(new BigInteger(fontSize)); CTHpsMeasure szCs = pRpr.isSetSzCs() ? pRpr.getSzCs() : pRpr.addNewSzCs(); szCs.setVal(new BigInteger(fontSize)); // 设置字体样式 // 加粗 if (isBlod) { pRun.setBold(isBlod); } // 倾斜 if (isItalic) { pRun.setItalic(isItalic); } } /** * 设置单元格文本 * * @param cell * @param text * 文本内容 * @param fontSize * 字号 */ public static void setCellText(XWPFTableCell cell, String text, String fontSize) { List\u0026lt;XWPFParagraph\u0026gt; paragraphs = cell.getParagraphs(); if (paragraphs == null || paragraphs.size() \u0026lt; 1) { cell.addParagraph(); } XWPFParagraph cellParagraph = cell.getParagraphs().get(0); XWPFRun cellRun = WordUtil.getOrAddParagraphFirstRun(cellParagraph, false, false); WordUtil.setFontStyle(cellParagraph, cellRun, fontSize, false, false); cellRun.setText(text); cell.setParagraph(cellParagraph); } public static void setCellText2(XWPFTableCell cell, String text, String fontSize,String fontFamily,boolean bold) { List\u0026lt;XWPFParagraph\u0026gt; paragraphs = cell.getParagraphs(); if (paragraphs == null || paragraphs.size() \u0026lt; 1) { cell.addParagraph(); } XWPFParagraph cellParagraph = cell.getParagraphs().get(0); XWPFRun cellRun = WordUtil.getOrAddParagraphFirstRun(cellParagraph, false, false); cellRun.setFontFamily(fontFamily); WordUtil.setFontStyle(cellParagraph, cellRun, fontSize, bold, false); cellRun.setText(text); cell.setParagraph(cellParagraph); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/word2htmlutil/",
	"title": "Word转换html",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.apache.commons.lang3.SystemUtils; import org.apache.poi.hwpf.HWPFDocument; import org.apache.poi.hwpf.converter.PicturesManager; import org.apache.poi.hwpf.converter.WordToHtmlConverter; import org.apache.poi.hwpf.usermodel.Picture; import org.apache.poi.hwpf.usermodel.PictureType; import org.apache.poi.xwpf.converter.core.BasicURIResolver; import org.apache.poi.xwpf.converter.core.FileImageExtractor; import org.apache.poi.xwpf.converter.core.XWPFConverterException; import org.apache.poi.xwpf.converter.xhtml.XHTMLConverter; import org.apache.poi.xwpf.converter.xhtml.XHTMLOptions; import org.apache.poi.xwpf.usermodel.XWPFDocument; import org.w3c.dom.Document; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.*; import java.util.List; /** * * word转换html的工具类 * * @author xiaoming * * @time 2016年11月29日 下午3:53:08 */ public class Word2HtmlUtil { private static String word2003 = \u0026quot;application/msword\u0026quot;; private static String word2007 = \u0026quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0026quot;; public static File convert2Html(String wordFilePath, String htmlFilePath, String relativePath) throws FileNotFoundException, IOException, ParserConfigurationException, TransformerException { String probeContentType = FileUtil.getFileContentType(new File(wordFilePath)); if (word2003.equals(probeContentType)) { // word 2003： return word20032Html(wordFilePath, htmlFilePath, relativePath); } else if (word2007.equals(probeContentType)) { // word 2007 return word20072Html(wordFilePath, htmlFilePath, relativePath); } else { return null; } } private static File word20032Html(String wordFilePath, String htmlFilePath, String relativePath) throws FileNotFoundException, IOException, ParserConfigurationException, TransformerException { HWPFDocument wordDocument = new HWPFDocument(new FileInputStream(wordFilePath)); WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter(DocumentBuilderFactory.newInstance().newDocumentBuilder() .newDocument()); wordToHtmlConverter.setPicturesManager(new PicturesManager() { @Override public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches) { return \u0026quot;../../../docimg/\u0026quot; + suggestedName; } }); wordToHtmlConverter.processDocument(wordDocument); // save pictures List\u0026lt;Picture\u0026gt; pics = wordDocument.getPicturesTable().getAllPictures(); if (pics != null) { for (int i = 0; i \u0026lt; pics.size(); i++) { Picture pic = pics.get(i); try { File file = new File(relativePath + \u0026quot;docimg/\u0026quot; + pic.suggestFullFileName()); if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } pic.writeImageContent(new FileOutputStream(relativePath + \u0026quot;docimg/\u0026quot; + pic.suggestFullFileName())); } catch (FileNotFoundException e) { e.printStackTrace(); } } } Document htmlDocument = wordToHtmlConverter.getDocument(); ByteArrayOutputStream out = new ByteArrayOutputStream(); DOMSource domSource = new DOMSource(htmlDocument); StreamResult streamResult = new StreamResult(out); TransformerFactory tf = TransformerFactory.newInstance(); Transformer serializer = tf.newTransformer(); if (SystemUtils.IS_OS_WINDOWS) { serializer.setOutputProperty(OutputKeys.ENCODING, \u0026quot;GBK\u0026quot;); } serializer.setOutputProperty(OutputKeys.INDENT, \u0026quot;yes\u0026quot;); serializer.setOutputProperty(OutputKeys.METHOD, \u0026quot;html\u0026quot;); serializer.transform(domSource, streamResult); out.close(); return writeFile(new String(out.toByteArray()), htmlFilePath); } private static File word20072Html(String wordFilePath, String htmlFilePath, String relativePath) throws XWPFConverterException, IOException { OutputStreamWriter outputStreamWriter = null; try { XWPFDocument document = new XWPFDocument(new FileInputStream(wordFilePath)); XHTMLOptions options = XHTMLOptions.create(); // 存放图片的文件夹 options.setExtractor(new FileImageExtractor(new File(relativePath + \u0026quot;docimg\u0026quot;))); // html中图片的路径 options.URIResolver(new BasicURIResolver(\u0026quot;../../../docimg\u0026quot;)); outputStreamWriter = new OutputStreamWriter(new FileOutputStream(htmlFilePath), \u0026quot;utf-8\u0026quot;); XHTMLConverter xhtmlConverter = (XHTMLConverter) XHTMLConverter.getInstance(); xhtmlConverter.convert(document, outputStreamWriter, options); } finally { if (outputStreamWriter != null) { outputStreamWriter.close(); } } return new File(htmlFilePath); } public static File writeFile(String content, String path) { FileOutputStream fos = null; BufferedWriter bw = null; try { File file = new File(path); fos = new FileOutputStream(file); bw = new BufferedWriter(new OutputStreamWriter(fos, \u0026quot;UTF-8\u0026quot;)); bw.write(content); return file; } catch (FileNotFoundException fnfe) { fnfe.printStackTrace(); } catch (IOException ioe) { ioe.printStackTrace(); } finally { try { if (bw != null) bw.close(); if (fos != null) fos.close(); } catch (IOException ie) { } } return null; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/csvutil/",
	"title": "csv 工具类",
	"tags": [],
	"description": "",
	"content": " import com.nuclear_Project.common.bean.Dictionary; import java.io.*; import java.lang.reflect.*; import java.util.ArrayList; import java.util.List; public class CSVUtil\u0026lt;T\u0026gt; { private String[] fields; private Class\u0026lt;T\u0026gt; entityClass; public CSVUtil(Class\u0026lt;T\u0026gt; clazz,String... fields){ this.entityClass = clazz; this.fields = fields; } public List\u0026lt;T\u0026gt; importCSV(File file) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { List\u0026lt;String\u0026gt; dataList = importCSVFile(file); List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); Constructor constructor = entityClass.getConstructor(null); Method[] methods = entityClass.getMethods(); Field[] fields = entityClass.getDeclaredFields(); for(String s:dataList){ T instance = (T) constructor.newInstance(null); String entity = s; String[] values = entity.split(\u0026quot;,\u0026quot;); for(int i=0;i\u0026lt;values.length;i++){ Field field = fields[i]; if(!field.isAccessible()){ field.setAccessible(true); } if(field.getType().equals(Integer.class)){ field.setInt(instance,Integer.parseInt(values[i])); }else if(field.getType().equals(int.class)){ field.setInt(instance,Integer.parseInt(values[i])); }else if(field.getType().equals(String.class)){ field.set(instance,values[i]); } } list.add(instance); } return list; } public List\u0026lt;String\u0026gt; importCSVFile(File file){ List\u0026lt;String\u0026gt; dataList=new ArrayList\u0026lt;String\u0026gt;(); BufferedReader br=null; try { br = new BufferedReader(new FileReader(file)); String line = \u0026quot;\u0026quot;; while ((line = br.readLine()) != null) { if(line.startsWith(\u0026quot;\\uFEFF\u0026quot;)){ line = line.replace(\u0026quot;\\uFEFF\u0026quot;, \u0026quot;\u0026quot;); } dataList.add(line); } }catch (Exception e) { }finally{ if(br!=null){ try { br.close(); br=null; } catch (IOException e) { e.printStackTrace(); } } } return dataList; } public Boolean exportCSV(List\u0026lt;T\u0026gt; dataList, File file) throws NoSuchFieldException, IllegalAccessException { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;dataList.size();i++){ StringBuilder string = new StringBuilder(); T instance = dataList.get(i); for(int j=0;j\u0026lt;fields.length;j++){ String field = fields[j]; Field entityField = entityClass.getDeclaredField(field); if(!entityField.isAccessible()){ entityField.setAccessible(true); } Object value = entityField.get(instance); string.append(value.toString()); int k = fields.length-1; if(j!=k){ string.append(\u0026quot;,\u0026quot;); } } list.add(string.toString()); } return exportCsvFile(file,list); } public boolean exportCsvFile(File file, List\u0026lt;String\u0026gt; dataList){ boolean isSucess=false; FileOutputStream out=null; OutputStreamWriter osw=null; BufferedWriter bw=null; try { out = new FileOutputStream(file); byte[] uft8bom={(byte)0xef,(byte)0xbb,(byte)0xbf}; out.write(uft8bom); bw = new BufferedWriter(new OutputStreamWriter(out, \u0026quot;UTF-8\u0026quot;)); if(dataList!=null \u0026amp;\u0026amp; !dataList.isEmpty()){ for(String data : dataList){ bw.append(data).append(\u0026quot;\\r\u0026quot;); } } isSucess=true; } catch (Exception e) { isSucess=false; }finally{ if(bw!=null){ try { bw.close(); bw=null; } catch (IOException e) { e.printStackTrace(); } } if(osw!=null){ try { osw.close(); osw=null; } catch (IOException e) { e.printStackTrace(); } } if(out!=null){ try { out.close(); out=null; } catch (IOException e) { e.printStackTrace(); } } } return isSucess; } public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { File file = new File(\u0026quot;d:\\\\test.csv\u0026quot;); /* List\u0026lt;Dictionary\u0026gt; ds = new ArrayList\u0026lt;\u0026gt;(); for(int i=1;i\u0026lt;10;i++){ Dictionary d = new Dictionary(); d.setDictId(i); d.setDictKey(i); d.setDictName(\u0026quot;测试\u0026quot;+i); ds.add(d); } String[] fields = {\u0026quot;dictId\u0026quot;,\u0026quot;dictKey\u0026quot;,\u0026quot;dictName\u0026quot;}; CSVUtil csvUtil = new CSVUtil(Dictionary.class,fields); try { csvUtil.exportCSV(ds,file); }catch (Exception e){ e.printStackTrace(); }*/ String[] fields = {\u0026quot;dictId\u0026quot;,\u0026quot;dictKey\u0026quot;,\u0026quot;dictName\u0026quot;}; CSVUtil csvUtil = new CSVUtil(Dictionary.class,fields); List\u0026lt;Dictionary\u0026gt; list = (List\u0026lt;Dictionary\u0026gt;)csvUtil.importCSV(file); for(Dictionary d:list){ System.out.print(d); } } }  实体类\n public class Dictionary { private int dictId; private int dictKey; private String dictName; private String dictType; private String remark; private int dictSort; @Override public String toString() { return \u0026quot;Dictionary{\u0026quot; + \u0026quot;dictId=\u0026quot; + dictId + \u0026quot;, dictKey=\u0026quot; + dictKey + \u0026quot;, dictName='\u0026quot; + dictName + '\\'' + \u0026quot;, dictType='\u0026quot; + dictType + '\\'' + \u0026quot;, remark='\u0026quot; + remark + '\\'' + \u0026quot;, dictSort=\u0026quot; + dictSort + '}'; } public String getRemark() { return remark; } public void setRemark(String remark) { this.remark = remark; } public int getDictSort() { return dictSort; } public void setDictSort(int dictSort) { this.dictSort = dictSort; } public int getDictKey() { return dictKey; } public void setDictKey(int dictKey) { this.dictKey = dictKey; } public int getDictId() { return dictId; } public void setDictId(int dictId) { this.dictId = dictId; } public String getDictName() { return dictName; } public void setDictName(String dictName) { this.dictName = dictName; } public String getDictType() { return dictType; } public void setDictType(String dictType) { this.dictType = dictType; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/docker/",
	"title": "docker 基本使用",
	"tags": [],
	"description": "",
	"content": " 一． docker常用命令 1. 从公网拉取一个镜像 docker pull images_name  2. 查看已有的docker镜像 [root@docker ~]# docker images  3. 查看帮助 docker command --help  4. 查看镜像列表 docker search nginx  5. 启动一个容器 基于hello-world镜像启动一个容器，如果本地没有镜像会从公网拉取过来，这次做为测试用\ndocker run hello-world  6. 导出镜像 docker save -o image_name.tar image_name  7. 删除镜像 docker rmi image_name  8. 启动一个容器 docker run --name=con_name images  \u0026ndash;name #设置容器名\n9. 基于创建好的容器自定义docker镜像 docker commit -m \u0026quot;con_name\u0026quot; con_id image_name  10. 创建一个容器的同时进入这个容器 docker run -it --name=con_name images  -it #在启动之后进入这个容器\n11. 创建一个容器，放入后台运行，把物理机80端口映射到容器的80端口 docker run -d -p 81:80 image_name  #-p 参数说明 -p hostPort:containerPort -p ip:hostPort:containerPort -p ip::containerPort -p hostPort:containerPort:udp\n12. 看容器的端口映射情况 docker port con_id  13. 查看正在运行的容器 docker ps  14. 查看所有的容器 docker ps -a  15. 动态查看容器日志 docker logs -f con_name  16. 进入容器 docker attach con_name  17. 退出容器 方法一\nexit  方法二 ctrl+p \u0026amp;\u0026amp; ctrl+q (一起按，注意顺序，退出后容器依然保持启动状态)\n18. 删除容器 docker rm con_name  强制删除需要加-f，不加-f不能删除正在运行中的容器，非常危险，最好不用\n19. 查看docker网络 [root@docker ~]# docker network ls  NETWORK ID NAME DRIVER SCOPE 3f91f2097286 bridge bridge local d7675dbd247c docker_gwbridge bridge local 5b36c7e947fd host host local ims6qkpikafu ingress overlay swarm 85ba10e7ef79 none null local\n20. 创建一个docker网络my-docker docker network create -d bridge \\  \u0026ndash;subnet=192.168.0.0/24 \u0026ndash;gateway=192.168.0.100 \u0026ndash;ip-range=192.168.0.0/24 my-docker\n21. 利用刚才创建的网络启动一个容器 docker run --network=my-docker --ip=192.168.0.5 -itd --name=con_name -h lb01 image_name  \u0026ndash;network #指定容器网络 \u0026ndash;ip #设定容器ip地址 -h #给容器设置主机名\n22. 查看容器pid 方法一：\ndocker top con_name  方法二：\ndocker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; con_name  23. 运行dockerfile并给dockerfile创建的镜像建立名字 docker build -t mysql:3.6.34 `pwd`  24. mariadb容器启动前需先设置密码方法 docker run -d -P -e MYSQL_ROOT_PASSWORD=password img_id  25. docker修改镜像名 docker tag imageid name:tag  26. 进入docker容器脚本 [root@docker ~]# cat nsenter.sh PID=`docker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; $1` nsenter -t $PID -u --mount -i -n -p  27. 创建一个网络 docker network create --driver bridge --subnet 172.22.16.0/  24 \u0026ndash;gateway 172.22.16.1 my_net2\n28. 将容器添加到my_net2网络 connect docker network connect my_net2 oldboy1  29. docker日志模块 使用filebeat收集日志 { \u0026ldquo;registry-mirrors\u0026rdquo;: [\u0026ldquo;https://56px195b.mirror.aliyuncs.com\u0026quot;], \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;consul://192.168.56.13:8500\u0026rdquo;, \u0026ldquo;cluster-advertise\u0026rdquo;: \u0026ldquo;192.168.56.11:2375\u0026rdquo;, \u0026ldquo;log-driver\u0026rdquo;: \u0026ldquo;fluentd\u0026rdquo;, \u0026ldquo;log-opts\u0026rdquo;: { \u0026ldquo;fluentd-address\u0026rdquo;:\u0026ldquo;192.168.56.13:24224\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;:\u0026ldquo;linux-node1.example.com\u0026rdquo; } }\n二． docker安装mysql 第一步，拉取MySQL镜像 $ sudo docker pull mysql  之后docker会自动拉取（下载）MySQL镜像。 拉取成功后我们查看一下：\n$ sudo docker images  第二步，创建并启动一个MySQL容器 输入以下命令：\n$ sudo docker run --name pwc-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql  • –name：给新创建的容器命名，此处命名为pwc-mysql • -e：配置信息，此处配置mysql的root用户的登陆密码 • -p：端口映射，此处映射主机3306端口到容器pwc-mysql的3306端口 • -d：成功启动容器后输出容器的完整ID，例如上图 73f8811f669ee\u0026hellip; • 最后一个mysql指的是mysql镜像名字 到这里我们查看容器运行状态：\n$ sudo docker ps  上图可以看到容器的简写ID，容器的源镜像，创建时间，状态，端口映射信息，容器名字等。\n第三步，修改mysql登录权限 docker exec -it xgmysql /bin/bash  进入mysql命令 通过mysql -uroot -p进入mysql的命令行模式 修改mysql登录权限\nALTER USER 'root'@'localhost' IDENTIFIED BY 'password'  PASSWORD EXPIRE NEVER;这里的password是你正在使用的密码\nALTER USER 'root'@'localhost' IDENTIFIED WITH  mysql_native_password BY \u0026lsquo;password\u0026rsquo;;#更新一下用户的密码这里的password为你修改的新密码。\nFLUSH PRIVILEGES;  刷新权限，使自己的修改生效。\nalter user 'root'@'%' identified by 'password' password expire never; alter user 'root'@'%' identified with mysql_native_password by 'why';//why是自己新修改的密码。 flush privileges;再次刷新一下权限配置。  三． redis安装（6379） docker pull redis docker run -d --name myredis -p 6379:6379 redis --requirepass \u0026quot;mypassword\u0026quot; 加密码  四． RabbitMq docker pull rabbitmq: 3-management  默认端口 5672\u0026frasl;15672 默认密码 guest/guest\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/ffmpeg/",
	"title": "ffmpeg 使用",
	"tags": [],
	"description": "",
	"content": " 1. 获取视频信息 import java.io.*; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 获取视频的信息 */ public class VideoInfo { //视频路径 private String ffmpegApp; //视频时 private int hours; //视频分 private int minutes; //视频秒 private float seconds; //视频width private int width; //视频height private int heigt; public VideoInfo() {} public VideoInfo(String ffmpegApp) { this.ffmpegApp = ffmpegApp; } public String toString() { return \u0026quot;time: \u0026quot; + hours + \u0026quot;:\u0026quot; + minutes + \u0026quot;:\u0026quot; + seconds + \u0026quot;, width = \u0026quot; + width + \u0026quot;, height= \u0026quot; + heigt; } public void getInfo(String videoFilename) throws IOException, InterruptedException { String tmpFile = videoFilename + \u0026quot;.tmp.png\u0026quot;; ProcessBuilder processBuilder = new ProcessBuilder(ffmpegApp, \u0026quot;-y\u0026quot;, \u0026quot;-i\u0026quot;, videoFilename, \u0026quot;-vframes\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;-ss\u0026quot;, \u0026quot;0:0:0\u0026quot;, \u0026quot;-an\u0026quot;, \u0026quot;-vcodec\u0026quot;, \u0026quot;png\u0026quot;, \u0026quot;-f\u0026quot;, \u0026quot;rawvideo\u0026quot;, \u0026quot;-s\u0026quot;, \u0026quot;100*100\u0026quot;, tmpFile); Process process = processBuilder.start(); InputStream stderr = process.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line; //打印 sb，获取更多信息。 如 bitrate、width、heigt StringBuffer sb = new StringBuffer(); while ((line = br.readLine()) != null) { sb.append(line); } new File(tmpFile).delete(); System.out.println(\u0026quot;video info:\\n\u0026quot; + sb); Pattern pattern = Pattern.compile(\u0026quot;Duration: (.*?),\u0026quot;); Matcher matcher = pattern.matcher(sb); if (matcher.find()) { String time = matcher.group(1); calcTime(time); } pattern = Pattern.compile(\u0026quot;w:\\\\d+ h:\\\\d+\u0026quot;); matcher = pattern.matcher(sb); if (matcher.find()) { String wh = matcher.group(); //w:100 h:100 String[] strs = wh.split(\u0026quot;\\\\s+\u0026quot;); if(strs != null \u0026amp;\u0026amp; strs.length == 2) { width = Integer.parseInt(strs[0].split(\u0026quot;:\u0026quot;)[1]); heigt = Integer.parseInt(strs[1].split(\u0026quot;:\u0026quot;)[1]); } } process.waitFor(); if(br != null) br.close(); if(isr != null) isr.close(); if(stderr != null) stderr.close(); } private void calcTime(String timeStr) { String[] parts = timeStr.split(\u0026quot;:\u0026quot;); hours = Integer.parseInt(parts[0]); minutes = Integer.parseInt(parts[1]); seconds = Float.parseFloat(parts[2]); } public String getFfmpegApp() { return ffmpegApp; } public void setFfmpegApp(String ffmpegApp) { this.ffmpegApp = ffmpegApp; } public int getHours() { return hours; } public void setHours(int hours) { this.hours = hours; } public int getMinutes() { return minutes; } public void setMinutes(int minutes) { this.minutes = minutes; } public float getSeconds() { return seconds; } public void setSeconds(float seconds) { this.seconds = seconds; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeigt() { return heigt; } public void setHeigt(int heigt) { this.heigt = heigt; } public static void main(String[] args) { VideoInfo videoInfo = new VideoInfo(\u0026quot;H:\\\\ffmpeg-20180808-af4c2ac-win64-static\\\\bin\\\\ffmpeg.exe\u0026quot;); try { videoInfo.getInfo(\u0026quot;h:/1532786415142.mp4\u0026quot;); System.out.println(videoInfo); } catch (Exception e) { e.printStackTrace(); } } }  2.获取截图 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; public class VideoThumbTaker { protected String ffmpegApp; public VideoThumbTaker(String ffmpegApp) { this.ffmpegApp = ffmpegApp; } @SuppressWarnings(\u0026quot;unused\u0026quot;) /**** * 获取指定时间内的图片 * @param videoFilename:视频路径 * @param thumbFilename:图片保存路径 * @param width:图片长 * @param height:图片宽 * @param hour:指定时 * @param min:指定分 * @param sec:指定秒 * @throws IOException * @throws InterruptedException */ public void getThumb(String videoFilename, String thumbFilename, int width, int height, int hour, int min, float sec) throws IOException, InterruptedException { ProcessBuilder processBuilder = new ProcessBuilder(ffmpegApp, \u0026quot;-y\u0026quot;, \u0026quot;-i\u0026quot;, videoFilename, \u0026quot;-vframes\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;-ss\u0026quot;, hour + \u0026quot;:\u0026quot; + min + \u0026quot;:\u0026quot; + sec, \u0026quot;-f\u0026quot;, \u0026quot;mjpeg\u0026quot;, \u0026quot;-s\u0026quot;, width + \u0026quot;*\u0026quot; + height, \u0026quot;-an\u0026quot;, thumbFilename); Process process = processBuilder.start(); InputStream stderr = process.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) ; process.waitFor(); if(br != null) br.close(); if(isr != null) isr.close(); if(stderr != null) stderr.close(); } public static void main(String[] args) { VideoThumbTaker videoThumbTaker = new VideoThumbTaker(\u0026quot;H:\\\\ffmpeg-20180808-af4c2ac-win64-static\\\\bin\\\\ffmpeg.exe\u0026quot;); try { videoThumbTaker.getThumb(\u0026quot;C:/java/apache-tomcat-7.0.54/apache-tomcat-7.0.54/webapps/zhsqData/tempFile/25a464df-735c-4321-b60b-bd1faae2b127_src.mp4\u0026quot;, \u0026quot;C:/java/apache-tomcat-7.0.54/apache-tomcat-7.0.54/webapps/zhsqData/tempFile/thumbTest2.png\u0026quot;, 800, 600, 0, 0, 9); System.out.println(\u0026quot;over\u0026quot;); } catch (Exception e) { e.printStackTrace(); } } }  3. 合成视频 合成视频有很多方式，多次试验，以下方法最好用 生成txt文件\nfile 'input1.mkv' file 'input2.mkv' file 'input3.mkv'  private static void createMp4(String txtFilePath, String filePath) throws IOException { List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;\u0026gt;(); s.add(\u0026quot;H:\\\\ffmpeg-20180808-af4c2ac-win64-static\\\\bin\\\\ffmpeg.exe\u0026quot;); s.add(\u0026quot;-f\u0026quot;); s.add(\u0026quot;concat\u0026quot;); s.add(\u0026quot;-safe\u0026quot;); s.add(\u0026quot;0\u0026quot;); s.add(\u0026quot;-i\u0026quot;); s.add(txtFilePath); s.add(\u0026quot;-c\u0026quot;); s.add(\u0026quot;copy\u0026quot;); s.add(filePath); ProcessBuilder builder = new ProcessBuilder(); builder.command(s); builder.start(); }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/ffmpeg/",
	"title": "ffmpeg 安装",
	"tags": [],
	"description": "",
	"content": " 　ffmpeg是一个很强大的音视频处理工具，官网是：http://ffmpeg.org/ 官网介绍ffmpeg是：一个完整的、跨平台的解决方案，可以记录、转换和传输音频和视频。ffmpeg既可以播放视频，也提供命令行工具来处理视频，另外还有强大的视频处理库用于开发。\n1.windows版本 下载解压即可使用链接： 下载地址 提取码：bqi9\n2.linux版本 下载地址 提取码：gtv9\n2.1 解压 tar -xjvf ffmpeg-3.3.1.tar.bz2 cd ffmpeg-4.0.2/  2.2 安装yasm 如果现在直接执行configure配置的话，可能会报如下的错误：\n错误的意思是 yasm/nasm 包不存在或者很旧，可以使用\u0026ndash;disable-yasm禁用这个选项编译，yasm是一款汇编器，并且是完全重写了nasm的汇编环境，接收nasm和gas语法，支持x86和amd64指令集，所以这里安装一下yasm即可，下载地址，提取码：sg9d。 执行下面命令安装：\ntar -xvzf yasm-1.3.0.tar.gz cd yasm-1.3.0/ ./configure make make install  编译参数都是默认的，直接安装到系统中即可。\n2.3 安装ffmpeg ./configure --enable-shared --prefix=/monchickey/ffmpeg make make install  编译过程有点长，耐心等待完成之后执行\n cd /monchickey/ffmpeg/bin  进入安装目录，查看一下发现有bin,include,lib,share这4个目录，其中bin是ffmpeg主程序二进制目录，include是C/C++头文件目录，lib是编译好的库文件目录，share是文档目录，然后进入bin目录，执行\n./ffmpeg -version  查看当前版本的详细信息，默认情况下一般会报libavdevice.so.57: cannot open shared object file: No such file or directory，原因是lib目录未加载到链接到系统库中，系统ld目录列表在/etc/ld.so.conf中，打开文件会发现，里面引用了/etc/ld.so.conf.d/下面所有的.conf文件，比如mariadb-x86_64.conf我们只需要创建一个文件并写入lib路径即可，执行命令：\nvim /etc/ld.so.conf.d/ffmpeg.conf  然后添加一行内容：\n/monchickey/ffmpeg/lib  之后保存并退出，然后执行\nldconfig  使配置生效，现在再次执行\n./ffmpeg -version  显示就正常了\n然后可以根据需要将bin目录添加至环境变量中以保证任何时候都能使用ffmpeg命令，下面测试一下对视频进行转码： 首先由一个avi格式的视频文件，大小是37M，现在使用ffmpeg转换为mp4格式，执行下面命令：\nffmpeg -i test.avi out.mp4  确认之后，看到屏幕滚动开始处理，大约半分钟之后视频就转换完毕了，转换后mp4视频大小是17M，具体可以下载下来看一下 java使用\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/gitlab/",
	"title": "gitlab 离线安装",
	"tags": [],
	"description": "",
	"content": " 1. 配置本地yum源 需要准备CentOs-Everything的iso作为本地yum源。一下以/root/CentOs-7-x86_64-DVD-1708.iso为例。\n2. 挂载镜像 mount -o loop /root/CentOs-7-x86_64-DVD-1708.iso /mnt/yum-iso  如果文件夹不存在可以提前mkdir\n3. 启动httpd服务 systemctl start httpd.service  4. 检查httpd服务状态 systemctl status httpd.service  如果状态正常，通过“http://服务器IP:80/”应该可以访问到http的欢迎页，如果开启防火墙，要开放80端口。\n5. 添加软链接 ln -s /mnt/yum-ios/ /var/www/html/CentOS-7-x86_64  如果顺利，通过“http://服务器IP:80/CentOS-7-x86_64”可以访问到iso中的文件。\n6. 准备配置本地yum源 cd /etc/yum.repos.d  7. 备份其他 repo:tar zcvf repo-bk.tar.gz CentOS-*  8. 移除其他 repo:rm -rf ./CentOS-*  9. 配置本地 repo:vi CentOS-Media.repo  内容如下\nname=CentOS-$releasever - Media baseurl=file:///yum/yum-iso/ gpgcheck=0 enable=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7  10. 制作cashe yum clear all yum makecache  11. 上传gitlab-ee文件 12. 跳转到gitlab-ee文件夹位置 13.安装 yum localinstall ./gitlab-ee-11.0.rpm  一路y知道成功\n14. 配置 主要修改各端口配置，避免端口占用 其中externam_url \u0026ldquo;服务器ip:端口\u0026rdquo; 为主界面ip及端口\n15. 更新配置 gitlab-ctl reconfigure  16. 启动git gitlab-car restart  如果出现502，检查端口号是否占用，然后调用步骤15,16重新访问。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/hugo/",
	"title": "hugo 搭建个人博客",
	"tags": [],
	"description": "",
	"content": " 1.准备工作 1.1 msysGit客户端 在Windows下默认是没有预装Git的，如果你是Mac和Linux的用户则没有这个烦恼，因此我们首先需要在Windows系统下安装一个Git软件，笔者使用的是msysGit，截止发文最新的版本是2.6.3，官网Download会自动识别系统（32位和64位）下载，之后一个个步骤按照向导安装就行，上面英文写的很清楚，基本可以按照默认的来，但是到了Ajusting your PATH environment（即设置环境变量）这一步时，建议还是勾选第二项Run Git from Windows Command Prompt，这样在Windows命令行中就可以全局使用Git相关命令。\n1.2 注册Github 点击Github官网进入Github首页，这样你能够进行注册，输入用户名、Email地址、密码即可进行注册，我们选择不需要花钱的Free类型用户，点击Finish sign up，这样即可完成注册，此时在页面顶部Bootcamp系统会提示你接下来可以做哪些事情，而我们首先需要做的就是Create Repositories，我们可以点击这一项进去看看教程，当然也可以根据我下面的提示直接开始： 1. 点击右侧New repository（新建仓库），此时系统会提示你验证邮箱，你需要去刚刚注册用的邮箱验证地址； 2. 验证完毕即可重新New reository，用户名一定要用：你的注册用户名.github.io，其他无需修改，然后点击Create repository即可; 3. 下面自动进入一个快速设置页面，告诉我们如何在仓库内添加东西，这就需要在Windows本地设置了。\n1.3 Windows本地配置Git 本文开篇就说了Windows下的Git程序，但是没有做配置，还是不能用的，这里解说下基本的配置： 1. 首先打开Git Bash做些全局设置： 1. git config \u0026ndash;global user.name \u0026ldquo;你的注册用户名\u0026rdquo; 2. git config \u0026ndash;global user.email \u0026ldquo;你的邮箱\u0026rdquo; 3. git config \u0026ndash;global color.ui auto 2. 设置SSH Key： 3. ssh-keygen -t rsa -C \u0026ldquo;你的邮箱\u0026rdquo; 然后会要求输入存储id_rsa的目录，接着是输入密码，这个密码可以与github的不同，过程中确认即可，最后会出现一个随机图形，说明生成SSH密匙成功，这样我们需要到刚刚的存储目录下打开id_rsa.pub复制里面的内容，到你的github页面上-\u0026gt;点击右上角头像旁三角-\u0026gt;settings-\u0026gt;SSH keys-\u0026gt;add SSH key-\u0026gt;黏贴刚刚复制的内容保存。\n1.4 使用hugo hugo是一个快速的静态网站引擎，使用Go语言开发，可以用Markdown格式的文章生成一个完整的静态网站，然后托管到自己的用户名.Github.io的Github仓库中，实现一个静态站点，一般用于博客或者项目主页等。那么我们先来了解下如何获取和使用： 1. 先从官网下载相关的版本，比如我是32位windows系统的，我下载hugo_0.14_windows_386.zip； 2. 解压缩后，将里面的exe文件重命名为hugo.exe，并放在C:\\hugo\\hugo.exe即可； 3. 添加环境变量：我的电脑-属性-高级系统设置-环境变量，编辑PATH，加入;C:\\hugo,用英文分号与之前的内容分割开。 这样我们可以测试下环境是否正常： 使用Windows命令行（Win+R输入cmd）输入下列命令：\ncd C:\\hugo hugo new site www  进入hugo目录下可以看到一个www的文件夹，就是刚刚新建的站点，目录的结构是： 1. ▸ archetypes/ 2. ▸ content/ 3. ▸ layouts/ 4. ▸ static/ 5. config.toml 尽管里面没有任何内容，但是恭喜你，说明程序可以正常使用了。\n2.正式建立静态网站 2.1 新建文章 首先需要先命令行进入www文件夹下，然后输入以下命令，创建一个关于页面：\nhugo new about.md  这样就生成楼www/content/about.md，打开该文件可以看到以下信息： 1. +++ 2. date = \u0026ldquo;2015-11-15T10:42:51+08:00\u0026rdquo; 3. draft = true 4. title = \u0026ldquo;about\u0026rdquo; 5.\n6. +++ 文件是md的，但是+++之间的内容是用TOML编写的文档信息，date代表文档创建的时间，后面的+08：00代表的时区，draft代表草稿，如果生成网站时不加入特殊说明是不生成该页的，title是这篇文章的标题，因此正文中不需要自己再写标题了。 为了方便之后生成聚合页面，我们继续在www/content/post/目录生成第一篇文章： hugo new post/first.md 打开first.md文件可以看到以下内容，跟上面的about.md差不多，我们在+++后面编辑一点内容并保存： 1. +++ 2. date = \u0026ldquo;2015-11-15T10:48:56+08:00\u0026rdquo; 3. draft = true 4. title = \u0026ldquo;first\u0026rdquo; 5.\n6. +++ 7. # My first blog 8. 1. aaa 9. 2. bbb 10. 3. ccc\n2.2 安装皮肤 hugo有很多皮肤(Github),也可以看这里(中文),可以找到喜欢的皮肤地址，然后在www文件夹下创建一个themes文件夹，在命令行中进入该文件夹后用git的方法获得皮肤(笔者这里使用hyde这个简单点的皮肤主题)：\ngit clone http://github.com/spf13/hyde.git  2.3 运行hugo 在站点根目录www文件夹下运行hugo调试命令： hugo server \u0026ndash;theme=hyde \u0026ndash;buildDrafts \u0026ndash;watch theme指明使用的主题名称（themes文件夹下的主题文件夹名称），buildDrafts指出编译草稿部分（即draft=true的文件），watch参数可以在文件修改时实时自动刷新页面。生成后我们可以在按照命令行提示在浏览器中输入http://127.0.0.1:1313查看页面，正常的话显示如下： 2.4 简单配置 目前为止，已经生成一个简单的静态站点，但是还有很多地方需要修改，以适应每个人的需求，可以在www站点根目录下看到一个config.toml配置文件，该文件使用TOML语法编写，基本内容如下：\nbaseurl = \u0026quot;http://replace-this-with-your-hugo-site.com/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot;  4.将本地站点上传 之前第一节已经注册好Github并创建软件仓库，现在我们需要生成最终的页面并上传到自己的Github仓库中，完成站点的最终部署，只需要在www根目录输入：\nhugo  或没有配置好config.toml文件的话用：\nhugo --thmem=hyde --baseUrl=\u0026quot;http://用户名.github.io\u0026quot;  这样在www目录下会生成一个public文件夹用于发布正式的站点，进行下列操作上传所有文件：\ncd public git init git remote add origin https://github.com/用户名/用户名.github.io.git git add -A git commit -m \u0026quot;first commit\u0026quot; git push -u origin master  过程中会要求用户输入github的用户名和密码，密码是隐式的，所以别以为没输入。上传成功后，只要在浏览器中输入http://用户名.github.io即可访问你自己的站点了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/java/",
	"title": "java",
	"tags": [],
	"description": "",
	"content": " java相关资料 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/jstutil/",
	"title": "java几何运算工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.vividsolutions\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jts\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  任意多边形相交面积\npublic static void main(String[] args) { // TODO Auto-generated method stub Coordinate[] coordinates1 = new Coordinate[]{ new Coordinate(125.72447156,39.82054423),new Coordinate(125.72447156,39.76282084), new Coordinate(125.77791891,39.76282084),new Coordinate(125.77791891,39.82054423), new Coordinate(125.72447156,39.82054423) }; Coordinate[] coordinates2 = new Coordinate[]{ new Coordinate(125.164119759729,40.0612609250715),new Coordinate(126.100803385316,39.9877343597289), new Coordinate(126.174165535013,39.2037784330532),new Coordinate(125.396225932331,39.2476580006858), new Coordinate(124.902255206616,39.7014452467443),new Coordinate(124.902267040602,39.7014536164514), new Coordinate(124.902267040602,39.7014536164514),new Coordinate(125.164119759729,40.0612609250715) }; /* Coordinate[] coordinates2 = new Coordinate[]{ new Coordinate(125,40),new Coordinate(125,38), new Coordinate(125.75,38),new Coordinate(125.75,40), new Coordinate(125,40) };*/ Geometry g1 = new GeometryFactory().createPolygon(coordinates1); Geometry g2 = new GeometryFactory().createPolygon(coordinates2); boolean isIter = g1.intersects(g2); if(isIter)System.out.println(\u0026quot;相交\u0026quot;); else System.out.println(\u0026quot;不相交\u0026quot;); Geometry g3 = g1.intersection(g2); Coordinate[] coordinates = g3.getCoordinates(); /* for(int i=0;i\u0026lt;coordinates.length;i++){ System.out.print(coordinates[i]); }*/ Geometry g4 = new GeometryFactory().createPolygon(coordinates); System.out.print(\u0026quot;g1-\u0026quot;+g1.getArea()); System.out.print(\u0026quot;g2-\u0026quot;+g2.getArea()); System.out.print(\u0026quot;g4-\u0026quot;+g4.getArea()); }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/",
	"title": "java工具类",
	"tags": [],
	"description": "",
	"content": " java工具类 "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/nexus3/",
	"title": "nexus3安装及使用",
	"tags": [],
	"description": "",
	"content": " Nexus3 安装：  Nexus3 运行时需要java8以上的环境，官方说不支持openjdk，但是我使用目前没有发现问题；\nNexus3允许为程序配置专用的jre环境，这样的话不会影响外部程序的运行。版本不一样也没问题。\n 只需要修改启动文件，/bin/nexus。 INSTALL4J_JAVA_HOME_OVERRIDE=/usr/lib/jvm/java-8-oracle\n 在linux安装 两种方式：docker安装，和包安装\n以下介绍包安装方式，nexus3没有硬编码目录，在任何目录下都可以运行，只需要解压tar包\n解压命令：\ntar -zxvf 包名  Nexus3开机自启动： 两种方式：主要区别是在linux系统的区别CentOS6,7\n6采用init.d,chkconfig的方式\nsudo ln -s $ NEXUS_HOME / bin / nexus /etc/init.d/nexus cd /etc/init.d sudo chkconfig --add nexus sudo chkconfig --levels 345 nexus on sudo service nexus start  第二种方式CentOS7，以服务 的方式运行\n编写nexus.service文件 ：\nvi /etc/systemd/system/nexus.service [Unit] Description=nexus service After=network.target [Service] Type=forking LimitNOFILE=65536 ExecStart=/opt/nexus/bin/nexus start ExecStop=/opt/nexus/bin/nexus stop User=nexus Restart=on-abort [Install] WantedBy=multi-user.target ：wq sudo systemctl daemon-reload sudo systemctl enable nexus.service sudo systemctl start nexus.service   之后就可以启动了\ntail -f /自定义目录/sonatype-work/nexus3/log/nexus.log\n可以看到启动成功的日志\n其他默认就好；\n此时，应该都已经设置好了：访问web界面：Ip：8081。 默认端口是8081.可以自定义修改\n它的用户名是 admin ，密码是 admin123。您可以使用用户界面右上角的按钮登录。\n 如果你只是安装自己玩玩，到这里就结束了。如果是实际使用，那就需要看下面的部分\n在服务器上，程序有两个目录\n安装目录。数据目录。\n安装目录\n $ ls -1 nexus-\u0026lt;version\u0026gt; LICENSE.txt NOTICE.txt bin deploy etc lib public system   LICENSE.txt 和 NOTICE.txt\n这些文件包含有关许可和版权声明的法律详细信息\nbin\n此目录包含 nexus 启动脚本本身以及与启动相关的配置文件\netc\n该目录包含配置文件\nlib\n该目录包含与Apache Karaf相关的二进制库\npublic\n该目录包含应用程序的公共资源\nsystem\n该目录包含构成应用程序的所有组件和插件\n数据目录 默认情况下找到的数据目录 ../sonatype-work/nexus3包含子目录，这些子目录包含存储库管理器提供的所有组件，存储库，配置和其他数据。子目录列为：\nblobs/\n这是blob存储的默认位置。如果在创建新的Blob存储库时提供了完全限定的路径，则它可能不会在此目录中结束。\ncache/\n此目录包含有关当前缓存的Karaf捆绑包的信息\ndb/\n此目录包含OrientDB数据库，它是存储库管理器元数据的主存储\nelasticsearch/\n此目录包含当前配置的Elasticsearch状态\netc/\n此目录包含存储库管理器的主运行时配置和自定义。配置运行时环境中进一步说明了这些文件 。\nhealth-check/\n此目录包含来自存储库运行状况检查功能的缓存报告\nkeystores/\n它包含用于标识存储库管理器的自动生成的密钥\nlog/\n此目录包含几个日志文件，用于捕获有关正在运行的存储库管理器的各个方面的信 在 nexus.log 和 request.log 文件旋转，所以每天这个目录也包含这些文件的归档副本。要回收磁盘空间，可以从logs目录中删除旧的日志文件。在此目录中找到的日志文件包括： nexus.log - 主存储库管理器应用程序日志。日志消息包含标准日志输出字段，包括日期/时间，日志级别，关联的线程，类和消息。\nrequest.log - 用于将http访问请求记录到正在运行的存储库管理器。日志消息包含客户端主机，用户和HTTP请求属性等信息，包括状态代码，字节和用户代理标头。\njvm.log - 包含JVM标准输出，stderr和线程转储消息\nkaraf.log - 这是Apache Karaf容器日志文件，其中包含特定于存储库管理器启动的消息\n该 log 目录还包含一个tasks 子目录，该 子目录包含运行的每个任务的单独的，唯一命名的（按日期，时间和任务名称）日志输出文件。有关 这些文件的命名策略和内容的更多详细信息，请参阅 任务日志记录。\ntmp/ -该目录用于临时存储\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/pm20/",
	"title": "pm2常用 命令",
	"tags": [],
	"description": "",
	"content": " 1. 启动 pm2 start app.js pm2 start app.js --name my-api #my-api为PM2进程名称 pm2 start app.js -i 0 #根据CPU核数启动进程个数 pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload  2. 查看进程 pm2 list pm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id  3. 监控 pm2 monit  4. 停止 pm2 stop all #停止PM2列表中所有的进程 pm2 stop 0 #停止PM2列表中进程为0的进程  5. 重载 pm2 reload all #重载PM2列表中所有的进程 pm2 reload 0 #重载PM2列表中进程为0的进程  6. 重启 pm2 restart all #重启PM2列表中所有的进程 pm2 restart 0 #重启PM2列表中进程为0的进程  7. 删除PM2进程 pm2 delete 0 #删除PM2列表中进程为0的进程 pm2 delete all #删除PM2列表中所有的进程  8. 日志操作 pm2 logs [--raw] #Display all processes logs in streaming pm2 flush #Empty all log file pm2 reloadLogs #Reload all logs  9. 升级PM2 npm install pm2@lastest -g #安装最新的PM2版本 pm2 updatePM2 #升级pm2  10. 更多命令参数请查看帮助 pm2 --help  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/verdaccio/",
	"title": "内网搭建npm私服",
	"tags": [],
	"description": "",
	"content": " 1、下载verdaccio 从github下载verdaccio，得到下载的包，之后拷贝到内网环境，在verdaccio文件目录下\nnpm install -g verdaccio --unsafe-perm  2、配置 C:\\Users\\用户名\\AppData\\Roaming\\verdaccio\\config.yaml 在末尾加listen: 0.0.0.0:4873，不配置的话只能本机访问。\n内网环境下将uplinks部分去掉或注释。\n3、启动 verdaccio  4、托管启动 安装pm2 从github下载pm2，得到下载的包，之后拷贝到内网环境，在pm2文件目录下\nnpm install npm link  使用pm2启动 pm2 start verdaccio  Pm2常用命令\n5、访问 访问localhost:4873,可以看到登录页面\n6、注册及登录 npm adduser –registry http://localhost:4873  如果已经配置了地址，则不需要\u0026ndash;registry部分，按照提示输入username，psd。\n7、公共组件打包 将写好的组件通过 npm run build打包，生成dist文件夹。 将路径切换到项目的dist的文件夹下，执行命令npm init，生成package.json,里面包含了版本，组件名等信息： 之后在npm上发布\nnpm publish --registry http://localhost:4873  之后在需要使用的项目下载\nnpm install table-two --registry=http://localhost:4873  "
},
{
	"uri": "https://peterhan-enjoy.github.com/web/",
	"title": "前端",
	"tags": [],
	"description": "",
	"content": " javaWeb前端相关技术 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/decryptionziputil/",
	"title": "加密解压缩工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lingala.zip4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zip4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import net.lingala.zip4j.core.ZipFile; import net.lingala.zip4j.exception.ZipException; import net.lingala.zip4j.model.ZipParameters; import net.lingala.zip4j.util.Zip4jConstants; import java.io.File; /** * 压缩指定文件或目录为ZIP格式压缩文件 * 支持中文(修改源码后) * 支持密码(仅支持256bit的AES加密解密) * 依赖bcprov项目(bcprov-jdk16-140.jar) * * @author zyh */ public class DecryptionZipUtil { private static void zipFile() throws ZipException { // 生成的压缩文件 ZipFile zipFile = new ZipFile(\u0026quot;D:\\\\test.zip\u0026quot;); ZipParameters parameters = new ZipParameters(); // 压缩方式 parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE); // 压缩级别 parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); parameters.setEncryptFiles( true ); parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_AES); parameters.setAesKeyStrength(Zip4jConstants.AES_STRENGTH_256); parameters.setPassword(\u0026quot;111\u0026quot;); // 要打包的文件夹 File currentFile = new File(\u0026quot;D:\\\\test\u0026quot;); File[] fs = currentFile.listFiles(); // 遍历test文件夹下所有的文件、文件夹 for (File f : fs) { if (f.isDirectory()) { zipFile.addFolder(f.getPath(), parameters); } else { zipFile.addFile(f, parameters); } } } private static void unzip() { try { ZipFile zipFile = new ZipFile(\u0026quot;D:\\\\test.zip\u0026quot;); // 如果解压需要密码 if(zipFile.isEncrypted()) { zipFile.setPassword(\u0026quot;111\u0026quot;); } zipFile.extractAll(\u0026quot;D:\\\\test\u0026quot;); } catch (ZipException e) { e.printStackTrace(); } } /** * 测试 * @param args */ public static void main(String[] args) { try { DecryptionZipUtil.unzip(); }catch (Exception e){ e.printStackTrace(); } } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/singletonpattern/",
	"title": "单例模式",
	"tags": [],
	"description": "",
	"content": " 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n注意：\n1、单例类只能有一个实例。\n2、单例类必须自己创建自己的唯一实例。\n3、单例类必须给所有其他对象提供这一实例。\n介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n主要解决：一个全局使用的类频繁地创建与销毁。\n何时使用：当您想控制实例数目，节省系统资源的时候。\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n关键代码：构造函数是私有的。\n应用实例：\n1、一个班级只有一个班主任。\n2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n优点：\n1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n2、避免对资源的多重占用（比如写文件操作）。\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n使用场景：\n1、要求生产唯一序列号。\n2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n实现 我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。\nSingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1 public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\u0026quot;Hello World!\u0026quot;); } }  步骤 2 创建 Observer 类。\npublic class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }  步骤 3 Hello World!  单例模式的几种实现方式 1、懒汉式，线程不安全 是否 Lazy 初始化：是\n是否多线程安全：否\n实现难度：易\n描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。\n2、懒汉式，线程安全 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：易\n描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  3、饿汉式 是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\n实例\npublic class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }  4、双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本：JDK1.5 起\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：较复杂\n描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。\n实例\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }  5、登记式/静态内部类 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：一般\n描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。\n实例\npublic class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }  6、枚举 JDK 版本：JDK1.5 起\n是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。\n实例\npublic enum Singleton { INSTANCE; public void whateverMethod() { } }  经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/commandpattern/",
	"title": "命令模式",
	"tags": [],
	"description": "",
	"content": " 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n介绍 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n何时使用：在某些场合，比如要对行为进行\u0026rdquo;记录、撤销/重做、事务\u0026rdquo;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\u0026rdquo;行为请求者\u0026rdquo;与\u0026rdquo;行为实现者\u0026rdquo;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n缺点：使用命令模式可能会导致某些系统有过多的具体命令类。\n使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\n注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n实现 我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。\nBroker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。 步骤 1 创建一个接口：\npublic interface Order { void execute(); }  步骤 2 创建一个请求类。\npublic class Stock { private String name = \u0026quot;ABC\u0026quot;; private int quantity = 10; public void buy(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] bought\u0026quot;); } public void sell(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] sold\u0026quot;); } }  步骤 3 创建实现了 Order 接口的实体类。\npublic class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); } }  public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); } }  步骤 4 创建命令调用类。\nimport java.util.ArrayList; import java.util.List; public class Broker { private List\u0026lt;Order\u0026gt; orderList = new ArrayList\u0026lt;Order\u0026gt;(); public void takeOrder(Order order){ orderList.add(order); } public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); } }  步骤 5 使用 Broker 类来接受并执行命令。\npublic class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); } }  步骤 6 执行程序，输出结果：\nStock [ Name: ABC, Quantity: 10 ] bought Stock [ Name: ABC, Quantity: 10 ] sold  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/base64util/",
	"title": "图片base64转换工具类",
	"tags": [],
	"description": "",
	"content": " import java.io.ByteArrayOutputStream; public class Base64Util { private static byte[] base64DecodeChars = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1 }; private static char[] codec_table = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' }; public static byte[] decode(String str) { byte[] data = str.getBytes(); int len = data.length; ByteArrayOutputStream buf = new ByteArrayOutputStream(len); int i = 0; int b1, b2, b3, b4; while (i \u0026lt; len) { do { b1 = base64DecodeChars[data[i++]]; } while (i \u0026lt; len \u0026amp;\u0026amp; b1 == -1); if (b1 == -1) { break; } do { b2 = base64DecodeChars[data[i++]]; } while (i \u0026lt; len \u0026amp;\u0026amp; b2 == -1); if (b2 == -1) { break; } buf.write((int) ((b1 \u0026lt;\u0026lt; 2) | ((b2 \u0026amp; 0x30) \u0026gt;\u0026gt;\u0026gt; 4))); do { b3 = data[i++]; if (b3 == 61) { return buf.toByteArray(); } b3 = base64DecodeChars[b3]; } while (i \u0026lt; len \u0026amp;\u0026amp; b3 == -1); if (b3 == -1) { break; } buf.write((int) (((b2 \u0026amp; 0x0f) \u0026lt;\u0026lt; 4) | ((b3 \u0026amp; 0x3c) \u0026gt;\u0026gt;\u0026gt; 2))); do { b4 = data[i++]; if (b4 == 61) { return buf.toByteArray(); } b4 = base64DecodeChars[b4]; } while (i \u0026lt; len \u0026amp;\u0026amp; b4 == -1); if (b4 == -1) { break; } buf.write((int) (((b3 \u0026amp; 0x03) \u0026lt;\u0026lt; 6) | b4)); } return buf.toByteArray(); } public static String encode(byte[] a) { int totalBits = a.length * 8; int nn = totalBits % 6; int curPos = 0; StringBuffer toReturn = new StringBuffer(); while(curPos \u0026lt; totalBits) { int bytePos = curPos / 8; switch (curPos % 8) { case 0: toReturn.append(codec_table[(a[bytePos] \u0026amp; 0xfc) \u0026gt;\u0026gt; 2]); break; case 2: toReturn.append(codec_table[(a[bytePos] \u0026amp; 0x3f)]); break; case 4: if (bytePos == a.length - 1) { toReturn.append(codec_table[((a[bytePos] \u0026amp; 0x0f) \u0026lt;\u0026lt; 2) \u0026amp; 0x3f]); } else { int pos = (((a[bytePos] \u0026amp; 0x0f) \u0026lt;\u0026lt; 2) | ((a[bytePos + 1] \u0026amp; 0xc0) \u0026gt;\u0026gt; 6)) \u0026amp; 0x3f; toReturn.append(codec_table[pos]); } break; case 6: if (bytePos == a.length - 1) { toReturn.append(codec_table[((a[bytePos] \u0026amp; 0x03) \u0026lt;\u0026lt; 4) \u0026amp; 0x3f]); } else { int pos = (((a[bytePos] \u0026amp; 0x03) \u0026lt;\u0026lt; 4) | ((a[bytePos + 1] \u0026amp; 0xf0) \u0026gt;\u0026gt; 4)) \u0026amp; 0x3f; toReturn.append(codec_table[pos]); } break; default: break; } curPos += 6; } if(nn == 2) { toReturn.append(\u0026quot;==\u0026quot;); }else if(nn == 4) { toReturn.append(\u0026quot;=\u0026quot;); } return toReturn.toString(); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/factorypattern/",
	"title": "工厂模式",
	"tags": [],
	"description": "",
	"content": " 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n介绍 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n主要解决：主要解决接口选择的问题。\n何时使用：我们明确地计划不同条件下创建不同实例时。\n如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。\n关键代码：创建过程在其子类执行。\n应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。\n优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\n缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\u0026rdquo;POP3\u0026rdquo;、\u0026rdquo;IMAP\u0026rdquo;、\u0026rdquo;HTTP\u0026rdquo;，可以把这三个作为产品类，共同实现一个接口。\n注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n实现 简单工厂模式 一个栗子： 我喜欢吃面条，抽象一个面条基类，(接口也可以)，这是产品的抽象类。\npublic abstract class INoodles { /** * 描述每种面条啥样的 */ public abstract void desc(); }  先来一份兰州拉面（具体的产品类）：\npublic class LzNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;兰州拉面 上海的好贵 家里才5 6块钱一碗\u0026quot;); } }  程序员加班必备也要吃泡面（具体的产品类）：\npublic class PaoNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;泡面好吃 可不要贪杯\u0026quot;); } }  还有我最爱吃的家乡的干扣面（具体的产品类）：\npublic class GankouNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;还是家里的干扣面好吃 6块一碗\u0026quot;); } }  准备工作做完了，我们来到一家“简单面馆”（简单工厂类），菜单如下：\npublic class SimpleNoodlesFactory { public static final int TYPE_LZ = 1;//兰州拉面 public static final int TYPE_PM = 2;//泡面 public static final int TYPE_GK = 3;//干扣面 public static INoodles createNoodles(int type) { switch (type) { case TYPE_LZ: return new LzNoodles(); case TYPE_PM: return new PaoNoodles(); case TYPE_GK: default: return new GankouNoodles(); } } }  简单面馆就提供三种面条（产品），你说你要啥，他就给你啥。这里我点了一份干扣面:\n/** * 简单工厂模式 */ INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK); noodles.desc();  输出：\n还是家里的干扣面好吃 6块一碗  特点\n1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。\n2 create()方法通常是静态的，所以也称之为静态工厂。\n缺点 1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）\n2 不同的产品需要不同额外参数的时候 不支持。\n二、工厂方法模式\n1.模式描述 提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。\n2.模式作用 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。\n可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。 等等。 另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。\n3.适用场景 消费者不关心它所要创建对象的类(产品类)的时候。\n消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。\n等等。\n例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。\n####### 4.模式要素 提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。 提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。 由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。\n5.模式实例代码 工厂：\npackage com.demoFound.factoryMethod.factory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_工厂接口 * * @author popkidorc * */ public interface IMyMessageFactory { public IMyMessage createMessage(String messageType); }  package com.demoFound.factoryMethod.factory; import java.util.HashMap; import java.util.Map; import com.demoFound.factoryMethod.message.IMyMessage; import com.demoFound.factoryMethod.message.MyMessageEmail; import com.demoFound.factoryMethod.message.MyMessageOaTodo; import com.demoFound.factoryMethod.message.MyMessageSms; /** * 工厂方法模式_工厂实现 * * @author popkidorc * */ public class MyMessageFactory implements IMyMessageFactory { @Override public IMyMessage createMessage(String messageType) { // 这里的方式是：消费者知道自己想要什么产品；若生产何种产品完全由工厂决定，则这里不应该传入控制生产的参数。 IMyMessage myMessage; Map\u0026lt;String, Object\u0026gt; messageParam = new HashMap\u0026lt;String, Object\u0026gt;(); // 根据某些条件去选择究竟创建哪一个具体的实现对象，条件可以传入的，也可以从其它途径获取。 // sms if (\u0026quot;SMS\u0026quot;.equals(messageType)) { myMessage = new MyMessageSms(); messageParam.put(\u0026quot;PHONENUM\u0026quot;, \u0026quot;123456789\u0026quot;); } else // OA待办 if (\u0026quot;OA\u0026quot;.equals(messageType)) { myMessage = new MyMessageOaTodo(); messageParam.put(\u0026quot;OAUSERNAME\u0026quot;, \u0026quot;testUser\u0026quot;); } else // email if (\u0026quot;EMAIL\u0026quot;.equals(messageType)) { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } else // 默认生产email这个产品 { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } myMessage.setMessageParam(messageParam); return myMessage; } }  产品：\npackage com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_产品接口 * * @author popkidorc * */ public interface IMyMessage { public Map\u0026lt;String, Object\u0026gt; getMessageParam(); public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam); public void sendMesage() throws Exception;// 发送通知/消息 }  package com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_虚拟产品类 * * @author popkidorc * */ public abstract class MyAbstractMessage implements IMyMessage { private Map\u0026lt;String, Object\u0026gt; messageParam;// 这里可以理解为生产产品所需要的原材料库。最好是个自定义的对象，这里为了不引起误解使用Map。 @Override public Map\u0026lt;String, Object\u0026gt; getMessageParam() { return messageParam; } @Override public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam) { this.messageParam = messageParam; } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_email产品 * * @author popkidorc * */ public class MyMessageEmail extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;EMAIL\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;EMAIL\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入EMAIL参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外邮件内容，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是邮件，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;EMAIL\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_oa待办产品 * * @author popkidorc * */ public class MyMessageOaTodo extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;))) { throw new Exception(\u0026quot;发送OA待办,需要传入OAUSERNAME参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 这里的参数需求就比较多了不一一处理了 System.out .println(\u0026quot;我是OA待办，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_sms产品 * * @author popkidorc * */ public class MyMessageSms extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;PHONENUM\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;PHONENUM\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入PHONENUM参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外短信信息，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是短信，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;PHONENUM\u0026quot;)); } }  消费者：\npackage com.demoFound.factoryMethod; import com.demoFound.factoryMethod.factory.IMyMessageFactory; import com.demoFound.factoryMethod.factory.MyMessageFactory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_消费者类 * * @author popkidorc * */ public class MyFactoryMethodMain { public static void main(String[] args) { IMyMessageFactory myMessageFactory = new MyMessageFactory(); IMyMessage myMessage; // 对于这个消费者来说，不用知道如何生产message这个产品，耦合度降低 try { // 先来一个短信通知 myMessage = myMessageFactory.createMessage(\u0026quot;SMS\u0026quot;); myMessage.sendMesage(); // 来一个oa待办 myMessage = myMessageFactory.createMessage(\u0026quot;OA\u0026quot;); myMessage.sendMesage(); // 来一个邮件通知 myMessage = myMessageFactory.createMessage(\u0026quot;EMAIL\u0026quot;); myMessage.sendMesage(); } catch (Exception e) { e.printStackTrace(); } } }  三、抽象工厂模式\n定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n类型：创建类模式\n类图：\n抽象工厂模式与工厂方法模式的区别\n抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。\n在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。\n明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。\n抽象工厂模式代码\ninterface IProduct1 { public void show(); } interface IProduct2 { public void show(); } class Product1 implements IProduct1 { public void show() { System.out.println(\u0026quot;这是1型产品\u0026quot;); } } class Product2 implements IProduct2 { public void show() { System.out.println(\u0026quot;这是2型产品\u0026quot;); } } interface IFactory { public IProduct1 createProduct1(); public IProduct2 createProduct2(); } class Factory implements IFactory{ public IProduct1 createProduct1() { return new Product1(); } public IProduct2 createProduct2() { return new Product2(); } } public class Client { public static void main(String[] args){ IFactory factory = new Factory(); factory.createProduct1().show(); factory.createProduct2().show(); } }  抽象工厂模式的优点\n抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。\n抽象工厂模式的缺点 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。\n适用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。\n总结 无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/strategypattern/",
	"title": "策略模式",
	"tags": [],
	"description": "",
	"content": " 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if\u0026hellip;else 所带来的复杂和难以维护。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。\n应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。\n优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。\n使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n实现 我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1 创建一个接口。Strategy.java\npublic interface Strategy { public int doOperation(int num1, int num2); }  步骤 2 创建实现接口的实体类。OperationAdd.java\npublic class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } }  步骤 3 创建 Context 类。Context.java\npublic class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } }  步骤 4 使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo\npublic class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\u0026quot;10 + 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(\u0026quot;10 - 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\u0026quot;10 * 5 = \u0026quot; + context.executeStrategy(10, 5)); } }  步骤 5 执行程序，输出结果：\n10 + 5 = 15 10 - 5 = 5 10 * 5 = 50  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/decoratorpattern/",
	"title": "装饰器模式",
	"tags": [],
	"description": "",
	"content": " 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。\n介绍 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n何时使用：在不想增加很多子类的情况下扩展类。\n如何解决：将具体功能职责划分，同时继承装饰者模式。\n关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n应用实例： 1、孙悟空有 72 变，当他变成\u0026rdquo;庙宇\u0026rdquo;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n注意事项：可代替继承。\n实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类。\nDecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。 步骤 1 创建一个接口：\npublic interface Shape { void draw(); }  步骤 2 创建实现接口的实体类。\npublic class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Rectangle\u0026quot;); } }  public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Circle\u0026quot;); } }  步骤 3 创建实现了 Shape 接口的抽象装饰类。\npublic abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } }  步骤 4 创建扩展了 ShapeDecorator 类的实体装饰类。\npublic class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(\u0026quot;Border Color: Red\u0026quot;); } }  步骤 5 使用 RedShapeDecorator 来装饰 Shape 对象。\npublic class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\u0026quot;Circle with normal border\u0026quot;); circle.draw(); System.out.println(\u0026quot;\\nCircle of red border\u0026quot;); redCircle.draw(); System.out.println(\u0026quot;\\nRectangle of red border\u0026quot;); redRectangle.draw(); } }  步骤 6 执行程序，输出结果：\nCircle with normal border Shape: Circle Circle of red border Shape: Circle Border Color: Red Rectangle of red border Shape: Rectangle Border Color: Red  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/observerpattern/",
	"title": "观察者模式",
	"tags": [],
	"description": "",
	"content": " 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。\n介绍 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n关键代码：在抽象类里有一个 ArrayList 存放观察者们。\n应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n使用场景：\n一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n实现 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。\nObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 步骤 1 创建 Subject 类。\nimport java.util.ArrayList; import java.util.List; public class Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } }  步骤 2 创建 Observer 类。\npublic abstract class Observer { protected Subject subject; public abstract void update(); }  步骤 3 创建实体观察者类。\npublic class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Binary String: \u0026quot; + Integer.toBinaryString( subject.getState() ) ); } }  public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Octal String: \u0026quot; + Integer.toOctalString( subject.getState() ) ); } }  步骤 4 使用 Subject 和实体观察者对象。\npublic class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\u0026quot;First state change: 15\u0026quot;); subject.setState(15); System.out.println(\u0026quot;Second state change: 10\u0026quot;); subject.setState(10); } }  步骤 5 执行程序，输出结果：\nFirst state change: 15 Hex String: F Octal String: 17 Binary String: 1111 Second state change: 10 Hex String: A Octal String: 12 Binary String: 1010  java内置观察者 实现观察者模式 实现观察者模式非常简单， [1]创建被观察者类，它继承自java.util.Observable类； [2]创建观察者类，它实现java.util.Observer接口；\n对于被观察者类： 添加它的观察者： void addObserver(Observer o) addObserver()方法把观察者对象添加到观察者对象列表中\n当被观察者中的事件发生变化时，执行 setChanged(); notifyObservers(); setChange()方法用来设置一个内部标志位注明数据发生了变化；notifyObservers()方法会去调用观察者对象列表中所有的Observer的update()方法，通知它们数据发生了变化。 只有在setChange()被调用后，notifyObservers()才会去调用update()。\n对于观察者类，实现Observer接口的唯一方法update void update(Observable o, Object arg)\n形参Object arg，对应一个由notifyObservers(Object arg);传递来的参数，当执行的是notifyObservers();时，arg为null。\n被观察者 package com.test.observer; import java.util.Observable; public class ServerManager extends Observable { private int data = 0; public int getData(){ return data; } public void setData(int i){ if(this.data != i){ this.data = i;setChanged();} notifyObservers(); //只有在setChange()被调用后，notifyObservers()才会去调用update()，否则什么都不干。 } } } }  观察者1 import java.util.Observable; import java.util.Observer; public class AObserver implements Observer { public AObserver(ServerManager sm) { super(); // TODO Auto-generated constructor stub sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable arg0, Object arg1) { System.out.println(\u0026quot;AObserver receive:Data has changed to \u0026quot;+((ServerManager) arg0).getData()); } }  观察者2 import java.util.Observable; import java.util.Observer; public class BObserver implements Observer { public BObserver(ServerManager sm) { super(); sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable o, Object arg) { // TODO Auto-generated method stub System.out.println(\u0026quot;BObserver receive:Data has changed to \u0026quot;+((ServerManager) o).getData()); } }  测试 public class TestDemo { public static void main(String[] args) { // TODO Auto-generated method stub ServerManager sm = new ServerManager(); AObserver a = new AObserver(sm); BObserver b = new BObserver(sm); sm.setData(5); sm.deleteObserver(a);　//注销观察者，以后被观察者有数据变化就不再通知这个已注销的观察者 sm.setData(10); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/zipfileutil/",
	"title": "解压缩工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.axet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-unrar\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.0-8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; import de.innosystec.unrar.NativeStorage; import org.apache.tools.ant.Project; import org.apache.tools.ant.taskdefs.Expand; import de.innosystec.unrar.Archive; import de.innosystec.unrar.rarfile.FileHeader; public class ZipFileUtil { private static final int BUFFER_SIZE = 2 * 1024; /** * 解压zip格式压缩包 * 对应的是ant.jar */ private static void unzip(String sourceZip,String destDir) throws Exception{ try{ Project p = new Project(); Expand e = new Expand(); e.setProject(p); e.setSrc(new File(sourceZip)); e.setOverwrite(false); e.setDest(new File(destDir)); /* ant下的zip工具默认压缩编码为UTF-8编码， 而winRAR软件压缩是用的windows默认的GBK或者GB2312编码 所以解压缩时要制定编码格式 */ e.setEncoding(\u0026quot;gbk\u0026quot;); e.execute(); }catch(Exception e){ throw e; } } /** * 解压rar格式压缩包。 * 对应的是java-unrar-0.3.jar，但是java-unrar-0.3.jar又会用到commons-logging-1.1.1.jar */ private static void unrar(String sourceRar,String destDir) throws Exception{ Archive a = null; FileOutputStream fos = null; try{ NativeStorage nativeStorage = new NativeStorage(new File(sourceRar)); a = new Archive(nativeStorage); FileHeader fh = a.nextFileHeader(); while(fh!=null){ if(!fh.isDirectory()){ //1 根据不同的操作系统拿到相应的 destDirName 和 destFileName String compressFileName = fh.getFileNameString().trim(); String destFileName = \u0026quot;\u0026quot;; String destDirName = \u0026quot;\u0026quot;; //非windows系统 if(File.separator.equals(\u0026quot;/\u0026quot;)){ destFileName = destDir + compressFileName.replaceAll(\u0026quot;\\\\\\\\\u0026quot;, \u0026quot;/\u0026quot;); destDirName = destFileName.substring(0, destFileName.lastIndexOf(\u0026quot;/\u0026quot;)); //windows系统 }else{ destFileName = destDir + compressFileName.replaceAll(\u0026quot;/\u0026quot;, \u0026quot;\\\\\\\\\u0026quot;); destDirName = destFileName.substring(0, destFileName.lastIndexOf(\u0026quot;\\\\\u0026quot;)); } //2创建文件夹 File dir = new File(destDirName); if(!dir.exists()||!dir.isDirectory()){ dir.mkdirs(); } //3解压缩文件 fos = new FileOutputStream(new File(destFileName)); a.extractFile(fh, fos); fos.close(); fos = null; } fh = a.nextFileHeader(); } a.close(); a = null; }catch(Exception e){ throw e; }finally{ if(fos!=null){ try{fos.close();fos=null;}catch(Exception e){e.printStackTrace();} } if(a!=null){ try{a.close();a=null;}catch(Exception e){e.printStackTrace();} } } } /** * 解压缩 */ public static void deCompress(String sourceFile,String destDir) throws Exception{ //保证文件夹路径最后是\u0026quot;/\u0026quot;或者\u0026quot;\\\u0026quot; char lastChar = destDir.charAt(destDir.length()-1); if(lastChar!='/'\u0026amp;\u0026amp;lastChar!='\\\\'){ destDir += File.separator; } //根据类型，进行相应的解压缩 String type = sourceFile.substring(sourceFile.lastIndexOf(\u0026quot;.\u0026quot;)+1); if(type.equals(\u0026quot;zip\u0026quot;)){ ZipFileUtil.unzip(sourceFile, destDir); }else if(type.equals(\u0026quot;rar\u0026quot;)){ ZipFileUtil.unrar(sourceFile, destDir); }else{ throw new Exception(\u0026quot;只支持zip和rar格式的压缩包！\u0026quot;); } } /** * 压缩成ZIP 方法1 * @param srcDir 压缩文件夹路径 * @param out 压缩文件输出流 * @param KeepDirStructure 是否保留原来的目录结构,true:保留目录结构; * false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败) * @throws RuntimeException 压缩失败会抛出运行时异常 */ public static void toZip(String srcDir, OutputStream out, boolean KeepDirStructure) throws RuntimeException{ long start = System.currentTimeMillis(); ZipOutputStream zos = null ; try { zos = new ZipOutputStream(out); File sourceFile = new File(srcDir); compress(sourceFile,zos,sourceFile.getName(),KeepDirStructure); long end = System.currentTimeMillis(); System.out.println(\u0026quot;压缩完成，耗时：\u0026quot; + (end - start) +\u0026quot; ms\u0026quot;); } catch (Exception e) { throw new RuntimeException(\u0026quot;zip error from ZipUtils\u0026quot;,e); }finally{ if(zos != null){ try { zos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 压缩成ZIP 方法2 * @param srcFiles 需要压缩的文件列表 * @param out 压缩文件输出流 * @throws RuntimeException 压缩失败会抛出运行时异常 */ public static void toZip(List\u0026lt;File\u0026gt; srcFiles , OutputStream out)throws RuntimeException { long start = System.currentTimeMillis(); ZipOutputStream zos = null ; try { zos = new ZipOutputStream(out); for (File srcFile : srcFiles) { byte[] buf = new byte[BUFFER_SIZE]; zos.putNextEntry(new ZipEntry(srcFile.getName())); int len; FileInputStream in = new FileInputStream(srcFile); while ((len = in.read(buf)) != -1){ zos.write(buf, 0, len); } zos.closeEntry(); in.close(); } long end = System.currentTimeMillis(); System.out.println(\u0026quot;压缩完成，耗时：\u0026quot; + (end - start) +\u0026quot; ms\u0026quot;); } catch (Exception e) { throw new RuntimeException(\u0026quot;zip error from ZipUtils\u0026quot;,e); }finally{ if(zos != null){ try { zos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 递归压缩方法 * @param sourceFile 源文件 * @param zos zip输出流 * @param name 压缩后的名称 * @param KeepDirStructure 是否保留原来的目录结构,true:保留目录结构; * false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败) * @throws Exception */ private static void compress(File sourceFile, ZipOutputStream zos, String name, boolean KeepDirStructure) throws Exception{ byte[] buf = new byte[BUFFER_SIZE]; if(sourceFile.isFile()){ // 向zip输出流中添加一个zip实体，构造器中name为zip实体的文件的名字 zos.putNextEntry(new ZipEntry(name)); // copy文件到zip输出流中 int len; FileInputStream in = new FileInputStream(sourceFile); while ((len = in.read(buf)) != -1){ zos.write(buf, 0, len); } // Complete the entry zos.closeEntry(); in.close(); } else { File[] listFiles = sourceFile.listFiles(); if(listFiles == null || listFiles.length == 0){ // 需要保留原来的文件结构时,需要对空文件夹进行处理 if(KeepDirStructure){ // 空文件夹的处理 zos.putNextEntry(new ZipEntry(name + \u0026quot;/\u0026quot;)); // 没有文件，不需要文件的copy zos.closeEntry(); } }else { for (File file : listFiles) { // 判断是否需要保留原来的文件结构 if (KeepDirStructure) { // 注意：file.getName()前面需要带上父文件夹的名字加一斜杠, // 不然最后压缩包中就不能保留原来的文件结构,即：所有文件都跑到压缩包根目录下了 compress(file, zos, name + \u0026quot;/\u0026quot; + file.getName(),KeepDirStructure); } else { compress(file, zos, file.getName(),KeepDirStructure); } } } } } public static void main(String[] args) throws FileNotFoundException { /* try { ZipFileUtil.deCompress(\u0026quot;H:\\\\test\\\\1.rar\u0026quot;,\u0026quot;H:\\\\test\u0026quot;); } catch (Exception e) { e.printStackTrace(); }*/ File file = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); File file2 = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); File file3 = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); File file4 = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); List\u0026lt;File\u0026gt; files = new ArrayList\u0026lt;\u0026gt;(); files.add(file); files.add(file2); files.add(file3); files.add(file4); FileOutputStream fos = new FileOutputStream(new File(\u0026quot;D:\\\\PeterHan\\\\test.zip\u0026quot;);); toZip(files,fos); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/",
	"title": "设计模式",
	"tags": [],
	"description": "",
	"content": "设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n"
}]
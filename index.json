[
{
	"uri": "https://peterhan-enjoy.github.com/utils/markdown/",
	"title": "Markdown使用",
	"tags": [],
	"description": "",
	"content": " Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n一、标题 在想要设置为标题的文字前面加#来表示\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。\n示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题  效果如下： 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二、字体 加粗\n要加粗的文字左右分别用两个*号包起来\n斜体\n要倾斜的文字左右分别用一个*号包起来\n斜体加粗\n要倾斜和加粗的文字左右分别用三个*号包起来\n删除线\n要加删除线的文字左右分别用两个~~号包起来\n示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~  效果如下： 这是加粗的文字\n这是倾斜的文字`\n这是斜体加粗的文字\n这是加删除线的文字\n三、分割线 三个或者三个以上的 - 或者 * 都可以。\n示例：  --- ---- *** *****  效果如下： 可以看到，显示效果是一样的。\n四、图片 语法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加  示例： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419\u0026amp;fm=27\u0026amp;gp=0.jpg \u0026quot;区块链\u0026quot;)  效果如下： 五、超链接 语法： [超链接名](超链接地址 \u0026quot;超链接title\u0026quot;) title可加可不加  示例： [简书](http://jianshu.com) [百度](http://baidu.com)  效果如下： 简书\n百度\n注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。\n\u0026lt;a href=\u0026quot;超链接地址\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;超链接名\u0026lt;/a\u0026gt; 示例 \u0026lt;a href=\u0026quot;https://www.jianshu.com/u/1f5ac0cf6a8b\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;简书\u0026lt;/a\u0026gt;  六、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  有序列表 语法： 数字加点 1. 列表内容 2. 列表内容 3. 列表内容 注意：序号跟内容之间要有空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  七、表格 语法： 表头|表头|表头 :-:|:-:|:-: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略  示例： 姓名|技能|排行 :-:|:-:|:-: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟  效果如下：    姓名 技能 排行     刘备 哭 大哥   关羽 打 二哥   张飞 骂 三弟    八、代码 语法： 单行代码：代码之间分别用一个反引号包起来\n `代码内容`  代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n(```) 代码... 代码... 代码... (```)  注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n示例： 单行代码\n`create database hero;`  代码块\n(```) function fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun(); (```)  效果如下： 单行代码\ncreate database hero;\n代码块\nfunction fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun();  九、问题 行末两个空格 在Hugo编写Markdown文件时，如果行末没有两个空格是不会换行的。\n高亮 在Markdown中，==可以用作高亮，但是hugo则不行\n代码 在hugo中，三个反引号和代码放一行是不会渲染出代码结构的，除非换行。\n转义 \u0026gt; =\u0026gt; \u0026amp;gt;  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/",
	"title": "工具类",
	"tags": [],
	"description": "",
	"content": " 工具使用 "
},
{
	"uri": "https://peterhan-enjoy.github.com/",
	"title": "规范",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/docker/",
	"title": "docker 基本使用",
	"tags": [],
	"description": "",
	"content": " 一． docker常用命令 1. 从公网拉取一个镜像 docker pull images_name  2. 查看已有的docker镜像 [root@docker ~]# docker images  3. 查看帮助 docker command --help  4. 查看镜像列表 docker search nginx  5. 启动一个容器 基于hello-world镜像启动一个容器，如果本地没有镜像会从公网拉取过来，这次做为测试用\ndocker run hello-world  6. 导出镜像 docker save -o image_name.tar image_name  7. 删除镜像 docker rmi image_name  8. 启动一个容器 docker run --name=con_name images  \u0026ndash;name #设置容器名\n9. 基于创建好的容器自定义docker镜像 docker commit -m \u0026quot;con_name\u0026quot; con_id image_name  10. 创建一个容器的同时进入这个容器 docker run -it --name=con_name images  -it #在启动之后进入这个容器\n11. 创建一个容器，放入后台运行，把物理机80端口映射到容器的80端口 docker run -d -p 81:80 image_name  #-p 参数说明 -p hostPort:containerPort -p ip:hostPort:containerPort -p ip::containerPort -p hostPort:containerPort:udp\n12. 看容器的端口映射情况 docker port con_id  13. 查看正在运行的容器 docker ps  14. 查看所有的容器 docker ps -a  15. 动态查看容器日志 docker logs -f con_name  16. 进入容器 docker attach con_name  17. 退出容器 方法一\nexit  方法二 ctrl+p \u0026amp;\u0026amp; ctrl+q (一起按，注意顺序，退出后容器依然保持启动状态)\n18. 删除容器 docker rm con_name  强制删除需要加-f，不加-f不能删除正在运行中的容器，非常危险，最好不用\n19. 查看docker网络 [root@docker ~]# docker network ls  NETWORK ID NAME DRIVER SCOPE 3f91f2097286 bridge bridge local d7675dbd247c docker_gwbridge bridge local 5b36c7e947fd host host local ims6qkpikafu ingress overlay swarm 85ba10e7ef79 none null local\n20. 创建一个docker网络my-docker docker network create -d bridge \\  \u0026ndash;subnet=192.168.0.0/24 \u0026ndash;gateway=192.168.0.100 \u0026ndash;ip-range=192.168.0.0/24 my-docker\n21. 利用刚才创建的网络启动一个容器 docker run --network=my-docker --ip=192.168.0.5 -itd --name=con_name -h lb01 image_name  \u0026ndash;network #指定容器网络 \u0026ndash;ip #设定容器ip地址 -h #给容器设置主机名\n22. 查看容器pid 方法一：\ndocker top con_name  方法二：\ndocker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; con_name  23. 运行dockerfile并给dockerfile创建的镜像建立名字 docker build -t mysql:3.6.34 `pwd`  24. mariadb容器启动前需先设置密码方法 docker run -d -P -e MYSQL_ROOT_PASSWORD=password img_id  25. docker修改镜像名 docker tag imageid name:tag  26. 进入docker容器脚本 [root@docker ~]# cat nsenter.sh PID=`docker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; $1` nsenter -t $PID -u --mount -i -n -p  27. 创建一个网络 docker network create --driver bridge --subnet 172.22.16.0/  24 \u0026ndash;gateway 172.22.16.1 my_net2\n28. 将容器添加到my_net2网络 connect docker network connect my_net2 oldboy1  29. docker日志模块 使用filebeat收集日志 { \u0026ldquo;registry-mirrors\u0026rdquo;: [\u0026ldquo;https://56px195b.mirror.aliyuncs.com\u0026quot;], \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;consul://192.168.56.13:8500\u0026rdquo;, \u0026ldquo;cluster-advertise\u0026rdquo;: \u0026ldquo;192.168.56.11:2375\u0026rdquo;, \u0026ldquo;log-driver\u0026rdquo;: \u0026ldquo;fluentd\u0026rdquo;, \u0026ldquo;log-opts\u0026rdquo;: { \u0026ldquo;fluentd-address\u0026rdquo;:\u0026ldquo;192.168.56.13:24224\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;:\u0026ldquo;linux-node1.example.com\u0026rdquo; } }\n二． docker安装mysql 第一步，拉取MySQL镜像 $ sudo docker pull mysql  之后docker会自动拉取（下载）MySQL镜像。 拉取成功后我们查看一下：\n$ sudo docker images  第二步，创建并启动一个MySQL容器 输入以下命令：\n$ sudo docker run --name pwc-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql  • –name：给新创建的容器命名，此处命名为pwc-mysql • -e：配置信息，此处配置mysql的root用户的登陆密码 • -p：端口映射，此处映射主机3306端口到容器pwc-mysql的3306端口 • -d：成功启动容器后输出容器的完整ID，例如上图 73f8811f669ee\u0026hellip; • 最后一个mysql指的是mysql镜像名字 到这里我们查看容器运行状态：\n$ sudo docker ps  上图可以看到容器的简写ID，容器的源镜像，创建时间，状态，端口映射信息，容器名字等。\n第三步，修改mysql登录权限 docker exec -it xgmysql /bin/bash  进入mysql命令 通过mysql -uroot -p进入mysql的命令行模式 修改mysql登录权限\nALTER USER 'root'@'localhost' IDENTIFIED BY 'password'  PASSWORD EXPIRE NEVER;这里的password是你正在使用的密码\nALTER USER 'root'@'localhost' IDENTIFIED WITH  mysql_native_password BY \u0026lsquo;password\u0026rsquo;;#更新一下用户的密码这里的password为你修改的新密码。\nFLUSH PRIVILEGES;  刷新权限，使自己的修改生效。\nalter user 'root'@'%' identified by 'password' password expire never; alter user 'root'@'%' identified with mysql_native_password by 'why';//why是自己新修改的密码。 flush privileges;再次刷新一下权限配置。  三． redis安装（6379） docker pull redis docker run -d --name myredis -p 6379:6379 redis --requirepass \u0026quot;mypassword\u0026quot; 加密码  四． RabbitMq docker pull rabbitmq: 3-management  默认端口 5672\u0026frasl;15672 默认密码 guest/guest\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/gitlab/",
	"title": "gitlab 离线安装",
	"tags": [],
	"description": "",
	"content": " 1. 配置本地yum源 需要准备CentOs-Everything的iso作为本地yum源。一下以/root/CentOs-7-x86_64-DVD-1708.iso为例。\n2. 挂载镜像 mount -o loop /root/CentOs-7-x86_64-DVD-1708.iso /mnt/yum-iso  如果文件夹不存在可以提前mkdir\n3. 启动httpd服务 systemctl start httpd.service  4. 检查httpd服务状态 systemctl status httpd.service  如果状态正常，通过“http://服务器IP:80/”应该可以访问到http的欢迎页，如果开启防火墙，要开放80端口。\n5. 添加软链接 ln -s /mnt/yum-ios/ /var/www/html/CentOS-7-x86_64  如果顺利，通过“http://服务器IP:80/CentOS-7-x86_64”可以访问到iso中的文件。\n6. 准备配置本地yum源 cd /etc/yum.repos.d  7. 备份其他 repo:tar zcvf repo-bk.tar.gz CentOS-*  8. 移除其他 repo:rm -rf ./CentOS-*  9. 配置本地 repo:vi CentOS-Media.repo  内容如下\nname=CentOS-$releasever - Media baseurl=file:///yum/yum-iso/ gpgcheck=0 enable=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7  10. 制作cashe yum clear all yum makecache  11. 上传gitlab-ee文件 12. 跳转到gitlab-ee文件夹位置 13.安装 yum localinstall ./gitlab-ee-11.0.rpm  一路y知道成功\n14. 配置 主要修改各端口配置，避免端口占用 其中externam_url \u0026ldquo;服务器ip:端口\u0026rdquo; 为主界面ip及端口\n15. 更新配置 gitlab-ctl reconfigure  16. 启动git gitlab-car restart  如果出现502，检查端口号是否占用，然后调用步骤15,16重新访问。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/hugo/",
	"title": "hugo 搭建个人博客",
	"tags": [],
	"description": "",
	"content": " 1.准备工作 1.1 msysGit客户端 在Windows下默认是没有预装Git的，如果你是Mac和Linux的用户则没有这个烦恼，因此我们首先需要在Windows系统下安装一个Git软件，笔者使用的是msysGit，截止发文最新的版本是2.6.3，官网Download会自动识别系统（32位和64位）下载，之后一个个步骤按照向导安装就行，上面英文写的很清楚，基本可以按照默认的来，但是到了Ajusting your PATH environment（即设置环境变量）这一步时，建议还是勾选第二项Run Git from Windows Command Prompt，这样在Windows命令行中就可以全局使用Git相关命令。\n1.2 注册Github 点击Github官网进入Github首页，这样你能够进行注册，输入用户名、Email地址、密码即可进行注册，我们选择不需要花钱的Free类型用户，点击Finish sign up，这样即可完成注册，此时在页面顶部Bootcamp系统会提示你接下来可以做哪些事情，而我们首先需要做的就是Create Repositories，我们可以点击这一项进去看看教程，当然也可以根据我下面的提示直接开始： 1. 点击右侧New repository（新建仓库），此时系统会提示你验证邮箱，你需要去刚刚注册用的邮箱验证地址； 2. 验证完毕即可重新New reository，用户名一定要用：你的注册用户名.github.io，其他无需修改，然后点击Create repository即可; 3. 下面自动进入一个快速设置页面，告诉我们如何在仓库内添加东西，这就需要在Windows本地设置了。\n1.3 Windows本地配置Git 本文开篇就说了Windows下的Git程序，但是没有做配置，还是不能用的，这里解说下基本的配置： 1. 首先打开Git Bash做些全局设置： 1. git config \u0026ndash;global user.name \u0026ldquo;你的注册用户名\u0026rdquo; 2. git config \u0026ndash;global user.email \u0026ldquo;你的邮箱\u0026rdquo; 3. git config \u0026ndash;global color.ui auto 2. 设置SSH Key： 3. ssh-keygen -t rsa -C \u0026ldquo;你的邮箱\u0026rdquo; 然后会要求输入存储id_rsa的目录，接着是输入密码，这个密码可以与github的不同，过程中确认即可，最后会出现一个随机图形，说明生成SSH密匙成功，这样我们需要到刚刚的存储目录下打开id_rsa.pub复制里面的内容，到你的github页面上-\u0026gt;点击右上角头像旁三角-\u0026gt;settings-\u0026gt;SSH keys-\u0026gt;add SSH key-\u0026gt;黏贴刚刚复制的内容保存。\n1.4 使用hugo hugo是一个快速的静态网站引擎，使用Go语言开发，可以用Markdown格式的文章生成一个完整的静态网站，然后托管到自己的用户名.Github.io的Github仓库中，实现一个静态站点，一般用于博客或者项目主页等。那么我们先来了解下如何获取和使用： 1. 先从官网下载相关的版本，比如我是32位windows系统的，我下载hugo_0.14_windows_386.zip； 2. 解压缩后，将里面的exe文件重命名为hugo.exe，并放在C:\\hugo\\hugo.exe即可； 3. 添加环境变量：我的电脑-属性-高级系统设置-环境变量，编辑PATH，加入;C:\\hugo,用英文分号与之前的内容分割开。 这样我们可以测试下环境是否正常： 使用Windows命令行（Win+R输入cmd）输入下列命令：\ncd C:\\hugo hugo new site www  进入hugo目录下可以看到一个www的文件夹，就是刚刚新建的站点，目录的结构是： 1. ▸ archetypes/ 2. ▸ content/ 3. ▸ layouts/ 4. ▸ static/ 5. config.toml 尽管里面没有任何内容，但是恭喜你，说明程序可以正常使用了。\n2.正式建立静态网站 2.1 新建文章 首先需要先命令行进入www文件夹下，然后输入以下命令，创建一个关于页面：\nhugo new about.md  这样就生成楼www/content/about.md，打开该文件可以看到以下信息： 1. +++ 2. date = \u0026ldquo;2015-11-15T10:42:51+08:00\u0026rdquo; 3. draft = true 4. title = \u0026ldquo;about\u0026rdquo; 5.\n6. +++ 文件是md的，但是+++之间的内容是用TOML编写的文档信息，date代表文档创建的时间，后面的+08：00代表的时区，draft代表草稿，如果生成网站时不加入特殊说明是不生成该页的，title是这篇文章的标题，因此正文中不需要自己再写标题了。 为了方便之后生成聚合页面，我们继续在www/content/post/目录生成第一篇文章： hugo new post/first.md 打开first.md文件可以看到以下内容，跟上面的about.md差不多，我们在+++后面编辑一点内容并保存： 1. +++ 2. date = \u0026ldquo;2015-11-15T10:48:56+08:00\u0026rdquo; 3. draft = true 4. title = \u0026ldquo;first\u0026rdquo; 5.\n6. +++ 7. # My first blog 8. 1. aaa 9. 2. bbb 10. 3. ccc\n2.2 安装皮肤 hugo有很多皮肤(Github),也可以看这里(中文),可以找到喜欢的皮肤地址，然后在www文件夹下创建一个themes文件夹，在命令行中进入该文件夹后用git的方法获得皮肤(笔者这里使用hyde这个简单点的皮肤主题)：\ngit clone http://github.com/spf13/hyde.git  2.3 运行hugo 在站点根目录www文件夹下运行hugo调试命令： hugo server \u0026ndash;theme=hyde \u0026ndash;buildDrafts \u0026ndash;watch theme指明使用的主题名称（themes文件夹下的主题文件夹名称），buildDrafts指出编译草稿部分（即draft=true的文件），watch参数可以在文件修改时实时自动刷新页面。生成后我们可以在按照命令行提示在浏览器中输入http://127.0.0.1:1313查看页面，正常的话显示如下： 2.4 简单配置 目前为止，已经生成一个简单的静态站点，但是还有很多地方需要修改，以适应每个人的需求，可以在www站点根目录下看到一个config.toml配置文件，该文件使用TOML语法编写，基本内容如下：\nbaseurl = \u0026quot;http://replace-this-with-your-hugo-site.com/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot;  4.将本地站点上传 之前第一节已经注册好Github并创建软件仓库，现在我们需要生成最终的页面并上传到自己的Github仓库中，完成站点的最终部署，只需要在www根目录输入：\nhugo  或没有配置好config.toml文件的话用：\nhugo --thmem=hyde --baseUrl=\u0026quot;http://用户名.github.io\u0026quot;  这样在www目录下会生成一个public文件夹用于发布正式的站点，进行下列操作上传所有文件：\n1. cd public 2. git init 3. git remote add origin https://github.com/用户名/用户名.github.io.git 4. git add -A 5. git commit -m \u0026quot;first commit\u0026quot; 6. git push -u origin master  过程中会要求用户输入github的用户名和密码，密码是隐式的，所以别以为没输入。上传成功后，只要在浏览器中输入http://用户名.github.io即可访问你自己的站点了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/nexus3/",
	"title": "nexus3安装及使用",
	"tags": [],
	"description": "",
	"content": " Nexus3 安装：  Nexus3 运行时需要java8以上的环境，官方说不支持openjdk，但是我使用目前没有发现问题；\nNexus3允许为程序配置专用的jre环境，这样的话不会影响外部程序的运行。版本不一样也没问题。\n 只需要修改启动文件，/bin/nexus。 INSTALL4J_JAVA_HOME_OVERRIDE=/usr/lib/jvm/java-8-oracle\n 在linux安装 两种方式：docker安装，和包安装\n以下介绍包安装方式，nexus3没有硬编码目录，在任何目录下都可以运行，只需要解压tar包\n解压命令：\ntar -zxvf 包名  Nexus3开机自启动： 两种方式：主要区别是在linux系统的区别CentOS6,7\n6采用init.d,chkconfig的方式\nsudo ln -s $ NEXUS_HOME / bin / nexus /etc/init.d/nexus cd /etc/init.d sudo chkconfig --add nexus sudo chkconfig --levels 345 nexus on sudo service nexus start  第二种方式CentOS7，以服务 的方式运行\n编写nexus.service文件 ：\nvi /etc/systemd/system/nexus.service [Unit] Description=nexus service After=network.target [Service] Type=forking LimitNOFILE=65536 ExecStart=/opt/nexus/bin/nexus start ExecStop=/opt/nexus/bin/nexus stop User=nexus Restart=on-abort [Install] WantedBy=multi-user.target ：wq sudo systemctl daemon-reload sudo systemctl enable nexus.service sudo systemctl start nexus.service   之后就可以启动了\ntail -f /自定义目录/sonatype-work/nexus3/log/nexus.log\n可以看到启动成功的日志\n其他默认就好；\n此时，应该都已经设置好了：访问web界面：Ip：8081。 默认端口是8081.可以自定义修改\n它的用户名是 admin ，密码是 admin123。您可以使用用户界面右上角的按钮登录。\n 如果你只是安装自己玩玩，到这里就结束了。如果是实际使用，那就需要看下面的部分\n在服务器上，程序有两个目录\n安装目录。数据目录。\n安装目录\n $ ls -1 nexus-\u0026lt;version\u0026gt; LICENSE.txt NOTICE.txt bin deploy etc lib public system   LICENSE.txt 和 NOTICE.txt\n这些文件包含有关许可和版权声明的法律详细信息\nbin\n此目录包含 nexus 启动脚本本身以及与启动相关的配置文件\netc\n该目录包含配置文件\nlib\n该目录包含与Apache Karaf相关的二进制库\npublic\n该目录包含应用程序的公共资源\nsystem\n该目录包含构成应用程序的所有组件和插件\n数据目录 默认情况下找到的数据目录 ../sonatype-work/nexus3包含子目录，这些子目录包含存储库管理器提供的所有组件，存储库，配置和其他数据。子目录列为：\nblobs/\n这是blob存储的默认位置。如果在创建新的Blob存储库时提供了完全限定的路径，则它可能不会在此目录中结束。\ncache/\n此目录包含有关当前缓存的Karaf捆绑包的信息\ndb/\n此目录包含OrientDB数据库，它是存储库管理器元数据的主存储\nelasticsearch/\n此目录包含当前配置的Elasticsearch状态\netc/\n此目录包含存储库管理器的主运行时配置和自定义。配置运行时环境中进一步说明了这些文件 。\nhealth-check/\n此目录包含来自存储库运行状况检查功能的缓存报告\nkeystores/\n它包含用于标识存储库管理器的自动生成的密钥\nlog/\n此目录包含几个日志文件，用于捕获有关正在运行的存储库管理器的各个方面的信 在 nexus.log 和 request.log 文件旋转，所以每天这个目录也包含这些文件的归档副本。要回收磁盘空间，可以从logs目录中删除旧的日志文件。在此目录中找到的日志文件包括： nexus.log - 主存储库管理器应用程序日志。日志消息包含标准日志输出字段，包括日期/时间，日志级别，关联的线程，类和消息。\nrequest.log - 用于将http访问请求记录到正在运行的存储库管理器。日志消息包含客户端主机，用户和HTTP请求属性等信息，包括状态代码，字节和用户代理标头。\njvm.log - 包含JVM标准输出，stderr和线程转储消息\nkaraf.log - 这是Apache Karaf容器日志文件，其中包含特定于存储库管理器启动的消息\n该 log 目录还包含一个tasks 子目录，该 子目录包含运行的每个任务的单独的，唯一命名的（按日期，时间和任务名称）日志输出文件。有关 这些文件的命名策略和内容的更多详细信息，请参阅 任务日志记录。\ntmp/ -该目录用于临时存储\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/pm20/",
	"title": "pm2常用 命令",
	"tags": [],
	"description": "",
	"content": " 1. 启动 pm2 start app.js pm2 start app.js --name my-api #my-api为PM2进程名称 pm2 start app.js -i 0 #根据CPU核数启动进程个数 pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload  2. 查看进程 pm2 list pm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id  3. 监控 pm2 monit  4. 停止 pm2 stop all #停止PM2列表中所有的进程 pm2 stop 0 #停止PM2列表中进程为0的进程  5. 重载 pm2 reload all #重载PM2列表中所有的进程 pm2 reload 0 #重载PM2列表中进程为0的进程  6. 重启 pm2 restart all #重启PM2列表中所有的进程 pm2 restart 0 #重启PM2列表中进程为0的进程  7. 删除PM2进程 pm2 delete 0 #删除PM2列表中进程为0的进程 pm2 delete all #删除PM2列表中所有的进程  8. 日志操作 pm2 logs [--raw] #Display all processes logs in streaming pm2 flush #Empty all log file pm2 reloadLogs #Reload all logs  9. 升级PM2 npm install pm2@lastest -g #安装最新的PM2版本 pm2 updatePM2 #升级pm2  10. 更多命令参数请查看帮助 pm2 --help  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/verdaccio/",
	"title": "内网搭建npm私服",
	"tags": [],
	"description": "",
	"content": " 1、下载verdaccio 从github下载verdaccio，得到下载的包，之后拷贝到内网环境，在verdaccio文件目录下\nnpm install -g verdaccio --unsafe-perm  2、配置 C:\\Users\\用户名\\AppData\\Roaming\\verdaccio\\config.yaml 在末尾加listen: 0.0.0.0:4873，不配置的话只能本机访问。\n内网环境下将uplinks部分去掉或注释。\n3、启动 verdaccio  4、托管启动 安装pm2 从github下载pm2，得到下载的包，之后拷贝到内网环境，在pm2文件目录下\nnpm install npm link  使用pm2启动 pm2 start verdaccio  Pm2常用命令\n5、访问 访问localhost:4873,可以看到登录页面\n6、注册及登录 npm adduser –registry http://localhost:4873  如果已经配置了地址，则不需要\u0026ndash;registry部分，按照提示输入username，psd。\n7、公共组件打包 将写好的组件通过 npm run build打包，生成dist文件夹。 将路径切换到项目的dist的文件夹下，执行命令npm init，生成package.json,里面包含了版本，组件名等信息： 之后在npm上发布\nnpm publish --registry http://localhost:4873  之后在需要使用的项目下载\nnpm install table-two --registry=http://localhost:4873  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/singletonpattern/",
	"title": "单例模式",
	"tags": [],
	"description": "",
	"content": " 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n注意：\n1、单例类只能有一个实例。\n2、单例类必须自己创建自己的唯一实例。\n3、单例类必须给所有其他对象提供这一实例。\n介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n主要解决：一个全局使用的类频繁地创建与销毁。\n何时使用：当您想控制实例数目，节省系统资源的时候。\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n关键代码：构造函数是私有的。\n应用实例：\n1、一个班级只有一个班主任。\n2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n优点：\n1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n2、避免对资源的多重占用（比如写文件操作）。\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n使用场景：\n1、要求生产唯一序列号。\n2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n实现 我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。\nSingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1 public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\u0026quot;Hello World!\u0026quot;); } }  步骤 2 创建 Observer 类。\npublic class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }  步骤 3 Hello World!  单例模式的几种实现方式 1、懒汉式，线程不安全 是否 Lazy 初始化：是\n是否多线程安全：否\n实现难度：易\n描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。\n2、懒汉式，线程安全 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：易\n描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  3、饿汉式 是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\n实例\npublic class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }  4、双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本：JDK1.5 起\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：较复杂\n描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。\n实例\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }  5、登记式/静态内部类 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：一般\n描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。\n实例\npublic class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }  6、枚举 JDK 版本：JDK1.5 起\n是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。\n实例\npublic enum Singleton { INSTANCE; public void whateverMethod() { } }  经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/commandpattern/",
	"title": "命令模式",
	"tags": [],
	"description": "",
	"content": " 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n介绍 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n何时使用：在某些场合，比如要对行为进行\u0026rdquo;记录、撤销/重做、事务\u0026rdquo;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\u0026rdquo;行为请求者\u0026rdquo;与\u0026rdquo;行为实现者\u0026rdquo;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n缺点：使用命令模式可能会导致某些系统有过多的具体命令类。\n使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\n注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n实现 我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。\nBroker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。 步骤 1 创建一个接口：\npublic interface Order { void execute(); }  步骤 2 创建一个请求类。\npublic class Stock { private String name = \u0026quot;ABC\u0026quot;; private int quantity = 10; public void buy(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] bought\u0026quot;); } public void sell(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] sold\u0026quot;); } }  步骤 3 创建实现了 Order 接口的实体类。\npublic class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); } }  public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); } }  步骤 4 创建命令调用类。\nimport java.util.ArrayList; import java.util.List; public class Broker { private List\u0026lt;Order\u0026gt; orderList = new ArrayList\u0026lt;Order\u0026gt;(); public void takeOrder(Order order){ orderList.add(order); } public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); } }  步骤 5 使用 Broker 类来接受并执行命令。\npublic class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); } }  步骤 6 执行程序，输出结果：\nStock [ Name: ABC, Quantity: 10 ] bought Stock [ Name: ABC, Quantity: 10 ] sold  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/factorypattern/",
	"title": "工厂模式",
	"tags": [],
	"description": "",
	"content": " 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n介绍 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n主要解决：主要解决接口选择的问题。\n何时使用：我们明确地计划不同条件下创建不同实例时。\n如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。\n关键代码：创建过程在其子类执行。\n应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。\n优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\n缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\u0026rdquo;POP3\u0026rdquo;、\u0026rdquo;IMAP\u0026rdquo;、\u0026rdquo;HTTP\u0026rdquo;，可以把这三个作为产品类，共同实现一个接口。\n注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n实现 简单工厂模式 一个栗子： 我喜欢吃面条，抽象一个面条基类，(接口也可以)，这是产品的抽象类。\npublic abstract class INoodles { /** * 描述每种面条啥样的 */ public abstract void desc(); }  先来一份兰州拉面（具体的产品类）：\npublic class LzNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;兰州拉面 上海的好贵 家里才5 6块钱一碗\u0026quot;); } }  程序员加班必备也要吃泡面（具体的产品类）：\npublic class PaoNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;泡面好吃 可不要贪杯\u0026quot;); } }  还有我最爱吃的家乡的干扣面（具体的产品类）：\npublic class GankouNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;还是家里的干扣面好吃 6块一碗\u0026quot;); } }  准备工作做完了，我们来到一家“简单面馆”（简单工厂类），菜单如下：\npublic class SimpleNoodlesFactory { public static final int TYPE_LZ = 1;//兰州拉面 public static final int TYPE_PM = 2;//泡面 public static final int TYPE_GK = 3;//干扣面 public static INoodles createNoodles(int type) { switch (type) { case TYPE_LZ: return new LzNoodles(); case TYPE_PM: return new PaoNoodles(); case TYPE_GK: default: return new GankouNoodles(); } } }  简单面馆就提供三种面条（产品），你说你要啥，他就给你啥。这里我点了一份干扣面:\n/** * 简单工厂模式 */ INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK); noodles.desc();  输出：\n还是家里的干扣面好吃 6块一碗  特点\n1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。\n2 create()方法通常是静态的，所以也称之为静态工厂。\n缺点 1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）\n2 不同的产品需要不同额外参数的时候 不支持。\n二、工厂方法模式\n1.模式描述 提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。\n2.模式作用 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。\n可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。 等等。 另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。\n3.适用场景 消费者不关心它所要创建对象的类(产品类)的时候。\n消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。\n等等。\n例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。\n####### 4.模式要素 提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。 提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。 由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。\n5.模式实例代码 工厂：\npackage com.demoFound.factoryMethod.factory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_工厂接口 * * @author popkidorc * */ public interface IMyMessageFactory { public IMyMessage createMessage(String messageType); }  package com.demoFound.factoryMethod.factory; import java.util.HashMap; import java.util.Map; import com.demoFound.factoryMethod.message.IMyMessage; import com.demoFound.factoryMethod.message.MyMessageEmail; import com.demoFound.factoryMethod.message.MyMessageOaTodo; import com.demoFound.factoryMethod.message.MyMessageSms; /** * 工厂方法模式_工厂实现 * * @author popkidorc * */ public class MyMessageFactory implements IMyMessageFactory { @Override public IMyMessage createMessage(String messageType) { // 这里的方式是：消费者知道自己想要什么产品；若生产何种产品完全由工厂决定，则这里不应该传入控制生产的参数。 IMyMessage myMessage; Map\u0026lt;String, Object\u0026gt; messageParam = new HashMap\u0026lt;String, Object\u0026gt;(); // 根据某些条件去选择究竟创建哪一个具体的实现对象，条件可以传入的，也可以从其它途径获取。 // sms if (\u0026quot;SMS\u0026quot;.equals(messageType)) { myMessage = new MyMessageSms(); messageParam.put(\u0026quot;PHONENUM\u0026quot;, \u0026quot;123456789\u0026quot;); } else // OA待办 if (\u0026quot;OA\u0026quot;.equals(messageType)) { myMessage = new MyMessageOaTodo(); messageParam.put(\u0026quot;OAUSERNAME\u0026quot;, \u0026quot;testUser\u0026quot;); } else // email if (\u0026quot;EMAIL\u0026quot;.equals(messageType)) { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } else // 默认生产email这个产品 { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } myMessage.setMessageParam(messageParam); return myMessage; } }  产品：\npackage com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_产品接口 * * @author popkidorc * */ public interface IMyMessage { public Map\u0026lt;String, Object\u0026gt; getMessageParam(); public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam); public void sendMesage() throws Exception;// 发送通知/消息 }  package com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_虚拟产品类 * * @author popkidorc * */ public abstract class MyAbstractMessage implements IMyMessage { private Map\u0026lt;String, Object\u0026gt; messageParam;// 这里可以理解为生产产品所需要的原材料库。最好是个自定义的对象，这里为了不引起误解使用Map。 @Override public Map\u0026lt;String, Object\u0026gt; getMessageParam() { return messageParam; } @Override public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam) { this.messageParam = messageParam; } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_email产品 * * @author popkidorc * */ public class MyMessageEmail extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;EMAIL\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;EMAIL\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入EMAIL参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外邮件内容，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是邮件，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;EMAIL\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_oa待办产品 * * @author popkidorc * */ public class MyMessageOaTodo extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;))) { throw new Exception(\u0026quot;发送OA待办,需要传入OAUSERNAME参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 这里的参数需求就比较多了不一一处理了 System.out .println(\u0026quot;我是OA待办，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_sms产品 * * @author popkidorc * */ public class MyMessageSms extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;PHONENUM\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;PHONENUM\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入PHONENUM参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外短信信息，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是短信，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;PHONENUM\u0026quot;)); } }  消费者：\npackage com.demoFound.factoryMethod; import com.demoFound.factoryMethod.factory.IMyMessageFactory; import com.demoFound.factoryMethod.factory.MyMessageFactory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_消费者类 * * @author popkidorc * */ public class MyFactoryMethodMain { public static void main(String[] args) { IMyMessageFactory myMessageFactory = new MyMessageFactory(); IMyMessage myMessage; // 对于这个消费者来说，不用知道如何生产message这个产品，耦合度降低 try { // 先来一个短信通知 myMessage = myMessageFactory.createMessage(\u0026quot;SMS\u0026quot;); myMessage.sendMesage(); // 来一个oa待办 myMessage = myMessageFactory.createMessage(\u0026quot;OA\u0026quot;); myMessage.sendMesage(); // 来一个邮件通知 myMessage = myMessageFactory.createMessage(\u0026quot;EMAIL\u0026quot;); myMessage.sendMesage(); } catch (Exception e) { e.printStackTrace(); } } }  三、抽象工厂模式\n定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n类型：创建类模式\n类图：\n抽象工厂模式与工厂方法模式的区别\n抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。\n在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。\n明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。\n抽象工厂模式代码\ninterface IProduct1 { public void show(); } interface IProduct2 { public void show(); } class Product1 implements IProduct1 { public void show() { System.out.println(\u0026quot;这是1型产品\u0026quot;); } } class Product2 implements IProduct2 { public void show() { System.out.println(\u0026quot;这是2型产品\u0026quot;); } } interface IFactory { public IProduct1 createProduct1(); public IProduct2 createProduct2(); } class Factory implements IFactory{ public IProduct1 createProduct1() { return new Product1(); } public IProduct2 createProduct2() { return new Product2(); } } public class Client { public static void main(String[] args){ IFactory factory = new Factory(); factory.createProduct1().show(); factory.createProduct2().show(); } }  抽象工厂模式的优点\n抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。\n抽象工厂模式的缺点 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。\n适用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。\n总结 无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/strategypattern/",
	"title": "策略模式",
	"tags": [],
	"description": "",
	"content": " 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if\u0026hellip;else 所带来的复杂和难以维护。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。\n应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。\n优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。\n使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n实现 我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1 创建一个接口。Strategy.java\npublic interface Strategy { public int doOperation(int num1, int num2); }  步骤 2 创建实现接口的实体类。OperationAdd.java\npublic class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } }  步骤 3 创建 Context 类。Context.java\npublic class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } }  步骤 4 使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo\npublic class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\u0026quot;10 + 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(\u0026quot;10 - 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\u0026quot;10 * 5 = \u0026quot; + context.executeStrategy(10, 5)); } }  步骤 5 执行程序，输出结果：\n10 + 5 = 15 10 - 5 = 5 10 * 5 = 50  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/decoratorpattern/",
	"title": "装饰器模式",
	"tags": [],
	"description": "",
	"content": " 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。\n介绍 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n何时使用：在不想增加很多子类的情况下扩展类。\n如何解决：将具体功能职责划分，同时继承装饰者模式。\n关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n应用实例： 1、孙悟空有 72 变，当他变成\u0026rdquo;庙宇\u0026rdquo;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n注意事项：可代替继承。\n实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类。\nDecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。 步骤 1 创建一个接口：\npublic interface Shape { void draw(); }  步骤 2 创建实现接口的实体类。\npublic class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Rectangle\u0026quot;); } }  public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Circle\u0026quot;); } }  步骤 3 创建实现了 Shape 接口的抽象装饰类。\npublic abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } }  步骤 4 创建扩展了 ShapeDecorator 类的实体装饰类。\npublic class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(\u0026quot;Border Color: Red\u0026quot;); } }  步骤 5 使用 RedShapeDecorator 来装饰 Shape 对象。\npublic class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\u0026quot;Circle with normal border\u0026quot;); circle.draw(); System.out.println(\u0026quot;\\nCircle of red border\u0026quot;); redCircle.draw(); System.out.println(\u0026quot;\\nRectangle of red border\u0026quot;); redRectangle.draw(); } }  步骤 6 执行程序，输出结果：\nCircle with normal border Shape: Circle Circle of red border Shape: Circle Border Color: Red Rectangle of red border Shape: Rectangle Border Color: Red  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/observerpattern/",
	"title": "观察者模式",
	"tags": [],
	"description": "",
	"content": " 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。\n介绍 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n关键代码：在抽象类里有一个 ArrayList 存放观察者们。\n应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n使用场景：\n一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n实现 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。\nObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 步骤 1 创建 Subject 类。\nimport java.util.ArrayList; import java.util.List; public class Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } }  步骤 2 创建 Observer 类。\npublic abstract class Observer { protected Subject subject; public abstract void update(); }  步骤 3 创建实体观察者类。\npublic class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Binary String: \u0026quot; + Integer.toBinaryString( subject.getState() ) ); } }  public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Octal String: \u0026quot; + Integer.toOctalString( subject.getState() ) ); } }  步骤 4 使用 Subject 和实体观察者对象。\npublic class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\u0026quot;First state change: 15\u0026quot;); subject.setState(15); System.out.println(\u0026quot;Second state change: 10\u0026quot;); subject.setState(10); } }  步骤 5 执行程序，输出结果：\nFirst state change: 15 Hex String: F Octal String: 17 Binary String: 1111 Second state change: 10 Hex String: A Octal String: 12 Binary String: 1010  java内置观察者 实现观察者模式 实现观察者模式非常简单， [1]创建被观察者类，它继承自java.util.Observable类； [2]创建观察者类，它实现java.util.Observer接口；\n对于被观察者类： 添加它的观察者： void addObserver(Observer o) addObserver()方法把观察者对象添加到观察者对象列表中\n当被观察者中的事件发生变化时，执行 setChanged(); notifyObservers(); setChange()方法用来设置一个内部标志位注明数据发生了变化；notifyObservers()方法会去调用观察者对象列表中所有的Observer的update()方法，通知它们数据发生了变化。 只有在setChange()被调用后，notifyObservers()才会去调用update()。\n对于观察者类，实现Observer接口的唯一方法update void update(Observable o, Object arg)\n形参Object arg，对应一个由notifyObservers(Object arg);传递来的参数，当执行的是notifyObservers();时，arg为null。\n被观察者 package com.test.observer; import java.util.Observable; public class ServerManager extends Observable { private int data = 0; public int getData(){ return data; } public void setData(int i){ if(this.data != i){ this.data = i;setChanged();} notifyObservers(); //只有在setChange()被调用后，notifyObservers()才会去调用update()，否则什么都不干。 } } } }  观察者1 import java.util.Observable; import java.util.Observer; public class AObserver implements Observer { public AObserver(ServerManager sm) { super(); // TODO Auto-generated constructor stub sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable arg0, Object arg1) { System.out.println(\u0026quot;AObserver receive:Data has changed to \u0026quot;+((ServerManager) arg0).getData()); } }  观察者2 import java.util.Observable; import java.util.Observer; public class BObserver implements Observer { public BObserver(ServerManager sm) { super(); sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable o, Object arg) { // TODO Auto-generated method stub System.out.println(\u0026quot;BObserver receive:Data has changed to \u0026quot;+((ServerManager) o).getData()); } }  测试 public class TestDemo { public static void main(String[] args) { // TODO Auto-generated method stub ServerManager sm = new ServerManager(); AObserver a = new AObserver(sm); BObserver b = new BObserver(sm); sm.setData(5); sm.deleteObserver(a);　//注销观察者，以后被观察者有数据变化就不再通知这个已注销的观察者 sm.setData(10); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/",
	"title": "设计模式",
	"tags": [],
	"description": "",
	"content": "设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n"
}]
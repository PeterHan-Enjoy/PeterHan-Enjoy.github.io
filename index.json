[
{
	"uri": "https://peterhan-enjoy.github.com/utils/git/",
	"title": "Git使用",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/markdown/",
	"title": "Markdown使用",
	"tags": [],
	"description": "",
	"content": " Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n一、标题 在想要设置为标题的文字前面加#来表示\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。\n示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题  效果如下： 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二、字体 加粗\n要加粗的文字左右分别用两个*号包起来\n斜体\n要倾斜的文字左右分别用一个*号包起来\n斜体加粗\n要倾斜和加粗的文字左右分别用三个*号包起来\n删除线\n要加删除线的文字左右分别用两个~~号包起来\n示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~  效果如下： 这是加粗的文字\n这是倾斜的文字`\n这是斜体加粗的文字\n这是加删除线的文字\n三、分割线 三个或者三个以上的 - 或者 * 都可以。\n示例：  --- ---- *** *****  效果如下： 可以看到，显示效果是一样的。\n四、图片 语法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加  示例： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419\u0026amp;fm=27\u0026amp;gp=0.jpg \u0026quot;区块链\u0026quot;)  效果如下： 五、超链接 语法： [超链接名](超链接地址 \u0026quot;超链接title\u0026quot;) title可加可不加  示例： [简书](http://jianshu.com) [百度](http://baidu.com)  效果如下： 简书\n百度\n注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。\n\u0026lt;a href=\u0026quot;超链接地址\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;超链接名\u0026lt;/a\u0026gt; 示例 \u0026lt;a href=\u0026quot;https://www.jianshu.com/u/1f5ac0cf6a8b\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;简书\u0026lt;/a\u0026gt;  六、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  有序列表 语法： 数字加点 1. 列表内容 2. 列表内容 3. 列表内容 注意：序号跟内容之间要有空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  七、表格 语法： 表头|表头|表头 :-:|:-:|:-: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略  示例： 姓名|技能|排行 :-:|:-:|:-: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟  效果如下：    姓名 技能 排行     刘备 哭 大哥   关羽 打 二哥   张飞 骂 三弟    八、代码 语法： 单行代码：代码之间分别用一个反引号包起来\n `代码内容`  代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n(```) 代码... 代码... 代码... (```)  注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n示例： 单行代码\n`create database hero;`  代码块\n(```) function fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun(); (```)  效果如下： 单行代码\ncreate database hero;\n代码块\nfunction fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun();  九、问题 行末两个空格 在Hugo编写Markdown文件时，如果行末没有两个空格是不会换行的。\n高亮 在Markdown中，==可以用作高亮，但是hugo则不行\n代码 在hugo中，三个反引号和代码放一行是不会渲染出代码结构的，除非换行。\n转义 \u0026gt; =\u0026gt; \u0026amp;gt;  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/maven/",
	"title": "Maven使用",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/",
	"title": "工具类",
	"tags": [],
	"description": "",
	"content": " Maven Git Markdown "
},
{
	"uri": "https://peterhan-enjoy.github.com/",
	"title": "规范",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/design/singletonpattern/",
	"title": "单例模式",
	"tags": [],
	"description": "",
	"content": " 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n注意：\n1、单例类只能有一个实例。\n2、单例类必须自己创建自己的唯一实例。\n3、单例类必须给所有其他对象提供这一实例。\n介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n主要解决：一个全局使用的类频繁地创建与销毁。\n何时使用：当您想控制实例数目，节省系统资源的时候。\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n关键代码：构造函数是私有的。\n应用实例：\n1、一个班级只有一个班主任。\n2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n优点：\n1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n2、避免对资源的多重占用（比如写文件操作）。\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n使用场景：\n1、要求生产唯一序列号。\n2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n实现 我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。\nSingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1 public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\u0026quot;Hello World!\u0026quot;); } }  步骤 2 创建 Observer 类。\npublic class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }  步骤 3 Hello World!  单例模式的几种实现方式 1、懒汉式，线程不安全 是否 Lazy 初始化：是\n是否多线程安全：否\n实现难度：易\n描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。\n2、懒汉式，线程安全 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：易\n描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  3、饿汉式 是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\n实例\npublic class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }  4、双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本：JDK1.5 起\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：较复杂\n描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。\n实例\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }  5、登记式/静态内部类 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：一般\n描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。\n实例\npublic class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }  6、枚举 JDK 版本：JDK1.5 起\n是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。\n实例\npublic enum Singleton { INSTANCE; public void whateverMethod() { } }  经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/commandpattern/",
	"title": "命令模式",
	"tags": [],
	"description": "",
	"content": " 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n介绍 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n何时使用：在某些场合，比如要对行为进行\u0026rdquo;记录、撤销/重做、事务\u0026rdquo;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\u0026rdquo;行为请求者\u0026rdquo;与\u0026rdquo;行为实现者\u0026rdquo;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n缺点：使用命令模式可能会导致某些系统有过多的具体命令类。\n使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\n注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n实现 我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。\nBroker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。 步骤 1 创建一个接口：\npublic interface Order { void execute(); }  步骤 2 创建一个请求类。\npublic class Stock { private String name = \u0026quot;ABC\u0026quot;; private int quantity = 10; public void buy(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] bought\u0026quot;); } public void sell(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] sold\u0026quot;); } }  步骤 3 创建实现了 Order 接口的实体类。\npublic class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); } }  public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); } }  步骤 4 创建命令调用类。\nimport java.util.ArrayList; import java.util.List; public class Broker { private List\u0026lt;Order\u0026gt; orderList = new ArrayList\u0026lt;Order\u0026gt;(); public void takeOrder(Order order){ orderList.add(order); } public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); } }  步骤 5 使用 Broker 类来接受并执行命令。\npublic class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); } }  步骤 6 执行程序，输出结果：\nStock [ Name: ABC, Quantity: 10 ] bought Stock [ Name: ABC, Quantity: 10 ] sold  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/factorypattern/",
	"title": "工厂模式",
	"tags": [],
	"description": "",
	"content": " 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n介绍 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n主要解决：主要解决接口选择的问题。\n何时使用：我们明确地计划不同条件下创建不同实例时。\n如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。\n关键代码：创建过程在其子类执行。\n应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。\n优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\n缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\u0026rdquo;POP3\u0026rdquo;、\u0026rdquo;IMAP\u0026rdquo;、\u0026rdquo;HTTP\u0026rdquo;，可以把这三个作为产品类，共同实现一个接口。\n注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n实现 简单工厂模式 一个栗子： 我喜欢吃面条，抽象一个面条基类，(接口也可以)，这是产品的抽象类。\npublic abstract class INoodles { /** * 描述每种面条啥样的 */ public abstract void desc(); }  先来一份兰州拉面（具体的产品类）：\npublic class LzNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;兰州拉面 上海的好贵 家里才5 6块钱一碗\u0026quot;); } }  程序员加班必备也要吃泡面（具体的产品类）：\npublic class PaoNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;泡面好吃 可不要贪杯\u0026quot;); } }  还有我最爱吃的家乡的干扣面（具体的产品类）：\npublic class GankouNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;还是家里的干扣面好吃 6块一碗\u0026quot;); } }  准备工作做完了，我们来到一家“简单面馆”（简单工厂类），菜单如下：\npublic class SimpleNoodlesFactory { public static final int TYPE_LZ = 1;//兰州拉面 public static final int TYPE_PM = 2;//泡面 public static final int TYPE_GK = 3;//干扣面 public static INoodles createNoodles(int type) { switch (type) { case TYPE_LZ: return new LzNoodles(); case TYPE_PM: return new PaoNoodles(); case TYPE_GK: default: return new GankouNoodles(); } } }  简单面馆就提供三种面条（产品），你说你要啥，他就给你啥。这里我点了一份干扣面:\n/** * 简单工厂模式 */ INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK); noodles.desc();  输出：\n还是家里的干扣面好吃 6块一碗  特点\n1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。\n2 create()方法通常是静态的，所以也称之为静态工厂。\n缺点 1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）\n2 不同的产品需要不同额外参数的时候 不支持。\n二、工厂方法模式\n1.模式描述 提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。\n2.模式作用 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。\n可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。 等等。 另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。\n3.适用场景 消费者不关心它所要创建对象的类(产品类)的时候。\n消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。\n等等。\n例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。\n####### 4.模式要素 提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。 提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。 由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。\n5.模式实例代码 工厂：\npackage com.demoFound.factoryMethod.factory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_工厂接口 * * @author popkidorc * */ public interface IMyMessageFactory { public IMyMessage createMessage(String messageType); }  package com.demoFound.factoryMethod.factory; import java.util.HashMap; import java.util.Map; import com.demoFound.factoryMethod.message.IMyMessage; import com.demoFound.factoryMethod.message.MyMessageEmail; import com.demoFound.factoryMethod.message.MyMessageOaTodo; import com.demoFound.factoryMethod.message.MyMessageSms; /** * 工厂方法模式_工厂实现 * * @author popkidorc * */ public class MyMessageFactory implements IMyMessageFactory { @Override public IMyMessage createMessage(String messageType) { // 这里的方式是：消费者知道自己想要什么产品；若生产何种产品完全由工厂决定，则这里不应该传入控制生产的参数。 IMyMessage myMessage; Map\u0026lt;String, Object\u0026gt; messageParam = new HashMap\u0026lt;String, Object\u0026gt;(); // 根据某些条件去选择究竟创建哪一个具体的实现对象，条件可以传入的，也可以从其它途径获取。 // sms if (\u0026quot;SMS\u0026quot;.equals(messageType)) { myMessage = new MyMessageSms(); messageParam.put(\u0026quot;PHONENUM\u0026quot;, \u0026quot;123456789\u0026quot;); } else // OA待办 if (\u0026quot;OA\u0026quot;.equals(messageType)) { myMessage = new MyMessageOaTodo(); messageParam.put(\u0026quot;OAUSERNAME\u0026quot;, \u0026quot;testUser\u0026quot;); } else // email if (\u0026quot;EMAIL\u0026quot;.equals(messageType)) { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } else // 默认生产email这个产品 { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } myMessage.setMessageParam(messageParam); return myMessage; } }  产品：\npackage com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_产品接口 * * @author popkidorc * */ public interface IMyMessage { public Map\u0026lt;String, Object\u0026gt; getMessageParam(); public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam); public void sendMesage() throws Exception;// 发送通知/消息 }  package com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_虚拟产品类 * * @author popkidorc * */ public abstract class MyAbstractMessage implements IMyMessage { private Map\u0026lt;String, Object\u0026gt; messageParam;// 这里可以理解为生产产品所需要的原材料库。最好是个自定义的对象，这里为了不引起误解使用Map。 @Override public Map\u0026lt;String, Object\u0026gt; getMessageParam() { return messageParam; } @Override public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam) { this.messageParam = messageParam; } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_email产品 * * @author popkidorc * */ public class MyMessageEmail extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;EMAIL\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;EMAIL\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入EMAIL参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外邮件内容，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是邮件，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;EMAIL\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_oa待办产品 * * @author popkidorc * */ public class MyMessageOaTodo extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;))) { throw new Exception(\u0026quot;发送OA待办,需要传入OAUSERNAME参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 这里的参数需求就比较多了不一一处理了 System.out .println(\u0026quot;我是OA待办，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_sms产品 * * @author popkidorc * */ public class MyMessageSms extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;PHONENUM\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;PHONENUM\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入PHONENUM参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外短信信息，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是短信，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;PHONENUM\u0026quot;)); } }  消费者：\npackage com.demoFound.factoryMethod; import com.demoFound.factoryMethod.factory.IMyMessageFactory; import com.demoFound.factoryMethod.factory.MyMessageFactory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_消费者类 * * @author popkidorc * */ public class MyFactoryMethodMain { public static void main(String[] args) { IMyMessageFactory myMessageFactory = new MyMessageFactory(); IMyMessage myMessage; // 对于这个消费者来说，不用知道如何生产message这个产品，耦合度降低 try { // 先来一个短信通知 myMessage = myMessageFactory.createMessage(\u0026quot;SMS\u0026quot;); myMessage.sendMesage(); // 来一个oa待办 myMessage = myMessageFactory.createMessage(\u0026quot;OA\u0026quot;); myMessage.sendMesage(); // 来一个邮件通知 myMessage = myMessageFactory.createMessage(\u0026quot;EMAIL\u0026quot;); myMessage.sendMesage(); } catch (Exception e) { e.printStackTrace(); } } }  三、抽象工厂模式\n定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n类型：创建类模式\n类图：\n抽象工厂模式与工厂方法模式的区别\n抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。\n在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。\n明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。\n抽象工厂模式代码\ninterface IProduct1 { public void show(); } interface IProduct2 { public void show(); } class Product1 implements IProduct1 { public void show() { System.out.println(\u0026quot;这是1型产品\u0026quot;); } } class Product2 implements IProduct2 { public void show() { System.out.println(\u0026quot;这是2型产品\u0026quot;); } } interface IFactory { public IProduct1 createProduct1(); public IProduct2 createProduct2(); } class Factory implements IFactory{ public IProduct1 createProduct1() { return new Product1(); } public IProduct2 createProduct2() { return new Product2(); } } public class Client { public static void main(String[] args){ IFactory factory = new Factory(); factory.createProduct1().show(); factory.createProduct2().show(); } }  抽象工厂模式的优点\n抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。\n抽象工厂模式的缺点 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。\n适用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。\n总结 无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/strategypattern/",
	"title": "策略模式",
	"tags": [],
	"description": "",
	"content": " 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if\u0026hellip;else 所带来的复杂和难以维护。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。\n应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。\n优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。\n使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n实现 我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1 创建一个接口。Strategy.java\npublic interface Strategy { public int doOperation(int num1, int num2); }  步骤 2 创建实现接口的实体类。OperationAdd.java\npublic class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } }  步骤 3 创建 Context 类。Context.java\npublic class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } }  步骤 4 使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo\npublic class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\u0026quot;10 + 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(\u0026quot;10 - 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\u0026quot;10 * 5 = \u0026quot; + context.executeStrategy(10, 5)); } }  步骤 5 执行程序，输出结果：\n10 + 5 = 15 10 - 5 = 5 10 * 5 = 50  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/decoratorpattern/",
	"title": "装饰器模式",
	"tags": [],
	"description": "",
	"content": " 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。\n介绍 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n何时使用：在不想增加很多子类的情况下扩展类。\n如何解决：将具体功能职责划分，同时继承装饰者模式。\n关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n应用实例： 1、孙悟空有 72 变，当他变成\u0026rdquo;庙宇\u0026rdquo;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n注意事项：可代替继承。\n实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类。\nDecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。 步骤 1 创建一个接口：\npublic interface Shape { void draw(); }  步骤 2 创建实现接口的实体类。\npublic class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Rectangle\u0026quot;); } }  public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Circle\u0026quot;); } }  步骤 3 创建实现了 Shape 接口的抽象装饰类。\npublic abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } }  步骤 4 创建扩展了 ShapeDecorator 类的实体装饰类。\npublic class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(\u0026quot;Border Color: Red\u0026quot;); } }  步骤 5 使用 RedShapeDecorator 来装饰 Shape 对象。\npublic class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\u0026quot;Circle with normal border\u0026quot;); circle.draw(); System.out.println(\u0026quot;\\nCircle of red border\u0026quot;); redCircle.draw(); System.out.println(\u0026quot;\\nRectangle of red border\u0026quot;); redRectangle.draw(); } }  步骤 6 执行程序，输出结果：\nCircle with normal border Shape: Circle Circle of red border Shape: Circle Border Color: Red Rectangle of red border Shape: Rectangle Border Color: Red  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/observerpattern/",
	"title": "观察者模式",
	"tags": [],
	"description": "",
	"content": " 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。\n介绍 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n关键代码：在抽象类里有一个 ArrayList 存放观察者们。\n应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n使用场景：\n一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n实现 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。\nObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 步骤 1 创建 Subject 类。\nimport java.util.ArrayList; import java.util.List; public class Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } }  步骤 2 创建 Observer 类。\npublic abstract class Observer { protected Subject subject; public abstract void update(); }  步骤 3 创建实体观察者类。\npublic class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Binary String: \u0026quot; + Integer.toBinaryString( subject.getState() ) ); } }  public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Octal String: \u0026quot; + Integer.toOctalString( subject.getState() ) ); } }  步骤 4 使用 Subject 和实体观察者对象。\npublic class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\u0026quot;First state change: 15\u0026quot;); subject.setState(15); System.out.println(\u0026quot;Second state change: 10\u0026quot;); subject.setState(10); } }  步骤 5 执行程序，输出结果：\nFirst state change: 15 Hex String: F Octal String: 17 Binary String: 1111 Second state change: 10 Hex String: A Octal String: 12 Binary String: 1010  java内置观察者 实现观察者模式 实现观察者模式非常简单， [1]创建被观察者类，它继承自java.util.Observable类； [2]创建观察者类，它实现java.util.Observer接口；\n对于被观察者类： 添加它的观察者： void addObserver(Observer o) addObserver()方法把观察者对象添加到观察者对象列表中\n当被观察者中的事件发生变化时，执行 setChanged(); notifyObservers(); setChange()方法用来设置一个内部标志位注明数据发生了变化；notifyObservers()方法会去调用观察者对象列表中所有的Observer的update()方法，通知它们数据发生了变化。 只有在setChange()被调用后，notifyObservers()才会去调用update()。\n对于观察者类，实现Observer接口的唯一方法update void update(Observable o, Object arg)\n形参Object arg，对应一个由notifyObservers(Object arg);传递来的参数，当执行的是notifyObservers();时，arg为null。\n被观察者 package com.test.observer; import java.util.Observable; public class ServerManager extends Observable { private int data = 0; public int getData(){ return data; } public void setData(int i){ if(this.data != i){ this.data = i;setChanged();} notifyObservers(); //只有在setChange()被调用后，notifyObservers()才会去调用update()，否则什么都不干。 } } } }  观察者1 import java.util.Observable; import java.util.Observer; public class AObserver implements Observer { public AObserver(ServerManager sm) { super(); // TODO Auto-generated constructor stub sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable arg0, Object arg1) { System.out.println(\u0026quot;AObserver receive:Data has changed to \u0026quot;+((ServerManager) arg0).getData()); } }  观察者2 import java.util.Observable; import java.util.Observer; public class BObserver implements Observer { public BObserver(ServerManager sm) { super(); sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable o, Object arg) { // TODO Auto-generated method stub System.out.println(\u0026quot;BObserver receive:Data has changed to \u0026quot;+((ServerManager) o).getData()); } }  测试 public class TestDemo { public static void main(String[] args) { // TODO Auto-generated method stub ServerManager sm = new ServerManager(); AObserver a = new AObserver(sm); BObserver b = new BObserver(sm); sm.setData(5); sm.deleteObserver(a);　//注销观察者，以后被观察者有数据变化就不再通知这个已注销的观察者 sm.setData(10); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/",
	"title": "设计模式",
	"tags": [],
	"description": "",
	"content": "设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n"
}]
[
{
	"uri": "https://peterhan-enjoy.github.com/utils/markdown/",
	"title": "Markdown使用",
	"tags": [],
	"description": "",
	"content": " Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。\n一、标题 在想要设置为标题的文字前面加#来表示\n一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。\n注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。\n示例： # 这是一级标题 ## 这是二级标题 ### 这是三级标题 #### 这是四级标题 ##### 这是五级标题 ###### 这是六级标题  效果如下： 这是一级标题 这是二级标题 这是三级标题 这是四级标题 这是五级标题 这是六级标题 二、字体 加粗\n要加粗的文字左右分别用两个*号包起来\n斜体\n要倾斜的文字左右分别用一个*号包起来\n斜体加粗\n要倾斜和加粗的文字左右分别用三个*号包起来\n删除线\n要加删除线的文字左右分别用两个~~号包起来\n示例： **这是加粗的文字** *这是倾斜的文字*` ***这是斜体加粗的文字*** ~~这是加删除线的文字~~  效果如下： 这是加粗的文字\n这是倾斜的文字`\n这是斜体加粗的文字\n这是加删除线的文字\n三、分割线 三个或者三个以上的 - 或者 * 都可以。\n示例：  --- ---- *** *****  效果如下： 可以看到，显示效果是一样的。\n四、图片 语法： ![图片alt](图片地址 ''图片title'') 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。 图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加  示例： ![blockchain](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/ u=702257389,1274025419\u0026amp;fm=27\u0026amp;gp=0.jpg \u0026quot;区块链\u0026quot;)  效果如下： 五、超链接 语法： [超链接名](超链接地址 \u0026quot;超链接title\u0026quot;) title可加可不加  示例： [简书](http://jianshu.com) [百度](http://baidu.com)  效果如下： 简书\n百度\n注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。\n\u0026lt;a href=\u0026quot;超链接地址\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;超链接名\u0026lt;/a\u0026gt; 示例 \u0026lt;a href=\u0026quot;https://www.jianshu.com/u/1f5ac0cf6a8b\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;简书\u0026lt;/a\u0026gt;  六、列表 无序列表 语法： 无序列表用 - + * 任何一种都可以 - 列表内容 + 列表内容 * 列表内容 注意：- + * 跟内容之间都要有一个空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  有序列表 语法： 数字加点 1. 列表内容 2. 列表内容 3. 列表内容 注意：序号跟内容之间要有空格  效果如下：  列表内容\n 列表内容\n 列表内容\n  七、表格 语法： 表头|表头|表头 :-:|:-:|:-: 内容|内容|内容 内容|内容|内容 第二行分割表头和内容。 - 有一个就行，为了对齐，多加了几个 文字默认居左 -两边加：表示文字居中 -右边加：表示文字居右 注：原生的语法两边都要用 | 包起来。此处省略  示例： 姓名|技能|排行 :-:|:-:|:-: 刘备|哭|大哥 关羽|打|二哥 张飞|骂|三弟  效果如下：    姓名 技能 排行     刘备 哭 大哥   关羽 打 二哥   张飞 骂 三弟    八、代码 语法： 单行代码：代码之间分别用一个反引号包起来\n `代码内容`  代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行\n(```) 代码... 代码... 代码... (```)  注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。\n示例： 单行代码\n`create database hero;`  代码块\n(```) function fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun(); (```)  效果如下： 单行代码\ncreate database hero;\n代码块\nfunction fun(){ echo \u0026quot;这是一句非常牛逼的代码\u0026quot;; } fun();  九、问题 行末两个空格 在Hugo编写Markdown文件时，如果行末没有两个空格是不会换行的。\n高亮 在Markdown中，==可以用作高亮，但是hugo则不行\n代码 在hugo中，三个反引号和代码放一行是不会渲染出代码结构的，除非换行。\n转义 \u0026gt; =\u0026gt; \u0026amp;gt;  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/",
	"title": "工具类",
	"tags": [],
	"description": "",
	"content": " 工具使用 "
},
{
	"uri": "https://peterhan-enjoy.github.com/",
	"title": "规范",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/dae2gltf/",
	"title": "Dae转换Gltf",
	"tags": [],
	"description": "",
	"content": "下载地址 提取码：e4aq\n系统启动时生成启动文件\n import com.nuclear_Project.common.bean.SystemConfig; import org.apache.commons.lang3.BooleanUtils; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.ApplicationEvent; import org.springframework.context.ApplicationListener; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.context.event.ContextClosedEvent; import org.springframework.context.event.ContextRefreshedEvent; import org.springframework.core.env.Environment; import org.springframework.stereotype.Service; import java.io.BufferedWriter; import java.io.File; import java.io.FileOutputStream; import java.io.OutputStreamWriter; /** * 启动监听器\u0026lt;br /\u0026gt; * 1,初始化系统参数 * */ @Service @Configuration @PropertySource(\u0026quot;classpath:system.properties\u0026quot;) public class SystemStartLister implements ApplicationListener\u0026lt;ApplicationEvent\u0026gt; { @Autowired private Environment env; @Override public void onApplicationEvent(ApplicationEvent event) { try { String path = System.getProperty(\u0026quot;Nuclear_Project.root\u0026quot;); String collpath = path+\u0026quot;\\\\daetogltf\\\\COLLADA2GLTF-v2.1.4-windows-Release-x64\u0026quot;; String batpath = path+\u0026quot;\\\\daetogltf\\\\test.bat\u0026quot;; StringBuilder stringBuilder = new StringBuilder(); stringBuilder.append(\u0026quot;cd /d \u0026quot;+collpath); stringBuilder.append(System.getProperty(\u0026quot;line.separator\u0026quot;)); stringBuilder.append(collpath+\u0026quot;\\\\COLLADA2GLTF-bin.exe \u0026quot;); stringBuilder.append(\u0026quot;-f %1 -e\u0026quot;); stringBuilder.append(System.getProperty(\u0026quot;line.separator\u0026quot;)); stringBuilder.append(\u0026quot;exit\u0026quot;); File file = new File(batpath); OutputStreamWriter write = new OutputStreamWriter(new FileOutputStream(file), \u0026quot;GBK\u0026quot;); BufferedWriter writer = new BufferedWriter(write); writer.write(stringBuilder.toString()); writer.close(); write.close(); SystemConfig.batpath = batpath; }catch (Exception e){ e.printStackTrace(); } } } }  执行调用\npackage com.nuclear_Project.common.util; import com.nuclear_Project.common.bean.SystemConfig; import com.nuclear_Project.common.service.FileService; import com.nuclear_Project.model.bean.Model; import java.io.File; /** * @Auther: Han Youqi * @Date: 2019/5/7 15:42 * @Description: */ public class GltfUitl { public static Model daeToGltf(Model model){ String path = model.getModelUrl(); //将dae转化为gltf Process process = null; try { Runtime runtime = Runtime.getRuntime(); process = runtime.exec(\u0026quot;cmd /k start \u0026quot;+ SystemConfig.batpath +\u0026quot; \u0026quot;+path); Thread.sleep(3000); String finalPath = path.replace(\u0026quot;.dae\u0026quot;,\u0026quot;.gltf\u0026quot;); StringBuilder sb = new StringBuilder(finalPath); sb.insert(finalPath.lastIndexOf(\u0026quot;\\\\\u0026quot;),\u0026quot;\\\\output\u0026quot;); int index = sb.toString().indexOf(\u0026quot;upload\u0026quot;); String filePath = sb.toString().substring(index); String url = filePath.replaceAll(\u0026quot;\\\\\\\\\u0026quot;,\u0026quot;/\u0026quot;); model.setModelUrl(url); } catch (Exception e) { e.printStackTrace(); }finally { if (process != null){ process.destroy(); } } return model; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/excelutil/",
	"title": "Excel工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.lang.reflect.Type; import java.util.ArrayList; import java.util.Date; import java.util.List; import org.apache.poi.hssf.usermodel.HSSFCell; import org.apache.poi.hssf.usermodel.HSSFRow; import org.apache.poi.hssf.usermodel.HSSFSheet; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.poifs.filesystem.NotOLE2FileException; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.CreationHelper; import org.apache.poi.ss.usermodel.DateUtil; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.usermodel.Sheet; import org.apache.poi.xssf.usermodel.XSSFCell; import org.apache.poi.xssf.usermodel.XSSFRow; import org.apache.poi.xssf.usermodel.XSSFSheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; /** * 将Excel文件读入到一个List集合中，必须给出“属性”(fields)，会按照给定的属性列表遍历该属性\u0026lt;br /\u0026gt; * 然后调用该属性的set方法赋值 ， 并添加到List集合中 \u0026lt;br /\u0026gt; * 注意:给出的属性应和Excel文件的列一一对应，否则会出现异常 * */ public class ExcelUtil\u0026lt;T\u0026gt; { private File file; private InputStream inputStream; private int ignoreRow = 1;// 忽略的行数 private Class\u0026lt;T\u0026gt; entityClass = null; private String[] fields;// 要写入的字段 private String[] header; private String sheetName = \u0026quot;sheet1\u0026quot;; private String par = \u0026quot;yyyy-MM-dd\u0026quot;; private static final String HSSF = \u0026quot;application/vnd.ms-excel\u0026quot;; private static final String XSSF = \u0026quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\u0026quot;; /** * * @param className * 传入类的包名+类名 * @param fileToBeRead * 要读取的文件 * * @param fields * 要写入的目标类的哪些字段，请按照excel的列的顺序 * @throws ClassNotFoundException * @throws FileNotFoundException */ public ExcelUtil(Class\u0026lt;T\u0026gt; clazz, String filePath, String... fields) throws ClassNotFoundException, FileNotFoundException { init(clazz, new File(filePath), fields); } public ExcelUtil(Class\u0026lt;T\u0026gt; clazz, File file, String... fields) throws ClassNotFoundException, FileNotFoundException { init(clazz, file, fields); } public ExcelUtil(Class\u0026lt;T\u0026gt; clazz, String... fields) throws FileNotFoundException { this.entityClass = clazz; this.fields = fields; } private void init(Class\u0026lt;T\u0026gt; clazz, File file, String... fields) throws FileNotFoundException { this.entityClass = clazz; this.file = file; this.inputStream = new FileInputStream(this.file); this.fields = fields; } /** * 设置工作薄名称 * * @param sheetName */ public void setSheetName(String sheetName) { this.sheetName = sheetName; } /** * 设置头部 * * @param header */ public void setHeader(String[] header) { this.header = header; } public List\u0026lt;T\u0026gt; convertToList() { List\u0026lt;T\u0026gt; list = null; try { list = toList2003(); } catch (Exception e2) { e2.printStackTrace(); try { list = toList2007(); } catch (Exception e1) { e1.printStackTrace(); } } return list; } public List\u0026lt;T\u0026gt; convertToList(String fileType) throws FileNotFoundException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, IOException, NotOLE2FileException { List\u0026lt;T\u0026gt; list = null; try { if (fileType != null \u0026amp;\u0026amp; fileType.equals(HSSF)) { list = toList2003(); } else if (fileType != null \u0026amp;\u0026amp; fileType.equals(XSSF)) { list = toList2007(); } } catch (Exception e) { e.printStackTrace(); } finally { if (inputStream != null) { inputStream.close(); } } return list; } /** * 设置忽略的行数，默认忽略第一行 * * @param ignoreRow * 要忽略的行数，默认忽略第一行 */ public void setIgnoreRow(int ignoreRow) { this.ignoreRow = ignoreRow; } /** * 将excel文件按照用户给定的字段，封装到对象中，并返回一个list集合 适用于2003版本 * * @throws IOException * @throws FileNotFoundException * @throws SecurityException * @throws NoSuchMethodException * @throws InvocationTargetException * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InstantiationException * */ public List\u0026lt;T\u0026gt; toList2003() throws FileNotFoundException, IOException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException { // 创建对工作表的引用。 HSSFWorkbook workbook = new HSSFWorkbook(this.inputStream); HSSFSheet sheet = workbook.getSheetAt(0); // 在Excel文档中，第一张工作表的缺省索引是0， // 用于存储目标对象，excel每一行都是一个实体对象 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); // 创建泛类的实例对象 Constructor\u0026lt;T\u0026gt; constructor = entityClass.getConstructor(); // Field[] objField = entityClass.getFields(); Method[] methods = entityClass.getMethods(); // 读取左上端单元 HSSFRow row = null; for (int i = ignoreRow; sheet.getRow(i) != null; i++) { // 指针指向第i行 row = sheet.getRow(i); T instance = constructor.newInstance(); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; for (Method method : methods) { String methodName = method.getName(); String prefix = methodName.substring(0, 3); String suffix = methodName.substring(3); if (prefix.equals(\u0026quot;set\u0026quot;) \u0026amp;\u0026amp; suffix.equalsIgnoreCase(field)) { HSSFCell cell = null; cell = row.getCell(j); if (cell == null) { continue; } // 单元格类型 int cellType = cell.getCellType(); if (cellType == Cell.CELL_TYPE_NUMERIC) { double value = row.getCell(j).getNumericCellValue(); if (DateUtil.isCellDateFormatted(cell)) { // 日期 Date date = org.apache.poi.ss.usermodel.DateUtil.getJavaDate(value); method.invoke(instance, date); continue; } setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_STRING) { String value = row.getCell(j).getStringCellValue(); setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_FORMULA) { // 公式型 try { double value = cell.getNumericCellValue(); setValue(method, instance, value); } catch (IllegalStateException e) { String value = String.valueOf(cell.getRichStringCellValue()); setValue(method, instance, value); } } } } } list.add(instance); } workbook.close(); return list; } public List\u0026lt;T\u0026gt; toList2007() throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, FileNotFoundException, IOException, NoSuchMethodException, SecurityException, InstantiationException { // 创建对工作表的引用。 XSSFWorkbook workbook = new XSSFWorkbook(this.inputStream); XSSFSheet sheet = workbook.getSheetAt(0); // 在Excel文档中，第一张工作表的缺省索引是0， // 用于存储目标对象，excel每一行都是一个实体对象 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); // 创建泛类的实例对象 Constructor\u0026lt;T\u0026gt; constructor = entityClass.getConstructor(); // Field[] objField = entityClass.getFields(); Method[] methods = entityClass.getMethods(); // 读取左上端单元 XSSFRow row = null; for (int i = ignoreRow; sheet.getRow(i) != null; i++) { // 指针指向第i行 row = sheet.getRow(i); T instance = constructor.newInstance(); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; for (Method method : methods) { String methodName = method.getName(); String prefix = methodName.substring(0, 3); String suffix = methodName.substring(3); if (prefix.equals(\u0026quot;set\u0026quot;) \u0026amp;\u0026amp; suffix.equalsIgnoreCase(field)) { XSSFCell cell = null; cell = row.getCell(j); if (cell == null) { continue; } int cellType = cell.getCellType(); if (cellType == Cell.CELL_TYPE_NUMERIC) { double value = row.getCell(j).getNumericCellValue(); if (DateUtil.isCellDateFormatted(cell)) { // 日期 Date date = org.apache.poi.ss.usermodel.DateUtil.getJavaDate(value); method.invoke(instance, date); continue; } setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_STRING) { String value = row.getCell(j).getStringCellValue(); setValue(method, instance, value); } else if (cellType == Cell.CELL_TYPE_FORMULA) { // 公式型 try { double value = cell.getNumericCellValue(); setValue(method, instance, value); } catch (IllegalStateException e) { String value = String.valueOf(cell.getRichStringCellValue()); setValue(method, instance, value); } } } } } list.add(instance); } workbook.close(); return list; } /** * * 去掉字符串右边的空格 * * @param str * 要处理的字符串 * * @return 处理后的字符串 */ private static String rlTrim(String str) { // 去除ascii 160 if (str.startsWith(\u0026quot; \u0026quot;)) { int startIndex = str.indexOf(\u0026quot; \u0026quot;); str = str.substring(startIndex + 1, str.length()); } if (str.endsWith(\u0026quot; \u0026quot;)) { int endIndex = str.lastIndexOf(\u0026quot; \u0026quot;); str = str.substring(0, endIndex); } // 去除ascii 32 return str.trim(); } /** * 注入值 * * @param method * @param instance * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ private void setValue(Method method, T instance, double value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { Class\u0026lt;?\u0026gt;[] parameterTypes = method.getParameterTypes(); Class\u0026lt;?\u0026gt; class1 = parameterTypes[0]; if (class1.equals(String.class)) { method.invoke(instance, rlTrim(value + \u0026quot;\u0026quot;)); } else if (class1.equals(int.class)) { method.invoke(instance, (int) value); } else if (class1.equals(Integer.class)) { method.invoke(instance, (int) value); } else if (class1.equals(double.class)) { method.invoke(instance, value); } else { method.invoke(instance, value); } } /** * 注入值 * * @param method * @param instance * @param value * @throws IllegalArgumentException * @throws IllegalAccessException * @throws InvocationTargetException */ private void setValue(Method method, T instance, String value) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException { Class\u0026lt;?\u0026gt;[] parameterTypes = method.getParameterTypes(); Class\u0026lt;?\u0026gt; class1 = parameterTypes[0]; if (class1.equals(String.class)) { method.invoke(instance, rlTrim(value)); } else if (class1.equals(int.class)) { method.invoke(instance, Integer.parseInt(value)); } else if (class1.equals(Integer.class)) { method.invoke(instance, Integer.parseInt(value)); } else if (class1.equals(double.class)) { method.invoke(instance, Double.parseDouble(value)); } else { method.invoke(instance, rlTrim(value)); } } private List\u0026lt;T\u0026gt; convertSheetToList(Sheet sheet, Integer ignoreRow, String... fields) throws FileNotFoundException, IOException, NoSuchMethodException, SecurityException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException, ClassNotFoundException { // 用于存储目标对象，excel每一行都是一个实体对象 List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); // 创建泛类的实例对象 Constructor constructor = entityClass.getConstructor(null); Field[] objField = entityClass.getFields(); Method[] methods = entityClass.getMethods(); // 读取左上端单元 Row row = null; for (int i = ignoreRow; sheet.getRow(i) != null; i++) { // 指针指向第i行 row = sheet.getRow(i); T instance = (T) constructor.newInstance(null); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; for (Method method : methods) { String methodName = method.getName(); String prefix = methodName.substring(0, 3); String suffix = methodName.substring(3); if (prefix.equals(\u0026quot;set\u0026quot;) \u0026amp;\u0026amp; suffix.equalsIgnoreCase(field)) { Cell cell = null; cell = row.getCell(j); if (cell == null) { continue; } // 单元格类型 int cellType = cell.getCellType(); if (cellType == HSSFCell.CELL_TYPE_NUMERIC) { double value = row.getCell(j).getNumericCellValue(); Type[] types = method.getGenericParameterTypes(); for (Type type : types) { String parameterName = ((Class) type).getSimpleName(); if (parameterName.equals(\u0026quot;String\u0026quot;)) { method.invoke(instance, rlTrim((int) value + \u0026quot;\u0026quot;)); } else if (parameterName.equals(\u0026quot;int\u0026quot;)) { method.invoke(instance, (int) value); } else if (parameterName.equals(\u0026quot;Integer\u0026quot;)) { method.invoke(instance, (int) value); } else if (parameterName.equalsIgnoreCase(\u0026quot;double\u0026quot;)) { method.invoke(instance, value); } else { method.invoke(instance, value); } } } else if (cellType == HSSFCell.CELL_TYPE_STRING) { String value = row.getCell(j).getStringCellValue(); Type[] types = method.getGenericParameterTypes(); for (Type type : types) { String parameterName = ((Class) type).getSimpleName(); if (parameterName.equals(\u0026quot;String\u0026quot;)) { method.invoke(instance, rlTrim(value)); } else if (parameterName.equals(\u0026quot;int\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else if (parameterName.equals(\u0026quot;Integer\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else if (parameterName.equalsIgnoreCase(\u0026quot;double\u0026quot;)) { method.invoke(instance, Double.parseDouble(value)); } else { method.invoke(instance, rlTrim(value)); } } } else if (cellType == HSSFCell.CELL_TYPE_FORMULA) { // 公式型 String value = \u0026quot;\u0026quot;; try { value = String.valueOf(cell.getNumericCellValue()); } catch (IllegalStateException e) { value = String.valueOf(cell.getRichStringCellValue()); } Type[] types = method.getGenericParameterTypes(); for (Type type : types) { String parameterName = ((Class) type).getSimpleName(); if (parameterName.equals(\u0026quot;String\u0026quot;)) { method.invoke(instance, rlTrim(value)); } else if (parameterName.equals(\u0026quot;int\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else if (parameterName.equals(\u0026quot;Integer\u0026quot;)) { method.invoke(instance, Integer.parseInt(value)); } else { method.invoke(instance, rlTrim(value)); } } } } } } list.add(instance); } return list; } /** * List 转Excel * * @return * @throws SecurityException * @throws NoSuchFieldException * @throws IllegalAccessException * @throws IllegalArgumentException */ public ByteArrayOutputStream convertList2Excel(List\u0026lt;T\u0026gt; list) throws NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException { HSSFWorkbook workbook = new HSSFWorkbook(); HSSFSheet sheet = workbook.createSheet(sheetName); // 创建表头 int index = 0; if (header != null) { HSSFRow row = sheet.createRow(index); for (int i = 0; i \u0026lt; header.length; i++) { HSSFCell cell = row.createCell(i); cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue(header[i]); } index++; } for (int i = 0; i \u0026lt; list.size(); i++) { HSSFRow row = sheet.createRow(i + index); T instance = list.get(i); for (int j = 0; j \u0026lt; fields.length; j++) { String field = fields[j]; Field entityField = entityClass.getDeclaredField(field); if (!entityField.isAccessible()) { entityField.setAccessible(true); } Cell cell = row.createCell(j); Object object = entityField.get(instance); if (object instanceof String) { cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue((String) object); } if (object instanceof Double) { cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC); Double num = (double) object; if (num != 0) { cell.setCellValue(num); } else { cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue(\u0026quot;\u0026quot;); } } if (object instanceof Float) { cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC); cell.setCellValue((float) object); } if (object instanceof Integer) { cell.setCellType(HSSFCell.CELL_TYPE_NUMERIC); cell.setCellValue((int) object); } if (object instanceof Date) { cell.setCellType(HSSFCell.CELL_TYPE_STRING); cell.setCellValue((Date) object); CreationHelper createHelper = workbook.getCreationHelper(); CellStyle cellStyle = workbook.createCellStyle(); cellStyle.setDataFormat(createHelper.createDataFormat().getFormat(par)); cell.setCellStyle(cellStyle); } } } ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); try { workbook.write(outputStream); workbook.close(); } catch (IOException e) { e.printStackTrace(); } return outputStream; } public void setPar(String par) { this.par = par; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/exceltohtmlutil/",
	"title": "Excel转换html",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.apache.poi.hssf.usermodel.*; import org.apache.poi.hssf.util.HSSFColor; import org.apache.poi.ss.usermodel.*; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.usermodel.XSSFCellStyle; import org.apache.poi.xssf.usermodel.XSSFColor; import org.apache.poi.xssf.usermodel.XSSFFont; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.text.DecimalFormat; import java.text.SimpleDateFormat; import java.util.Date; import java.util.HashMap; import java.util.Map; /** * @功能描述 POI 读取 Excel 转 HTML 支持 03xls 和 07xlsx 版本 包含样式 * @author Devil * @创建时间 2015/4/19 21:34 */ public class ExcelToHtmlUtil { /** * 程序入口方法 * @param filePath 文件的路径 * @param isWithStyle 是否需要表格样式 包含 字体 颜色 边框 对齐方式 * @return \u0026lt;table\u0026gt;...\u0026lt;/table\u0026gt; 字符串 */ public String readExcelToHtml(String filePath , boolean isWithStyle){ InputStream is = null; String htmlExcel = null; try { File sourcefile = new File(filePath); is = new FileInputStream(sourcefile); Workbook wb = WorkbookFactory.create(is); if (wb instanceof XSSFWorkbook) { XSSFWorkbook xWb = (XSSFWorkbook) wb; htmlExcel = ExcelToHtmlUtil.getExcelInfo(xWb,isWithStyle); }else if(wb instanceof HSSFWorkbook){ HSSFWorkbook hWb = (HSSFWorkbook) wb; htmlExcel = ExcelToHtmlUtil.getExcelInfo(hWb,isWithStyle); } } catch (Exception e) { e.printStackTrace(); }finally{ try { is.close(); } catch (IOException e) { e.printStackTrace(); } } return htmlExcel; } public static String xSSFWorkbookToHtml(HSSFWorkbook wb,boolean isWithStyle) { return ExcelToHtmlUtil.getExcelInfo(wb,isWithStyle); } public static String getExcelInfo(Workbook wb,boolean isWithStyle){ StringBuffer sb = new StringBuffer(); Sheet sheet = wb.getSheetAt(0);//获取第一个Sheet的内容 int lastRowNum = sheet.getLastRowNum(); Map\u0026lt;String, String\u0026gt; map[] = getRowSpanColSpanMap(sheet); sb.append(\u0026quot;\u0026lt;table style='border-collapse:collapse;' width='100%'\u0026gt;\u0026quot;); Row row = null; //兼容 Cell cell = null; //兼容 for (int rowNum = sheet.getFirstRowNum(); rowNum \u0026lt;= lastRowNum; rowNum++) { row = sheet.getRow(rowNum); if (row == null) { sb.append(\u0026quot;\u0026lt;tr\u0026gt;\u0026lt;td \u0026gt; \u0026amp;nbsp;\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt;\u0026quot;); continue; } sb.append(\u0026quot;\u0026lt;tr\u0026gt;\u0026quot;); int lastColNum = row.getLastCellNum(); for (int colNum = 0; colNum \u0026lt; lastColNum; colNum++) { cell = row.getCell(colNum); if (cell == null) { //特殊情况 空白的单元格会返回null sb.append(\u0026quot;\u0026lt;td\u0026gt;\u0026amp;nbsp;\u0026lt;/td\u0026gt;\u0026quot;); continue; } String stringValue = getCellValue(cell); if (map[0].containsKey(rowNum + \u0026quot;,\u0026quot; + colNum)) { String pointString = map[0].get(rowNum + \u0026quot;,\u0026quot; + colNum); map[0].remove(rowNum + \u0026quot;,\u0026quot; + colNum); int bottomeRow = Integer.valueOf(pointString.split(\u0026quot;,\u0026quot;)[0]); int bottomeCol = Integer.valueOf(pointString.split(\u0026quot;,\u0026quot;)[1]); int rowSpan = bottomeRow - rowNum + 1; int colSpan = bottomeCol - colNum + 1; sb.append(\u0026quot;\u0026lt;td rowspan= '\u0026quot; + rowSpan + \u0026quot;' colspan= '\u0026quot;+ colSpan + \u0026quot;' \u0026quot;); } else if (map[1].containsKey(rowNum + \u0026quot;,\u0026quot; + colNum)) { map[1].remove(rowNum + \u0026quot;,\u0026quot; + colNum); continue; } else { sb.append(\u0026quot;\u0026lt;td \u0026quot;); } //判断是否需要样式 if(isWithStyle){ dealExcelStyle(wb, sheet, cell, sb);//处理单元格样式 } sb.append(\u0026quot;\u0026gt;\u0026quot;); if (stringValue == null || \u0026quot;\u0026quot;.equals(stringValue.trim())) { sb.append(\u0026quot; \u0026amp;nbsp; \u0026quot;); } else { // 将ascii码为160的空格转换为html下的空格（\u0026amp;nbsp;） sb.append(stringValue.replace(String.valueOf((char) 160),\u0026quot;\u0026amp;nbsp;\u0026quot;)); } sb.append(\u0026quot;\u0026lt;/td\u0026gt;\u0026quot;); } sb.append(\u0026quot;\u0026lt;/tr\u0026gt;\u0026quot;); } sb.append(\u0026quot;\u0026lt;/table\u0026gt;\u0026quot;); return sb.toString(); } private static Map\u0026lt;String, String\u0026gt;[] getRowSpanColSpanMap(Sheet sheet) { Map\u0026lt;String, String\u0026gt; map0 = new HashMap\u0026lt;String, String\u0026gt;(); Map\u0026lt;String, String\u0026gt; map1 = new HashMap\u0026lt;String, String\u0026gt;(); int mergedNum = sheet.getNumMergedRegions(); CellRangeAddress range = null; for (int i = 0; i \u0026lt; mergedNum; i++) { range = sheet.getMergedRegion(i); int topRow = range.getFirstRow(); int topCol = range.getFirstColumn(); int bottomRow = range.getLastRow(); int bottomCol = range.getLastColumn(); map0.put(topRow + \u0026quot;,\u0026quot; + topCol, bottomRow + \u0026quot;,\u0026quot; + bottomCol); // System.out.println(topRow + \u0026quot;,\u0026quot; + topCol + \u0026quot;,\u0026quot; + bottomRow + \u0026quot;,\u0026quot; + bottomCol); int tempRow = topRow; while (tempRow \u0026lt;= bottomRow) { int tempCol = topCol; while (tempCol \u0026lt;= bottomCol) { map1.put(tempRow + \u0026quot;,\u0026quot; + tempCol, \u0026quot;\u0026quot;); tempCol++; } tempRow++; } map1.remove(topRow + \u0026quot;,\u0026quot; + topCol); } Map[] map = { map0, map1 }; return map; } /** * 获取表格单元格Cell内容 * @param cell * @return */ private static String getCellValue(Cell cell) { String result = new String(); switch (cell.getCellType()) { case Cell.CELL_TYPE_NUMERIC:// 数字类型 if (HSSFDateUtil.isCellDateFormatted(cell)) {// 处理日期格式、时间格式 SimpleDateFormat sdf = null; if (cell.getCellStyle().getDataFormat() == HSSFDataFormat.getBuiltinFormat(\u0026quot;h:mm\u0026quot;)) { sdf = new SimpleDateFormat(\u0026quot;HH:mm\u0026quot;); } else {// 日期 sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); } Date date = cell.getDateCellValue(); result = sdf.format(date); } else if (cell.getCellStyle().getDataFormat() == 58) { // 处理自定义日期格式：m月d日(通过判断单元格的格式id解决，id的值是58) SimpleDateFormat sdf = new SimpleDateFormat(\u0026quot;yyyy-MM-dd\u0026quot;); double value = cell.getNumericCellValue(); Date date = org.apache.poi.ss.usermodel.DateUtil .getJavaDate(value); result = sdf.format(date); } else { double value = cell.getNumericCellValue(); CellStyle style = cell.getCellStyle(); DecimalFormat format = new DecimalFormat(); String temp = style.getDataFormatString(); // 单元格设置成常规 if (temp.equals(\u0026quot;General\u0026quot;)) { format.applyPattern(\u0026quot;#\u0026quot;); } result = format.format(value); } break; case Cell.CELL_TYPE_STRING:// String类型 result = cell.getRichStringCellValue().toString(); break; case Cell.CELL_TYPE_BLANK: result = \u0026quot;\u0026quot;; break; default: result = \u0026quot;\u0026quot;; break; } return result; } /** * 处理表格样式 * @param wb * @param sheet * @param cell * @param sb */ private static void dealExcelStyle(Workbook wb,Sheet sheet,Cell cell,StringBuffer sb){ CellStyle cellStyle = cell.getCellStyle(); if (cellStyle != null) { short alignment = cellStyle.getAlignment(); sb.append(\u0026quot;align='\u0026quot; + convertAlignToHtml(alignment) + \u0026quot;' \u0026quot;);//单元格内容的水平对齐方式 short verticalAlignment = cellStyle.getVerticalAlignment(); sb.append(\u0026quot;valign='\u0026quot;+ convertVerticalAlignToHtml(verticalAlignment)+ \u0026quot;' \u0026quot;);//单元格中内容的垂直排列方式 if (wb instanceof XSSFWorkbook) { XSSFFont xf = ((XSSFCellStyle) cellStyle).getFont(); short boldWeight = xf.getBoldweight(); sb.append(\u0026quot;style='\u0026quot;); sb.append(\u0026quot;font-weight:\u0026quot; + boldWeight + \u0026quot;;\u0026quot;); // 字体加粗 sb.append(\u0026quot;font-size: \u0026quot; + xf.getFontHeight() / 2 + \u0026quot;%;\u0026quot;); // 字体大小 int columnWidth = sheet.getColumnWidth(cell.getColumnIndex()) ; sb.append(\u0026quot;width:\u0026quot; + columnWidth + \u0026quot;px;\u0026quot;); XSSFColor xc = xf.getXSSFColor(); if (xc != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(xc)) { sb.append(\u0026quot;color:#\u0026quot; + xc.getARGBHex().substring(2) + \u0026quot;;\u0026quot;); // 字体颜色 } XSSFColor bgColor = (XSSFColor) cellStyle.getFillForegroundColorColor(); //System.out.println(\u0026quot;************************************\u0026quot;); //System.out.println(\u0026quot;BackgroundColorColor: \u0026quot;+cellStyle.getFillBackgroundColorColor()); //System.out.println(\u0026quot;ForegroundColor: \u0026quot;+cellStyle.getFillForegroundColor());//0 //System.out.println(\u0026quot;BackgroundColorColor: \u0026quot;+cellStyle.getFillBackgroundColorColor()); //System.out.println(\u0026quot;ForegroundColorColor: \u0026quot;+cellStyle.getFillForegroundColorColor()); //String bgColorStr = bgColor.getARGBHex(); //System.out.println(\u0026quot;bgColorStr: \u0026quot;+bgColorStr); if (bgColor != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(bgColor)) { sb.append(\u0026quot;background-color:#\u0026quot; + bgColor.getARGBHex().substring(2) + \u0026quot;;\u0026quot;); // 背景颜色 } sb.append(getBorderStyle(0,cellStyle.getBorderTop(), ((XSSFCellStyle) cellStyle).getTopBorderXSSFColor())); sb.append(getBorderStyle(1,cellStyle.getBorderRight(), ((XSSFCellStyle) cellStyle).getRightBorderXSSFColor())); sb.append(getBorderStyle(2,cellStyle.getBorderBottom(), ((XSSFCellStyle) cellStyle).getBottomBorderXSSFColor())); sb.append(getBorderStyle(3,cellStyle.getBorderLeft(), ((XSSFCellStyle) cellStyle).getLeftBorderXSSFColor())); }else if(wb instanceof HSSFWorkbook){ HSSFFont hf = ((HSSFCellStyle) cellStyle).getFont(wb); short boldWeight = hf.getBoldweight(); short fontColor = hf.getColor(); sb.append(\u0026quot;style='\u0026quot;); HSSFPalette palette = ((HSSFWorkbook) wb).getCustomPalette(); // 类HSSFPalette用于求的颜色的国际标准形式 HSSFColor hc = palette.getColor(fontColor); sb.append(\u0026quot;font-weight:\u0026quot; + boldWeight + \u0026quot;;\u0026quot;); // 字体加粗 sb.append(\u0026quot;font-size: \u0026quot; + hf.getFontHeight() / 2 + \u0026quot;%;\u0026quot;); // 字体大小 String fontColorStr = convertToStardColor(hc); if (fontColorStr != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(fontColorStr.trim())) { sb.append(\u0026quot;color:\u0026quot; + fontColorStr + \u0026quot;;\u0026quot;); // 字体颜色 } int columnWidth = sheet.getColumnWidth(cell.getColumnIndex()) ; sb.append(\u0026quot;width:\u0026quot; + columnWidth + \u0026quot;px;\u0026quot;); short bgColor = cellStyle.getFillForegroundColor(); hc = palette.getColor(bgColor); String bgColorStr = convertToStardColor(hc); if (bgColorStr != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(bgColorStr.trim())) { sb.append(\u0026quot;background-color:\u0026quot; + bgColorStr + \u0026quot;;\u0026quot;); // 背景颜色 } sb.append( getBorderStyle(palette,0,cellStyle.getBorderTop(),cellStyle.getTopBorderColor())); sb.append( getBorderStyle(palette,1,cellStyle.getBorderRight(),cellStyle.getRightBorderColor())); sb.append( getBorderStyle(palette,3,cellStyle.getBorderLeft(),cellStyle.getLeftBorderColor())); sb.append( getBorderStyle(palette,2,cellStyle.getBorderBottom(),cellStyle.getBottomBorderColor())); } sb.append(\u0026quot;' \u0026quot;); } } /** * 单元格内容的水平对齐方式 * @param alignment * @return */ private static String convertAlignToHtml(short alignment) { String align = \u0026quot;left\u0026quot;; switch (alignment) { case CellStyle.ALIGN_LEFT: align = \u0026quot;left\u0026quot;; break; case CellStyle.ALIGN_CENTER: align = \u0026quot;center\u0026quot;; break; case CellStyle.ALIGN_RIGHT: align = \u0026quot;right\u0026quot;; break; default: break; } return align; } /** * 单元格中内容的垂直排列方式 * @param verticalAlignment * @return */ private static String convertVerticalAlignToHtml(short verticalAlignment) { String valign = \u0026quot;middle\u0026quot;; switch (verticalAlignment) { case CellStyle.VERTICAL_BOTTOM: valign = \u0026quot;bottom\u0026quot;; break; case CellStyle.VERTICAL_CENTER: valign = \u0026quot;center\u0026quot;; break; case CellStyle.VERTICAL_TOP: valign = \u0026quot;top\u0026quot;; break; default: break; } return valign; } private static String convertToStardColor(HSSFColor hc) { StringBuffer sb = new StringBuffer(\u0026quot;\u0026quot;); if (hc != null) { if (HSSFColor.AUTOMATIC.index == hc.getIndex()) { return null; } sb.append(\u0026quot;#\u0026quot;); for (int i = 0; i \u0026lt; hc.getTriplet().length; i++) { sb.append(fillWithZero(Integer.toHexString(hc.getTriplet()[i]))); } } return sb.toString(); } private static String fillWithZero(String str) { if (str != null \u0026amp;\u0026amp; str.length() \u0026lt; 2) { return \u0026quot;0\u0026quot; + str; } return str; } static String[] bordesr={\u0026quot;border-top:\u0026quot;,\u0026quot;border-right:\u0026quot;,\u0026quot;border-bottom:\u0026quot;,\u0026quot;border-left:\u0026quot;}; static String[] borderStyles={\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid \u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;,\u0026quot;solid\u0026quot;}; private static String getBorderStyle( HSSFPalette palette ,int b,short s, short t){ if(s==0)return bordesr[b]+borderStyles[s]+\u0026quot;#d0d7e5 1px;\u0026quot;;; String borderColorStr = convertToStardColor( palette.getColor(t)); borderColorStr=borderColorStr==null|| borderColorStr.length()\u0026lt;1?\u0026quot;#000000\u0026quot;:borderColorStr; return bordesr[b]+borderStyles[s]+borderColorStr+\u0026quot; 1px;\u0026quot;; } private static String getBorderStyle(int b,short s, XSSFColor xc){ if(s==0)return bordesr[b]+borderStyles[s]+\u0026quot;#d0d7e5 1px;\u0026quot;;; if (xc != null \u0026amp;\u0026amp; !\u0026quot;\u0026quot;.equals(xc)) { String borderColorStr = xc.getARGBHex();//t.getARGBHex(); borderColorStr=borderColorStr==null|| borderColorStr.length()\u0026lt;1?\u0026quot;#000000\u0026quot;:borderColorStr.substring(2); return bordesr[b]+borderStyles[s]+borderColorStr+\u0026quot; 1px;\u0026quot;; } return \u0026quot;\u0026quot;; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/geoserver/",
	"title": "Geoserver",
	"tags": [],
	"description": "",
	"content": "下载地址提取码：300y 通过geoserver远程发布\n import it.geosolutions.geoserver.rest.GeoServerRESTManager; import it.geosolutions.geoserver.rest.GeoServerRESTPublisher; import it.geosolutions.geoserver.rest.GeoServerRESTReader; import org.apache.commons.httpclient.NameValuePair; import java.io.File; import java.net.MalformedURLException; import java.net.URL; public class GeoServerUtil { public static final String RESTURL; public static final String RESTUSER; public static final String RESTPW; public static final String GS_VERSION; public static java.net.URL URL; public static GeoServerRESTManager manager; public static GeoServerRESTReader reader; public static GeoServerRESTPublisher publisher; // private static ResourceBundle bundle = ResourceBundle.getBundle(\u0026quot;constant\u0026quot;); //初始化用户名密码赋值,发布图集时会进行身份认证 static { RESTURL = getenv(\u0026quot;gsmgr_resturl\u0026quot;, \u0026quot;http://localhost:6060/geoserver/\u0026quot;); RESTUSER = getenv(\u0026quot;gsmgr_restuser\u0026quot;,\u0026quot;admin\u0026quot;); RESTPW = getenv(\u0026quot;gsmgr_restpw\u0026quot;, \u0026quot;geoserver\u0026quot;); GS_VERSION = getenv(\u0026quot;gsmgr_version\u0026quot;, \u0026quot;2.8.2\u0026quot;); try { URL = new URL(RESTURL); manager = new GeoServerRESTManager(URL, RESTUSER, RESTPW); reader = manager.getReader(); publisher = manager.getPublisher(); } catch (MalformedURLException e) { e.printStackTrace(); } } //获取环境信息 private static String getenv(String envName, String envDefault) { String env = System.getenv(envName); String prop = System.getProperty(envName, env); return prop != null ? prop : envDefault; } public static boolean publishShpAndReloadStore(String workspace,String zipFilePath,String coordinateSystem) throws Exception{ //坐标系,判断是否为空 if(ComUtil.isEmpty(coordinateSystem)){ coordinateSystem= GeoServerRESTPublisher.DEFAULT_CRS; } //存在相应的工作区 if(!reader.existsWorkspace(workspace)){ publisher.createWorkspace(workspace); } boolean published; /* if(Constant.AtlasStyleType.ATLAS_STYLE_TYPE_5.equals(styleType)){*/ /* published = publisher.publishShp(workspace, storeName, layerName, new File(zipFilePath),coordinateSystem, new NameValuePair[]{new NameValuePair(\u0026quot;charset\u0026quot;, \u0026quot;GBK\u0026quot;)});*/ //published = publisher.publishGeoTIFF(workspace,storeName,new File(zipFilePath)); String name = new File(zipFilePath).getName(); name = name.substring(0,name.lastIndexOf(\u0026quot;.\u0026quot;)); published = publisher.publishShp(workspace,name,name,new File(zipFilePath),coordinateSystem,new NameValuePair[]{new NameValuePair(\u0026quot;charset\u0026quot;, \u0026quot;ISO8859-1\u0026quot;)}); return published; } public static boolean publishTifAndReloadStore(String workspace,String zipFilePath,String storeName) throws Exception{ //存在相应的工作区 if(!reader.existsWorkspace(workspace)){ publisher.createWorkspace(workspace); } boolean published; published = publisher.publishGeoTIFF(workspace,storeName,new File(zipFilePath)); return published; } public static boolean unPublishShpAndReloadStore(String workspace,String storeName){ return publisher.removeLayer(workspace,storeName); } public static void main(String[] args) { try { //boolean b = GeoServerUtil.publishShpAndReloadStore(\u0026quot;testshp\u0026quot;,\u0026quot;H:\\\\下载\\\\shp矢量文件\\\\test.zip\u0026quot;,\u0026quot;shpstore\u0026quot;,\u0026quot;shplayer\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;EPSG:4326\u0026quot;); boolean b = GeoServerUtil.publishTifAndReloadStore(\u0026quot;testtif\u0026quot;,\u0026quot;C:test.tif\u0026quot;,\u0026quot;tifjava03\u0026quot;); // boolean b = GeoServerUtil.publishShpAndReloadStore(\u0026quot;testshp\u0026quot;,\u0026quot;D:\\\\PeterHan\\\\test.zip\u0026quot;,\u0026quot;shp0123\u0026quot;,\u0026quot;shp0123\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;\u0026quot;); // System.out.print(b); } catch (Exception e) { e.printStackTrace(); } //HTTPUtils.post(\u0026quot;http://localhost:8080/geoserver/rest/workspaces/testshp/datastores/shpstore/file.shp\u0026quot;,\u0026quot;\u0026lt;featureType\u0026gt;\u0026lt;enabled\u0026gt;true\u0026lt;/enabled\u0026gt;\u0026lt;metadata /\u0026gt;\u0026lt;keywords /\u0026gt;\u0026lt;metadataLinks /\u0026gt;\u0026lt;attributes /\u0026gt;\u0026lt;name\u0026gt;shplayer\u0026lt;/name\u0026gt;\u0026lt;title\u0026gt;shplayer\u0026lt;/title\u0026gt;\u0026lt;srs\u0026gt;EPSG:4326\u0026lt;/srs\u0026gt;\u0026lt;projectionPolicy\u0026gt;FORCE_DECLARED\u0026lt;/projectionPolicy\u0026gt;\u0026lt;/featureType\u0026gt;\u0026quot;,\u0026quot;application/xml\u0026quot;,\u0026quot;admin\u0026quot;,\u0026quot;geoserver\u0026quot;); try { /* String url = XmlUtil.getMapUrl(\u0026quot;bh_bhtb\u0026quot;,\u0026quot;testshp\u0026quot;,\u0026quot;shp\u0026quot;); System.out.print(url);*/ } catch (Exception e) { e.printStackTrace(); } } }  解析发布后信息\n import com.nuclear_Project.image.bean.ImageServer; import org.dom4j.Document; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.File; import java.io.IOException; import java.math.BigDecimal; import java.util.Iterator; /** * \u0026lt;p\u0026gt; * xml解析工具类 * \u0026lt;/p\u0026gt; * * @author liugh * @since 2018/4/3 */ public class XmlUtil { private static String GEO_SERVER_PATH=\u0026quot;D:\\\\Program Files (x86)\\\\GeoServer 2.8.2\\\\data_dir\\\\workspaces\u0026quot;; private static String BUNDLE_URL = \u0026quot;http://localhost:6060/geoserver/\u0026quot;; private static String XML_ELEMENT_NAME=\u0026quot;latLonBoundingBox\u0026quot;; /*public static void main(String[] args)throws Exception { getMapUrl(\u0026quot;1522723368940\u0026quot;,\u0026quot;unitMap\u0026quot;); }*/ //获取图集发布地址 public static String getMapUrl(String layerId, String workspace, String type, ImageServer server)throws Exception{ File file =new File(GEO_SERVER_PATH+File.separator+workspace); String[] fileList = file.list(); StringBuilder mapUrl = new StringBuilder(); mapUrl.append(BUNDLE_URL+workspace) .append(\u0026quot;/wms?service=WMS\u0026amp;version=1.1.0\u0026amp;request=GetMap\u0026amp;layers=\u0026quot;).append(workspace+\u0026quot;:\u0026quot;+layerId).append(\u0026quot;\u0026amp;styles=\u0026amp;bbox=\u0026quot;); if(!ComUtil.isEmpty(fileList)){ for (String fileName:fileList) { if(fileName.equals(layerId)){ String [] coordinates = readXMLDocument(layerId,workspace,type); mapUrl.append(coordinates[0]+\u0026quot;,\u0026quot;+coordinates[2]+\u0026quot;,\u0026quot;+coordinates[1]+\u0026quot;,\u0026quot;+coordinates[3]).append(\u0026quot;\u0026amp;width=768\u0026amp;height=437\u0026amp;srs=\u0026quot;).append(coordinates[4]); server.setNwlong(new BigDecimal(coordinates[0])); server.setNwlat(new BigDecimal(coordinates[2])); server.setSelong(new BigDecimal(coordinates[1])); server.setSelat(new BigDecimal(coordinates[3])); } } }else{ return null; } mapUrl.append(\u0026quot;\u0026amp;format=application/openlayers\u0026quot;); return mapUrl.toString(); } private static String [] readXMLDocument(String layerId, String workspace,String type){ String str=\u0026quot;\u0026quot;; if(type.equalsIgnoreCase(\u0026quot;tif\u0026quot;)||type.equalsIgnoreCase(\u0026quot;tiff\u0026quot;)){ str=\u0026quot;coverage.xml\u0026quot;; }else if(type.equals(\u0026quot;shp\u0026quot;)){ str=\u0026quot;featuretype.xml\u0026quot;; } File file = new File(GEO_SERVER_PATH+File.separator+workspace+ File.separator+layerId+File.separator+layerId+File.separator+str); if (!file.exists()) { try { throw new IOException(\u0026quot;Can't find the path\u0026quot;); } catch (IOException e) { e.printStackTrace(); } } //创建SAXReader对象 SAXReader saxReader = new SAXReader(); Document document; try { //读取文件 转换成Document document = saxReader.read(file); //获取根节点元素对象 遍历当前节点下的所有节点 for (Iterator iter = document.getRootElement().elementIterator(); iter.hasNext();){ //获取节点 Element e1 = (Element) iter.next(); //如果过节点的名称等于beanName那么继续进入循环读取beanName节点下的所有节点 if(e1.getName().equalsIgnoreCase(XML_ELEMENT_NAME)){ String [] ss = new String[5]; int i =0; //遍历beanName当前节点下的所有节点 for (Iterator iter1 = e1.elementIterator(); iter1.hasNext();){ Element e2 = (Element) iter1.next(); ss[i]= e2.getStringValue(); i++; } return ss; } } } catch (DocumentException e) { e.printStackTrace(); return null; } return null; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/",
	"title": "Gis相关工具类",
	"tags": [],
	"description": "",
	"content": " Gis相关工具类 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/html2image/",
	"title": "Html转换Image",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.xuwei-k\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;html2image\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import gui.ava.html.image.generator.HtmlImageGenerator; public class Html2Image { public static void main(String[] args){ HtmlImageGenerator imageGenerator = new HtmlImageGenerator(); String htmlstr = \u0026quot;\u0026quot;; imageGenerator.loadHtml(htmlstr); imageGenerator.getBufferedImage(); imageGenerator.saveAsImage(\u0026quot;d:/hello-world.png\u0026quot;); imageGenerator.saveAsHtmlWithMap(\u0026quot;hello-world.html\u0026quot;, \u0026quot;hello-world.png\u0026quot;); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/jsonutil/",
	"title": "Json工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.codehaus.jackson\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-mapper-asl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.8.7\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.codehaus.jackson.map.ObjectMapper; public class JsonUtil { private static ObjectMapper mapper; private static ObjectMapper getMapper(){ if (mapper == null) { mapper = new ObjectMapper(); } return mapper; } public static String toJson(Object obj) { String str = null; try { str = getMapper().writeValueAsString(obj); } catch (Exception e) { e.printStackTrace(); } return str; } public static \u0026lt;T\u0026gt; T toObj(String json,Class\u0026lt;T\u0026gt; clazz) { try { T obj = getMapper().readValue(json, clazz); return obj; } catch (Exception e) { e.printStackTrace(); } return null; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/kml%E5%AF%BC%E5%85%A5/",
	"title": "Kml导入",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.micromata.jak\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;JavaAPIforKml\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;dom4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;dom4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import com.nuclear_Project.common.util.FileUtil; import com.nuclear_Project.specificObjective.bean.KmlLine; import com.nuclear_Project.specificObjective.bean.KmlPoint; import com.nuclear_Project.specificObjective.bean.KmlPolygon; import com.nuclear_Project.specificObjective.bean.KmlProperty; import de.micromata.opengis.kml.v_2_2_0.*; import org.apache.commons.io.FilenameUtils; import org.apache.commons.io.IOUtils; import org.dom4j.DocumentException; import org.dom4j.Element; import org.dom4j.io.SAXReader; import java.io.*; import java.math.BigDecimal; import java.util.ArrayList; import java.util.Iterator; import java.util.List; public class ParsingKmlUtil { //以下三行都是自定义的KML类，用于获取名称name、所有点points、样式颜色color private List\u0026lt;KmlPoint\u0026gt; kmlPointList = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;KmlLine\u0026gt; kmlLineList = new ArrayList\u0026lt;\u0026gt;(); private List\u0026lt;KmlPolygon\u0026gt; kmlPolygonList = new ArrayList\u0026lt;\u0026gt;(); private KmlProperty kmlProperty = new KmlProperty(); /** * 保存kml数据到临时表 * * @param file 上传的文件实体 * @return 自定义的KML文件实体 */ public KmlProperty parseKmlForJAK(File file) throws FileNotFoundException { ByteArrayOutputStream outputStream = new ByteArrayOutputStream(); BufferedReader reader = new BufferedReader( new FileReader(file)); try { IOUtils.copy(reader,outputStream,\u0026quot;UTF-8\u0026quot;); } catch (IOException e) { e.printStackTrace(); } Kml kml = Kml.unmarshal(outputStream.toString()); Feature feature = kml.getFeature(); parseFeature(feature); kmlProperty.setKmlPoints(kmlPointList); kmlProperty.setKmlLines(kmlLineList); kmlProperty.setKmlPolygons(kmlPolygonList); return kmlProperty; } /** * 解析kml节点信息 * * @param feature 需要解析到要素信息 * @return */ private void parseFeature(Feature feature) { if (feature != null) { //判断根节点是否为Document if (feature instanceof Document) { List\u0026lt;Feature\u0026gt; featureList = ((Document) feature).getFeature(); //遍历已获取的节点信息(节点信息为List)，将list使用forEach进行遍历（同for、while） featureList.forEach(documentFeature -\u0026gt; { //判断遍历节点是否为PlaceMark，否则迭代解析 if (documentFeature instanceof Placemark) { getPlaceMark((Placemark) documentFeature); } else { parseFeature(documentFeature); } } ); } else if (feature instanceof Folder) { //原理同上 List\u0026lt;Feature\u0026gt; featureList = ((Folder) feature).getFeature(); featureList.forEach(documentFeature -\u0026gt; { if (documentFeature instanceof Placemark) { getPlaceMark((Placemark) documentFeature); } { parseFeature(documentFeature); } } ); } } } /** * 解析PlaceMark节点下的信息 * * @return */ private void getPlaceMark(Placemark placemark) { Geometry geometry = placemark.getGeometry(); String name = placemark.getName(); parseGeometry(name, geometry); } /** * 解析PlaceMark节点下的信息 * * @return */ private void parseGeometry(String name, Geometry geometry) { if (geometry != null) { if (geometry instanceof Polygon) { Polygon polygon = (Polygon) geometry; Boundary outerBoundaryIs = polygon.getOuterBoundaryIs(); if (outerBoundaryIs != null) { LinearRing linearRing = outerBoundaryIs.getLinearRing(); if (linearRing != null) { List\u0026lt;Coordinate\u0026gt; coordinates = linearRing.getCoordinates(); if (coordinates != null) { outerBoundaryIs = ((Polygon) geometry).getOuterBoundaryIs(); addPolygonToList(kmlPolygonList, name, outerBoundaryIs); } } } } else if (geometry instanceof LineString) { LineString lineString = (LineString) geometry; List\u0026lt;Coordinate\u0026gt; coordinates = lineString.getCoordinates(); if (coordinates != null) { coordinates = ((LineString) geometry).getCoordinates(); addLineStringToList(kmlLineList, coordinates, name); } } else if (geometry instanceof Point) { Point point = (Point) geometry; List\u0026lt;Coordinate\u0026gt; coordinates = point.getCoordinates(); if (coordinates != null) { coordinates = ((Point) geometry).getCoordinates(); addPointToList(kmlPointList, coordinates, name); } } else if (geometry instanceof MultiGeometry) { List\u0026lt;Geometry\u0026gt; geometries = ((MultiGeometry) geometry).getGeometry(); for (Geometry geometryToMult : geometries) { Boundary outerBoundaryIs; List\u0026lt;Coordinate\u0026gt; coordinates; if (geometryToMult instanceof Point) { coordinates = ((Point) geometryToMult).getCoordinates(); addPointToList(kmlPointList, coordinates, name); } else if (geometryToMult instanceof LineString) { coordinates = ((LineString) geometryToMult).getCoordinates(); addLineStringToList(kmlLineList, coordinates, name); } else if (geometryToMult instanceof Polygon) { outerBoundaryIs = ((Polygon) geometryToMult).getOuterBoundaryIs(); addPolygonToList(kmlPolygonList, name, outerBoundaryIs); } } } } } /** * 将kml中所有面添加到一个list * * @return */ private void addPolygonToList(List\u0026lt;KmlPolygon\u0026gt; kmlPolygonList, String name, Boundary outerBoundaryIs) { LinearRing linearRing; List\u0026lt;Coordinate\u0026gt; coordinates; linearRing = outerBoundaryIs.getLinearRing();//面 coordinates = linearRing.getCoordinates(); KmlPolygon kmlPolygon = new KmlPolygon(); kmlPolygon.setPoints(coordinates); kmlPolygon.setName(name); kmlPolygonList.add(kmlPolygon); } /** * 将kml中所有线添加到一个list * * @return */ private void addLineStringToList(List\u0026lt;KmlLine\u0026gt; kmlLineList, List\u0026lt;Coordinate\u0026gt; coordinates, String name) { KmlLine kmlLine = new KmlLine(); kmlLine.setPoints(coordinates); kmlLine.setName(name); kmlLineList.add(kmlLine); } /** * 将kml中所有点添加到一个list * * @return */ private void addPointToList(List\u0026lt;KmlPoint\u0026gt; kmlPointList, List\u0026lt;Coordinate\u0026gt; coordinates, String name) { KmlPoint kmlPoint = new KmlPoint(); kmlPoint.setName(name); kmlPoint.setPoints(coordinates); kmlPointList.add(kmlPoint); } public static List\u0026lt;KmlPoint\u0026gt; getKmlPoints(String path) throws DocumentException, FileNotFoundException { List\u0026lt;KmlPoint\u0026gt; points = new ArrayList\u0026lt;\u0026gt;(); File xmlFile = new File(path); SAXReader reader = new SAXReader(); org.dom4j.Document document = reader.read(xmlFile); Element rootElement = document.getRootElement(); Iterator rootIt = rootElement.elementIterator(); while (rootIt.hasNext()){ placeMark(points,(Element)rootIt.next()); } return points; } public static void placeMark(List\u0026lt;KmlPoint\u0026gt; points, Element next) { if(next.getName().equals(\u0026quot;Placemark\u0026quot;)){ Iterator it = next.elementIterator(); boolean tag = false; while (it.hasNext()){ Element element = (Element) it.next(); if(element.getName().equals(\u0026quot;LookAt\u0026quot;)){ tag = true; break; } } if(true){ getPoint(points,next); } }else{ Iterator it = next.elementIterator(); while (it.hasNext()){ placeMark(points,(Element)it.next()); } } } private static void getPoint(List\u0026lt;KmlPoint\u0026gt; points, Element placemark) { KmlPoint point = new KmlPoint(); Iterator mark = placemark.elementIterator(); while (mark.hasNext()){ Element element = (Element)mark.next(); if(element.getName().equalsIgnoreCase(\u0026quot;name\u0026quot;)){ point.setName(element.getText()); }else if(element.getName().equalsIgnoreCase(\u0026quot;LookAt\u0026quot;)){ Iterator itc = element.elementIterator(); while (itc.hasNext()){ Element elementc = (Element) itc.next(); if(elementc.getName().equalsIgnoreCase(\u0026quot;longitude\u0026quot;)){ point.setLongitude(new BigDecimal(elementc.getText())); }else if(elementc.getName().equalsIgnoreCase(\u0026quot;latitude\u0026quot;)){ point.setLatitude(new BigDecimal(elementc.getText())); } } } } points.add(point); } public static void main(String[] args) throws DocumentException, FileNotFoundException { //List\u0026lt;KmlPoint\u0026gt; points = getKmlPoints(\u0026quot;D:\\\\PeterHan\\\\test.kml\u0026quot;); List\u0026lt;KmlPoint\u0026gt; points = getKmlPoints(\u0026quot;C:\\\\\\\\java\\\\\\\\idea\\\\\\\\test.kml\u0026quot;); /* KmlProperty kmlProperty; ParsingKmlUtil parsingKmlUtil =new ParsingKmlUtil(); File file = new File(\u0026quot;D:\\\\PeterHan\\\\test.kml\u0026quot;); kmlProperty = parsingKmlUtil.parseKmlForJAK(file); assert kmlProperty != null; if (kmlProperty.getKmlPoints().size() \u0026gt; 0) { for (KmlPoint k : kmlProperty.getKmlPoints()) { System.out.println(k.getName()); } System.out.println(\u0026quot;点\u0026quot;); } if (kmlProperty.getKmlLines().size() \u0026gt; 0) { for (KmlLine k : kmlProperty.getKmlLines()) { System.out.println(k.getName()); } System.out.println(\u0026quot;线\u0026quot;); } if (kmlProperty.getKmlPoints().size() \u0026gt; 0) { for (KmlPoint k : kmlProperty.getKmlPoints()) { System.out.println(k.getPoints()); } System.out.println(\u0026quot;面\u0026quot;); }*/ } }  kmz格式\nFile kmzFile = new File(path); ZipFile zipFile = new ZipFile(kmzFile); ZipInputStream zipInputStream = new ZipInputStream(new FileInputStream(kmzFile)); InputStream inputStream = null; ZipEntry entry = null; Document doc = null; List\u0026lt;KmlPoint\u0026gt; points = new ArrayList\u0026lt;\u0026gt;(); while ((entry = zipInputStream.getNextEntry()) != null) { String zipEntryName = entry.getName(); //获取所需文件的节点 if (zipEntryName.equals(\u0026quot;doc.kml\u0026quot;)) {} }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/pdfutil/",
	"title": "Pdf工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.lowagie\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;itext\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.5\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.awt.Color; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.util.ArrayList; import java.util.List; import java.util.UUID; import com.cnmts.common.service.FileService; import com.cnmts.inspections.bean.RespInspectionTemplateInfo; import com.lowagie.text.Cell; import com.lowagie.text.Document; import com.lowagie.text.DocumentException; import com.lowagie.text.Element; import com.lowagie.text.Font; import com.lowagie.text.PageSize; import com.lowagie.text.Paragraph; import com.lowagie.text.Phrase; import com.lowagie.text.Table; import com.lowagie.text.pdf.BaseFont; import com.lowagie.text.pdf.PdfCopy; import com.lowagie.text.pdf.PdfImportedPage; import com.lowagie.text.pdf.PdfReader; import com.lowagie.text.pdf.PdfWriter; public class PdfUtil { private static final int N = 1; public static String CreatePdf(List\u0026lt;RespInspectionTemplateInfo\u0026gt; list) throws FileNotFoundException, DocumentException { String fileName = UUID.randomUUID().toString() + \u0026quot;.pdf\u0026quot;; String relatiePath = FileService.temp+\u0026quot;/\u0026quot;+DateUtil.getYear() + \u0026quot;/\u0026quot; + DateUtil.getMonth(); relatiePath = relatiePath + \u0026quot;/\u0026quot; + fileName; File file = new File(relatiePath); if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } // 创建一个文档对象纸张大小为A4 Document doc = new Document(PageSize.A4, 40, 40, 40, 40); // 设置要输出到磁盘上的文件名称 PdfWriter writer = PdfWriter.getInstance(doc, new FileOutputStream(new File(relatiePath))); MyEvent event = new MyEvent(); writer.setPageEvent(event); /* * //设置作者信息 doc.addAuthor(\u0026quot;sxyx2008\u0026quot;); //设置文档创建日期 doc.addCreationDate(); */ // 设置标题 doc.addTitle(\u0026quot;iText测试\u0026quot;); // 设置值主题 doc.addSubject(\u0026quot;iText\u0026quot;); // 打开文档开始写内容 doc.open(); // 构建一段落 Paragraph par3 = new Paragraph(\u0026quot;检查记录表\u0026quot;, ChineseFont()); // 设置局中对齐 par3.setAlignment(Element.ALIGN_CENTER); // 添加到文档 doc.add(par3); // 创建一个四列的表格 Table table = new Table(6); // 设置边框 table.setBorder(1); table.setBorderColor(Color.GRAY); table.setWidth(530); float[] widths = { 18, 170, 60, 130, 60, 50 }; table.setWidths(widths); table.setPadding(2); table.setLocked(true); // 创建表头 Cell cell1 = new Cell(new Phrase(\u0026quot;编号\\r\\n#\u0026quot;, ChineseFont())); cell1.setHorizontalAlignment(Element.ALIGN_CENTER); cell1.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell2 = new Cell(new Phrase(\u0026quot;项目\\r\\nItem\u0026quot;, ChineseFont())); cell2.setHorizontalAlignment(Element.ALIGN_CENTER); cell2.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell3 = new Cell(new Phrase(\u0026quot;设备\\r\\nAsset\u0026quot;, ChineseFont())); cell3.setHorizontalAlignment(Element.ALIGN_CENTER); cell3.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell4 = new Cell(new Phrase(\u0026quot;运行状态\\r\\nStatus\u0026quot;, ChineseFont())); cell4.setHorizontalAlignment(Element.ALIGN_CENTER); cell4.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell5 = new Cell(new Phrase(\u0026quot;采取/建议的措施\\r\\nPorposed Action\u0026quot;, ChineseFont())); cell5.setHorizontalAlignment(Element.ALIGN_CENTER); cell5.setVerticalAlignment(Element.ALIGN_CENTER); Cell cell6 = new Cell(new Phrase(\u0026quot;备注\\r\\nRemark\u0026quot;, ChineseFont())); cell6.setHorizontalAlignment(Element.ALIGN_CENTER); cell6.setVerticalAlignment(Element.ALIGN_CENTER); table.addCell(cell1); table.addCell(cell2); table.addCell(cell3); table.addCell(cell4); table.addCell(cell5); table.addCell(cell6); // 添加此代码后每页都会显示表头 table.endHeaders(); // 循环向表格中添加100条记录 100行4列的表格 // 以下代码的作用是创建100行数据,其中每行有四列,列依次为 编号 姓名 性别 备注 for (int i = 0; i \u0026lt; list.size(); i++) { Cell cell11 = new Cell(new Phrase(i + 1 + \u0026quot;\u0026quot;, ChineseFont())); Cell cell22 = new Cell(new Phrase(list.get(i).getItemName(), ChineseFont())); Cell cell33 = new Cell(new Phrase(list.get(i).getAssetName(), ChineseFont())); Cell cell44 = null; if (list.get(i).getConditionMeasure() == 1) { cell44 = new Cell(new Phrase(\u0026quot;一般 不良\u0026quot;, ChineseFont())); } else if (list.get(i).getConditionMeasure() == 2) { cell44 = new Cell(new Phrase(\u0026quot;良好 一般 不良\u0026quot;, ChineseFont())); } else if (list.get(i).getConditionMeasure() == 3) { cell44 = new Cell(new Phrase(\u0026quot;很好 良好 一般 低劣 不良\u0026quot;, ChineseFont())); } else if (list.get(i).getConditionMeasure() == 4) { cell44 = new Cell(new Phrase(\u0026quot;得分( )\u0026quot;, ChineseFont())); } else { cell44 = new Cell(new Phrase(\u0026quot;比例( )\u0026quot;, ChineseFont())); } Cell cell55 = new Cell(new Phrase(\u0026quot;\u0026quot;)); Cell cell66 = new Cell(new Phrase(\u0026quot;\u0026quot;)); // 单元格水平对齐方式 cell11.setHorizontalAlignment(Element.ALIGN_LEFT); // 单元格垂直对齐方式 cell11.setVerticalAlignment(Element.ALIGN_CENTER); cell22.setHorizontalAlignment(Element.ALIGN_LEFT); cell22.setVerticalAlignment(Element.ALIGN_CENTER); cell33.setHorizontalAlignment(Element.ALIGN_LEFT); cell33.setVerticalAlignment(Element.ALIGN_CENTER); cell44.setHorizontalAlignment(Element.ALIGN_LEFT); cell44.setVerticalAlignment(Element.ALIGN_CENTER); cell55.setHorizontalAlignment(Element.ALIGN_LEFT); cell55.setVerticalAlignment(Element.ALIGN_CENTER); cell66.setHorizontalAlignment(Element.ALIGN_LEFT); cell66.setVerticalAlignment(Element.ALIGN_CENTER); table.addCell(cell11); table.addCell(cell22); table.addCell(cell33); table.addCell(cell44); table.addCell(cell55); table.addCell(cell66); } // 将表格添加到新的文档 doc.add(table); doc.close(); writer.close(); return relatiePath; } // pdf文档中文字符处理 public static Font ChineseFont() { BaseFont baseFont = null; try { baseFont = BaseFont.createFont(\u0026quot;c:\\\\windows\\\\fonts\\\\SIMHEI.TTF\u0026quot;, BaseFont.IDENTITY_H, BaseFont.NOT_EMBEDDED); } catch (DocumentException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } Font chineseFont = new Font(baseFont, 8, Font.NORMAL, Color.black); return chineseFont; } public static byte[] mergePdfFiles(String[] files) { try { Document document = new Document(new PdfReader(files[0]).getPageSize(1)); ByteArrayOutputStream bos = new ByteArrayOutputStream(); PdfCopy copy = new PdfCopy(document, bos); document.open(); for (int i = 0; i \u0026lt; files.length; i++) { if (files[i] == null || files[i].equals(\u0026quot;\u0026quot;)) { continue; } PdfReader reader = new PdfReader(files[i]); int n = reader.getNumberOfPages(); for (int j = 1; j \u0026lt;= n; j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } } bos.flush(); bos.close(); copy.close(); document.close(); return bos.toByteArray(); } catch (IOException e) { e.printStackTrace(); } catch (DocumentException e) { e.printStackTrace(); } return null; } public static void partitionPdfFile(String filepath) { Document document = null; PdfCopy copy = null; try { PdfReader reader = new PdfReader(filepath); int n = reader.getNumberOfPages(); if (n \u0026lt; N) { System.out.println(\u0026quot;The document does not have \u0026quot; + N + \u0026quot; pages to partition !\u0026quot;); return; } int size = n / N; String staticpath = filepath.substring(0, filepath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1); String savepath = null; ArrayList\u0026lt;String\u0026gt; savepaths = new ArrayList\u0026lt;String\u0026gt;(); for (int i = 1; i \u0026lt;= N; i++) { if (i \u0026lt; 10) { savepath = filepath.substring(filepath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1, filepath.length() - 4); savepath = staticpath + savepath + \u0026quot;0\u0026quot; + i + \u0026quot;.pdf\u0026quot;; savepaths.add(savepath); } else { savepath = filepath.substring(filepath.lastIndexOf(\u0026quot;\\\\\u0026quot;) + 1, filepath.length() - 4); savepath = staticpath + savepath + i + \u0026quot;.pdf\u0026quot;; savepaths.add(savepath); } } for (int i = 0; i \u0026lt; N - 1; i++) { document = new Document(reader.getPageSize(1)); copy = new PdfCopy(document, new FileOutputStream(savepaths.get(i))); document.open(); for (int j = size * i + 1; j \u0026lt;= size * (i + 1); j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } document.close(); } document = new Document(reader.getPageSize(1)); copy = new PdfCopy(document, new FileOutputStream(savepaths.get(N - 1))); document.open(); for (int j = size * (N - 1) + 1; j \u0026lt;= n; j++) { document.newPage(); PdfImportedPage page = copy.getImportedPage(reader, j); copy.addPage(page); } document.close(); } catch (IOException e) { e.printStackTrace(); } catch (DocumentException e) { e.printStackTrace(); } } }  通过Myevent在每页的开始和结尾加标注\n import java.io.IOException; import com.lowagie.text.BadElementException; import com.lowagie.text.Document; import com.lowagie.text.DocumentException; import com.lowagie.text.Image; import com.lowagie.text.pdf.PdfPageEventHelper; import com.lowagie.text.pdf.PdfWriter; public class MyEvent extends PdfPageEventHelper{ Image image; Image image2; Image image3; @Override public void onOpenDocument(PdfWriter writer, Document document) { String fileNameInResource = \u0026quot;/images/1.png\u0026quot;; String fileNameInResource2 =\u0026quot;/images/2.png\u0026quot;; String fileNameInResource3 = \u0026quot;/images/3.png\u0026quot;; try { image = Image.getInstance(fileNameInResource); image.setAbsolutePosition(30, 20); image.setWidthPercentage(10); image2 = Image.getInstance(fileNameInResource2); image2.setAbsolutePosition(470, 25); image3 = Image.getInstance(fileNameInResource3); image3.setAbsolutePosition(30, 800); } catch (BadElementException | IOException e) { e.printStackTrace(); } } @Override public void onEndPage(PdfWriter writer, Document document) { try { writer.getDirectContent().addImage(image); writer.getDirectContent().addImage(image2); } catch (DocumentException e) { e.printStackTrace(); } } @Override public void onStartPage(PdfWriter writer,Document document) { try { writer.getDirectContent().addImage(image3); } catch (DocumentException e) { e.printStackTrace(); } } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/httpclientutil/",
	"title": "Post请求",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.httpcomponents\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;httpclient\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import org.apache.http.HttpResponse; import org.apache.http.ParseException; import org.apache.http.client.HttpClient; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.NameValuePair; import org.apache.http.impl.client.HttpClientBuilder; import org.apache.http.message.BasicNameValuePair; import org.apache.http.protocol.HTTP; import org.apache.http.util.EntityUtils; public class HttpClientUtils { private static final String userAgent_firefox = \u0026quot;Mozilla/5.0 (Windows; U; Windows NT 5.1; zh-CN; rv:1.9.0.3) Gecko/2008092417 Firefox/3.0.3\u0026quot;; @SuppressWarnings(\u0026quot;deprecation\u0026quot;) public static String doPost(String url, Map\u0026lt;String, String\u0026gt; params) { return doPost(url, params, null, HTTP.UTF_8); } @SuppressWarnings(\u0026quot;deprecation\u0026quot;) public static String doPost(String url, Map\u0026lt;String, String\u0026gt; params, Map\u0026lt;String, String\u0026gt; header) { return doPost(url, params, header, HTTP.UTF_8); } public static String doPost(String url, Map\u0026lt;String, String\u0026gt; params, Map\u0026lt;String, String\u0026gt; header, String charset) { String result = \u0026quot;\u0026quot;; HttpClient httpClient = getHttpClient(); HttpPost httpPost = getHttpPost(url); setHeader(header, httpPost); List\u0026lt;NameValuePair\u0026gt; nvps = new ArrayList\u0026lt;NameValuePair\u0026gt;(); if (params != null) { Set\u0026lt;String\u0026gt; keySet = params.keySet(); for (String key : keySet) { nvps.add(new BasicNameValuePair(key, params.get(key))); } } try { httpPost.setEntity(new UrlEncodedFormEntity(nvps, charset)); HttpResponse response = httpClient.execute(httpPost); result = EntityUtils.toString(response.getEntity()); } catch (IOException e) { e.printStackTrace(); } catch (ParseException pe) { pe.printStackTrace(); } return result; } public static File downloadFile(String url, File file) { HttpClient httpClient = getHttpClient(); HttpGet httpGet = getHttpGet(url); BufferedInputStream bufferedInputStream = null; BufferedOutputStream bufferedOutputStream = null; try { if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } InputStream inputStream = httpClient.execute(httpGet).getEntity() .getContent(); bufferedInputStream = new BufferedInputStream(inputStream); bufferedOutputStream = new BufferedOutputStream( new FileOutputStream(file)); byte[] buff = new byte[1024 * 1024]; int length = 0; while ((length = bufferedInputStream.read(buff)) != -1) { bufferedOutputStream.write(buff, 0, length); bufferedOutputStream.flush(); } } catch (Exception e) { e.printStackTrace(); } finally { if (bufferedInputStream != null) { try { bufferedInputStream.close(); } catch (IOException e) { e.printStackTrace(); } } if (bufferedOutputStream != null) { try { bufferedOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } } return file; } private static HttpClient getHttpClient() { HttpClientBuilder create = HttpClientBuilder.create(); return create.build(); } private static HttpPost getHttpPost(String url) { HttpPost post = new HttpPost(url); post.setHeader(\u0026quot;User-Agent\u0026quot;, userAgent_firefox); return post; } private static HttpGet getHttpGet(String url) { HttpGet httpGet = new HttpGet(url); httpGet.setHeader(\u0026quot;User-Agent\u0026quot;, userAgent_firefox); return httpGet; } private static void setHeader(Map\u0026lt;String, String\u0026gt; header, Object obj) { if (header != null) {// 设置header Set\u0026lt;String\u0026gt; headerKey = header.keySet(); for (Iterator\u0026lt;String\u0026gt; iterator = headerKey.iterator(); iterator .hasNext();) { String key = (String) iterator.next(); String value = header.get(key); if (obj instanceof HttpPost) { ((HttpPost) obj).setHeader(key, value); } if (obj instanceof HttpGet) { ((HttpPost) obj).setHeader(key, value); } } } } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/shputil/",
	"title": "Shp工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.geotools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gt-shapefile\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;19.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.geotools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;gt-swing\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;19.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.geotools.data.FileDataStore; import org.geotools.data.FileDataStoreFinder; import org.geotools.data.shapefile.ShapefileDataStore; import org.geotools.data.simple.SimpleFeatureCollection; import org.geotools.data.simple.SimpleFeatureIterator; import org.geotools.data.simple.SimpleFeatureSource; import org.opengis.feature.simple.SimpleFeature; import org.opengis.filter.Filter; import java.io.File; import java.io.IOException; import java.nio.charset.Charset; import java.util.List; public class ShpUtil { public static void main(String[] args){ String path1 = \u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot; ; //读取shp SimpleFeatureCollection colls1 = readShp(path1); //拿到所有features SimpleFeatureIterator iters = colls1.features(); //遍历打印 while(iters.hasNext()){ SimpleFeature sf = iters.next(); List\u0026lt;Object\u0026gt; list = sf.getAttributes(); System.out.println(sf.getID() + \u0026quot; , \u0026quot; + sf.getAttributes()); } } public static SimpleFeatureCollection readShp(String path ){ return readShp(path, null); } public static SimpleFeatureCollection readShp(String path , Filter filter){ SimpleFeatureSource featureSource = readStoreByShp(path); if(featureSource == null) return null; try { return filter != null ? featureSource.getFeatures(filter) : featureSource.getFeatures() ; } catch (IOException e) { e.printStackTrace(); } return null ; } public static SimpleFeatureSource readStoreByShp(String path ){ File file = new File(path); FileDataStore store; SimpleFeatureSource featureSource = null; try { store = FileDataStoreFinder.getDataStore(file); ((ShapefileDataStore) store).setCharset(Charset.forName(\u0026quot;UTF-8\u0026quot;)); featureSource = store.getFeatureSource(); } catch (IOException e) { e.printStackTrace(); } return featureSource ; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/wordutil/",
	"title": "Word工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.14\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import java.math.BigInteger; import java.util.List; import org.apache.poi.xwpf.usermodel.ParagraphAlignment; import org.apache.poi.xwpf.usermodel.TextAlignment; import org.apache.poi.xwpf.usermodel.XWPFParagraph; import org.apache.poi.xwpf.usermodel.XWPFRun; import org.apache.poi.xwpf.usermodel.XWPFTable; import org.apache.poi.xwpf.usermodel.XWPFTableCell; import org.apache.poi.xwpf.usermodel.XWPFTableRow; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTHpsMeasure; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTRPr; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTc; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTTcPr; import org.openxmlformats.schemas.wordprocessingml.x2006.main.CTVerticalJc; import org.openxmlformats.schemas.wordprocessingml.x2006.main.STMerge; import org.openxmlformats.schemas.wordprocessingml.x2006.main.STVerticalJc; public class WordUtil { /** * 创建一行，如果有则直接使用 * * @param table * @param rowNum * @return */ public static XWPFTableRow createRow(XWPFTable table, int rowNum) { XWPFTableRow row = table.getRow(rowNum); if (row == null) { row = table.createRow(); } return row; } /** * 创建一列，如果有则使用 * * @param row * 行 * @param cellNum * 列号 * @return */ public static XWPFTableCell createCell(XWPFTableRow row, int cellNum) { XWPFTableCell cell = row.getCell(cellNum); if (cell == null) { cell = row.createCell(); } return cell; } /** * 和并列 * * @param cell * 被合并的列 * @param from * 起始列号 * @param index * 当前列号 * @param to * 结束列号 */ public static void mergeCell(XWPFTableCell cell, int from, int index, int to) { CTTcPr cellCTTcPr = getCellCTTcPr(cell); if (from == index) { cellCTTcPr.addNewHMerge().setVal(STMerge.RESTART); } else { cellCTTcPr.addNewHMerge().setVal(STMerge.CONTINUE); } } /** * 合并行 * * @param cell * 被合并的列 * @param from * 起始行号 * @param index * 当前行号 * @param to * 结束行号 */ public static void mergeRow(XWPFTableCell cell, int from, int index, int to) { CTTcPr cellCTTcPr = getCellCTTcPr(cell); if (from == index) { cellCTTcPr.addNewVMerge().setVal(STMerge.RESTART); } else { cellCTTcPr.addNewVMerge().setVal(STMerge.CONTINUE); } } /** * @Description: 得到Cell的CTTcPr,不存在则新建 * @param cell * @return */ public static CTTcPr getCellCTTcPr(XWPFTableCell cell) { CTTc cttc = cell.getCTTc(); CTTcPr tcPr = cttc.isSetTcPr() ? cttc.getTcPr() : cttc.addNewTcPr(); return tcPr; } /** * 设置单元格垂直对齐 * * @param vAlign * STVerticalJc * @param cell */ public static void setCellVAlign(STVerticalJc.Enum vAlign, XWPFTableCell cell) { CTTcPr cellCTTcPr = getCellCTTcPr(cell); CTVerticalJc vJc = cellCTTcPr.isSetVAlign() ? cellCTTcPr.getVAlign() : cellCTTcPr.addNewVAlign(); vJc.setVal(STVerticalJc.CENTER); } /** * 设置水平对齐方式 * * @param align * ParagraphAlignment * @param cell */ public static void setCellHAlign(ParagraphAlignment align, XWPFTableCell cell) { List\u0026lt;XWPFParagraph\u0026gt; paragraphs = cell.getParagraphs(); for (XWPFParagraph xwpfParagraph : paragraphs) { xwpfParagraph.setAlignment(align); } } /** * @Description: 设置单元格Margin */ public static void setTableCellMargin(XWPFTable table, int top, int left, int bottom, int right) { table.setCellMargins(top, left, bottom, right); } /** * 获得XWPFRun * * @param p * 段落 * @param isInsert * @param isNewLine * @return */ public static XWPFRun getOrAddParagraphFirstRun(XWPFParagraph p, boolean isInsert, boolean isNewLine) { XWPFRun pRun = null; if (isInsert) { pRun = p.createRun(); } else { if (p.getRuns() != null \u0026amp;\u0026amp; p.getRuns().size() \u0026gt; 0) { pRun = p.getRuns().get(0); } else { pRun = p.createRun(); } } if (isNewLine) { pRun.addBreak(); } return pRun; } /** * @Description: 得到XWPFRun的CTRPr */ public static CTRPr getRunCTRPr(XWPFParagraph p, XWPFRun pRun) { CTRPr pRpr = null; if (pRun.getCTR() != null) { pRpr = pRun.getCTR().getRPr(); if (pRpr == null) { pRpr = pRun.getCTR().addNewRPr(); } } else { pRpr = p.getCTP().addNewR().addNewRPr(); } return pRpr; } /** * @Description: 设置段落对齐 */ public static void setParagraphAlignInfo(XWPFParagraph p, ParagraphAlignment pAlign, TextAlignment valign) { if (pAlign != null) { p.setAlignment(pAlign); } if (valign != null) { p.setVerticalAlignment(valign); } } public static void setFontStyle(XWPFParagraph p, XWPFRun pRun, String fontSize, boolean isBlod, boolean isItalic) { CTRPr pRpr = getRunCTRPr(p, pRun); // 设置字体大小 CTHpsMeasure sz = pRpr.isSetSz() ? pRpr.getSz() : pRpr.addNewSz(); sz.setVal(new BigInteger(fontSize)); CTHpsMeasure szCs = pRpr.isSetSzCs() ? pRpr.getSzCs() : pRpr.addNewSzCs(); szCs.setVal(new BigInteger(fontSize)); // 设置字体样式 // 加粗 if (isBlod) { pRun.setBold(isBlod); } // 倾斜 if (isItalic) { pRun.setItalic(isItalic); } } /** * 设置单元格文本 * * @param cell * @param text * 文本内容 * @param fontSize * 字号 */ public static void setCellText(XWPFTableCell cell, String text, String fontSize) { List\u0026lt;XWPFParagraph\u0026gt; paragraphs = cell.getParagraphs(); if (paragraphs == null || paragraphs.size() \u0026lt; 1) { cell.addParagraph(); } XWPFParagraph cellParagraph = cell.getParagraphs().get(0); XWPFRun cellRun = WordUtil.getOrAddParagraphFirstRun(cellParagraph, false, false); WordUtil.setFontStyle(cellParagraph, cellRun, fontSize, false, false); cellRun.setText(text); cell.setParagraph(cellParagraph); } public static void setCellText2(XWPFTableCell cell, String text, String fontSize,String fontFamily,boolean bold) { List\u0026lt;XWPFParagraph\u0026gt; paragraphs = cell.getParagraphs(); if (paragraphs == null || paragraphs.size() \u0026lt; 1) { cell.addParagraph(); } XWPFParagraph cellParagraph = cell.getParagraphs().get(0); XWPFRun cellRun = WordUtil.getOrAddParagraphFirstRun(cellParagraph, false, false); cellRun.setFontFamily(fontFamily); WordUtil.setFontStyle(cellParagraph, cellRun, fontSize, bold, false); cellRun.setText(text); cell.setParagraph(cellParagraph); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/word2htmlutil/",
	"title": "Word转换html",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.poi\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;poi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.1.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import org.apache.commons.lang3.SystemUtils; import org.apache.poi.hwpf.HWPFDocument; import org.apache.poi.hwpf.converter.PicturesManager; import org.apache.poi.hwpf.converter.WordToHtmlConverter; import org.apache.poi.hwpf.usermodel.Picture; import org.apache.poi.hwpf.usermodel.PictureType; import org.apache.poi.xwpf.converter.core.BasicURIResolver; import org.apache.poi.xwpf.converter.core.FileImageExtractor; import org.apache.poi.xwpf.converter.core.XWPFConverterException; import org.apache.poi.xwpf.converter.xhtml.XHTMLConverter; import org.apache.poi.xwpf.converter.xhtml.XHTMLOptions; import org.apache.poi.xwpf.usermodel.XWPFDocument; import org.w3c.dom.Document; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import java.io.*; import java.util.List; /** * * word转换html的工具类 * * @author xiaoming * * @time 2016年11月29日 下午3:53:08 */ public class Word2HtmlUtil { private static String word2003 = \u0026quot;application/msword\u0026quot;; private static String word2007 = \u0026quot;application/vnd.openxmlformats-officedocument.wordprocessingml.document\u0026quot;; public static File convert2Html(String wordFilePath, String htmlFilePath, String relativePath) throws FileNotFoundException, IOException, ParserConfigurationException, TransformerException { String probeContentType = FileUtil.getFileContentType(new File(wordFilePath)); if (word2003.equals(probeContentType)) { // word 2003： return word20032Html(wordFilePath, htmlFilePath, relativePath); } else if (word2007.equals(probeContentType)) { // word 2007 return word20072Html(wordFilePath, htmlFilePath, relativePath); } else { return null; } } private static File word20032Html(String wordFilePath, String htmlFilePath, String relativePath) throws FileNotFoundException, IOException, ParserConfigurationException, TransformerException { HWPFDocument wordDocument = new HWPFDocument(new FileInputStream(wordFilePath)); WordToHtmlConverter wordToHtmlConverter = new WordToHtmlConverter(DocumentBuilderFactory.newInstance().newDocumentBuilder() .newDocument()); wordToHtmlConverter.setPicturesManager(new PicturesManager() { @Override public String savePicture(byte[] content, PictureType pictureType, String suggestedName, float widthInches, float heightInches) { return \u0026quot;../../../docimg/\u0026quot; + suggestedName; } }); wordToHtmlConverter.processDocument(wordDocument); // save pictures List\u0026lt;Picture\u0026gt; pics = wordDocument.getPicturesTable().getAllPictures(); if (pics != null) { for (int i = 0; i \u0026lt; pics.size(); i++) { Picture pic = pics.get(i); try { File file = new File(relativePath + \u0026quot;docimg/\u0026quot; + pic.suggestFullFileName()); if (!file.getParentFile().exists()) { file.getParentFile().mkdirs(); } pic.writeImageContent(new FileOutputStream(relativePath + \u0026quot;docimg/\u0026quot; + pic.suggestFullFileName())); } catch (FileNotFoundException e) { e.printStackTrace(); } } } Document htmlDocument = wordToHtmlConverter.getDocument(); ByteArrayOutputStream out = new ByteArrayOutputStream(); DOMSource domSource = new DOMSource(htmlDocument); StreamResult streamResult = new StreamResult(out); TransformerFactory tf = TransformerFactory.newInstance(); Transformer serializer = tf.newTransformer(); if (SystemUtils.IS_OS_WINDOWS) { serializer.setOutputProperty(OutputKeys.ENCODING, \u0026quot;GBK\u0026quot;); } serializer.setOutputProperty(OutputKeys.INDENT, \u0026quot;yes\u0026quot;); serializer.setOutputProperty(OutputKeys.METHOD, \u0026quot;html\u0026quot;); serializer.transform(domSource, streamResult); out.close(); return writeFile(new String(out.toByteArray()), htmlFilePath); } private static File word20072Html(String wordFilePath, String htmlFilePath, String relativePath) throws XWPFConverterException, IOException { OutputStreamWriter outputStreamWriter = null; try { XWPFDocument document = new XWPFDocument(new FileInputStream(wordFilePath)); XHTMLOptions options = XHTMLOptions.create(); // 存放图片的文件夹 options.setExtractor(new FileImageExtractor(new File(relativePath + \u0026quot;docimg\u0026quot;))); // html中图片的路径 options.URIResolver(new BasicURIResolver(\u0026quot;../../../docimg\u0026quot;)); outputStreamWriter = new OutputStreamWriter(new FileOutputStream(htmlFilePath), \u0026quot;utf-8\u0026quot;); XHTMLConverter xhtmlConverter = (XHTMLConverter) XHTMLConverter.getInstance(); xhtmlConverter.convert(document, outputStreamWriter, options); } finally { if (outputStreamWriter != null) { outputStreamWriter.close(); } } return new File(htmlFilePath); } public static File writeFile(String content, String path) { FileOutputStream fos = null; BufferedWriter bw = null; try { File file = new File(path); fos = new FileOutputStream(file); bw = new BufferedWriter(new OutputStreamWriter(fos, \u0026quot;UTF-8\u0026quot;)); bw.write(content); return file; } catch (FileNotFoundException fnfe) { fnfe.printStackTrace(); } catch (IOException ioe) { ioe.printStackTrace(); } finally { try { if (bw != null) bw.close(); if (fos != null) fos.close(); } catch (IOException ie) { } } return null; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/csvutil/",
	"title": "csv 工具类",
	"tags": [],
	"description": "",
	"content": " import com.nuclear_Project.common.bean.Dictionary; import java.io.*; import java.lang.reflect.*; import java.util.ArrayList; import java.util.List; public class CSVUtil\u0026lt;T\u0026gt; { private String[] fields; private Class\u0026lt;T\u0026gt; entityClass; public CSVUtil(Class\u0026lt;T\u0026gt; clazz,String... fields){ this.entityClass = clazz; this.fields = fields; } public List\u0026lt;T\u0026gt; importCSV(File file) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException { List\u0026lt;String\u0026gt; dataList = importCSVFile(file); List\u0026lt;T\u0026gt; list = new ArrayList\u0026lt;T\u0026gt;(); Constructor constructor = entityClass.getConstructor(null); Method[] methods = entityClass.getMethods(); Field[] fields = entityClass.getDeclaredFields(); for(String s:dataList){ T instance = (T) constructor.newInstance(null); String entity = s; String[] values = entity.split(\u0026quot;,\u0026quot;); for(int i=0;i\u0026lt;values.length;i++){ Field field = fields[i]; if(!field.isAccessible()){ field.setAccessible(true); } if(field.getType().equals(Integer.class)){ field.setInt(instance,Integer.parseInt(values[i])); }else if(field.getType().equals(int.class)){ field.setInt(instance,Integer.parseInt(values[i])); }else if(field.getType().equals(String.class)){ field.set(instance,values[i]); } } list.add(instance); } return list; } public List\u0026lt;String\u0026gt; importCSVFile(File file){ List\u0026lt;String\u0026gt; dataList=new ArrayList\u0026lt;String\u0026gt;(); BufferedReader br=null; try { br = new BufferedReader(new FileReader(file)); String line = \u0026quot;\u0026quot;; while ((line = br.readLine()) != null) { if(line.startsWith(\u0026quot;\\uFEFF\u0026quot;)){ line = line.replace(\u0026quot;\\uFEFF\u0026quot;, \u0026quot;\u0026quot;); } dataList.add(line); } }catch (Exception e) { }finally{ if(br!=null){ try { br.close(); br=null; } catch (IOException e) { e.printStackTrace(); } } } return dataList; } public Boolean exportCSV(List\u0026lt;T\u0026gt; dataList, File file) throws NoSuchFieldException, IllegalAccessException { List\u0026lt;String\u0026gt; list = new ArrayList\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;dataList.size();i++){ StringBuilder string = new StringBuilder(); T instance = dataList.get(i); for(int j=0;j\u0026lt;fields.length;j++){ String field = fields[j]; Field entityField = entityClass.getDeclaredField(field); if(!entityField.isAccessible()){ entityField.setAccessible(true); } Object value = entityField.get(instance); string.append(value.toString()); int k = fields.length-1; if(j!=k){ string.append(\u0026quot;,\u0026quot;); } } list.add(string.toString()); } return exportCsvFile(file,list); } public boolean exportCsvFile(File file, List\u0026lt;String\u0026gt; dataList){ boolean isSucess=false; FileOutputStream out=null; OutputStreamWriter osw=null; BufferedWriter bw=null; try { out = new FileOutputStream(file); byte[] uft8bom={(byte)0xef,(byte)0xbb,(byte)0xbf}; out.write(uft8bom); bw = new BufferedWriter(new OutputStreamWriter(out, \u0026quot;UTF-8\u0026quot;)); if(dataList!=null \u0026amp;\u0026amp; !dataList.isEmpty()){ for(String data : dataList){ bw.append(data).append(\u0026quot;\\r\u0026quot;); } } isSucess=true; } catch (Exception e) { isSucess=false; }finally{ if(bw!=null){ try { bw.close(); bw=null; } catch (IOException e) { e.printStackTrace(); } } if(osw!=null){ try { osw.close(); osw=null; } catch (IOException e) { e.printStackTrace(); } } if(out!=null){ try { out.close(); out=null; } catch (IOException e) { e.printStackTrace(); } } } return isSucess; } public static void main(String[] args) throws IOException, InvocationTargetException, NoSuchMethodException, InstantiationException, IllegalAccessException { File file = new File(\u0026quot;d:\\\\test.csv\u0026quot;); /* List\u0026lt;Dictionary\u0026gt; ds = new ArrayList\u0026lt;\u0026gt;(); for(int i=1;i\u0026lt;10;i++){ Dictionary d = new Dictionary(); d.setDictId(i); d.setDictKey(i); d.setDictName(\u0026quot;测试\u0026quot;+i); ds.add(d); } String[] fields = {\u0026quot;dictId\u0026quot;,\u0026quot;dictKey\u0026quot;,\u0026quot;dictName\u0026quot;}; CSVUtil csvUtil = new CSVUtil(Dictionary.class,fields); try { csvUtil.exportCSV(ds,file); }catch (Exception e){ e.printStackTrace(); }*/ String[] fields = {\u0026quot;dictId\u0026quot;,\u0026quot;dictKey\u0026quot;,\u0026quot;dictName\u0026quot;}; CSVUtil csvUtil = new CSVUtil(Dictionary.class,fields); List\u0026lt;Dictionary\u0026gt; list = (List\u0026lt;Dictionary\u0026gt;)csvUtil.importCSV(file); for(Dictionary d:list){ System.out.print(d); } } }  实体类\n public class Dictionary { private int dictId; private int dictKey; private String dictName; private String dictType; private String remark; private int dictSort; @Override public String toString() { return \u0026quot;Dictionary{\u0026quot; + \u0026quot;dictId=\u0026quot; + dictId + \u0026quot;, dictKey=\u0026quot; + dictKey + \u0026quot;, dictName='\u0026quot; + dictName + '\\'' + \u0026quot;, dictType='\u0026quot; + dictType + '\\'' + \u0026quot;, remark='\u0026quot; + remark + '\\'' + \u0026quot;, dictSort=\u0026quot; + dictSort + '}'; } public String getRemark() { return remark; } public void setRemark(String remark) { this.remark = remark; } public int getDictSort() { return dictSort; } public void setDictSort(int dictSort) { this.dictSort = dictSort; } public int getDictKey() { return dictKey; } public void setDictKey(int dictKey) { this.dictKey = dictKey; } public int getDictId() { return dictId; } public void setDictId(int dictId) { this.dictId = dictId; } public String getDictName() { return dictName; } public void setDictName(String dictName) { this.dictName = dictName; } public String getDictType() { return dictType; } public void setDictType(String dictType) { this.dictType = dictType; } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/docker/",
	"title": "docker 基本使用",
	"tags": [],
	"description": "",
	"content": " 一． docker常用命令 1. 从公网拉取一个镜像 docker pull images_name  2. 查看已有的docker镜像 [root@docker ~]# docker images  3. 查看帮助 docker command --help  4. 查看镜像列表 docker search nginx  5. 启动一个容器 基于hello-world镜像启动一个容器，如果本地没有镜像会从公网拉取过来，这次做为测试用\ndocker run hello-world  6. 导出镜像 docker save -o image_name.tar image_name  7. 删除镜像 docker rmi image_name  8. 启动一个容器 docker run --name=con_name images  \u0026ndash;name #设置容器名\n9. 基于创建好的容器自定义docker镜像 docker commit -m \u0026quot;con_name\u0026quot; con_id image_name  10. 创建一个容器的同时进入这个容器 docker run -it --name=con_name images  -it #在启动之后进入这个容器\n11. 创建一个容器，放入后台运行，把物理机80端口映射到容器的80端口 docker run -d -p 81:80 image_name  #-p 参数说明 -p hostPort:containerPort -p ip:hostPort:containerPort -p ip::containerPort -p hostPort:containerPort:udp\n12. 看容器的端口映射情况 docker port con_id  13. 查看正在运行的容器 docker ps  14. 查看所有的容器 docker ps -a  15. 动态查看容器日志 docker logs -f con_name  16. 进入容器 docker attach con_name  17. 退出容器 方法一\nexit  方法二 ctrl+p \u0026amp;\u0026amp; ctrl+q (一起按，注意顺序，退出后容器依然保持启动状态)\n18. 删除容器 docker rm con_name  强制删除需要加-f，不加-f不能删除正在运行中的容器，非常危险，最好不用\n19. 查看docker网络 [root@docker ~]# docker network ls  NETWORK ID NAME DRIVER SCOPE 3f91f2097286 bridge bridge local d7675dbd247c docker_gwbridge bridge local 5b36c7e947fd host host local ims6qkpikafu ingress overlay swarm 85ba10e7ef79 none null local\n20. 创建一个docker网络my-docker docker network create -d bridge \\  \u0026ndash;subnet=192.168.0.0/24 \u0026ndash;gateway=192.168.0.100 \u0026ndash;ip-range=192.168.0.0/24 my-docker\n21. 利用刚才创建的网络启动一个容器 docker run --network=my-docker --ip=192.168.0.5 -itd --name=con_name -h lb01 image_name  \u0026ndash;network #指定容器网络 \u0026ndash;ip #设定容器ip地址 -h #给容器设置主机名\n22. 查看容器pid 方法一：\ndocker top con_name  方法二：\ndocker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; con_name  23. 运行dockerfile并给dockerfile创建的镜像建立名字 docker build -t mysql:3.6.34 `pwd`  24. mariadb容器启动前需先设置密码方法 docker run -d -P -e MYSQL_ROOT_PASSWORD=password img_id  25. docker修改镜像名 docker tag imageid name:tag  26. 进入docker容器脚本 [root@docker ~]# cat nsenter.sh PID=`docker inspect --format \u0026quot;{{.State.Pid}}\u0026quot; $1` nsenter -t $PID -u --mount -i -n -p  27. 创建一个网络 docker network create --driver bridge --subnet 172.22.16.0/  24 \u0026ndash;gateway 172.22.16.1 my_net2\n28. 将容器添加到my_net2网络 connect docker network connect my_net2 oldboy1  29. docker日志模块 使用filebeat收集日志 { \u0026ldquo;registry-mirrors\u0026rdquo;: [\u0026ldquo;https://56px195b.mirror.aliyuncs.com\u0026quot;], \u0026ldquo;cluster-store\u0026rdquo;:\u0026ldquo;consul://192.168.56.13:8500\u0026rdquo;, \u0026ldquo;cluster-advertise\u0026rdquo;: \u0026ldquo;192.168.56.11:2375\u0026rdquo;, \u0026ldquo;log-driver\u0026rdquo;: \u0026ldquo;fluentd\u0026rdquo;, \u0026ldquo;log-opts\u0026rdquo;: { \u0026ldquo;fluentd-address\u0026rdquo;:\u0026ldquo;192.168.56.13:24224\u0026rdquo;, \u0026ldquo;tag\u0026rdquo;:\u0026ldquo;linux-node1.example.com\u0026rdquo; } }\n二． docker安装mysql 第一步，拉取MySQL镜像 $ sudo docker pull mysql  之后docker会自动拉取（下载）MySQL镜像。 拉取成功后我们查看一下：\n$ sudo docker images  第二步，创建并启动一个MySQL容器 输入以下命令：\n$ sudo docker run --name pwc-mysql -e MYSQL_ROOT_PASSWORD=123456 -p 3306:3306 -d mysql  • –name：给新创建的容器命名，此处命名为pwc-mysql • -e：配置信息，此处配置mysql的root用户的登陆密码 • -p：端口映射，此处映射主机3306端口到容器pwc-mysql的3306端口 • -d：成功启动容器后输出容器的完整ID，例如上图 73f8811f669ee\u0026hellip; • 最后一个mysql指的是mysql镜像名字 到这里我们查看容器运行状态：\n$ sudo docker ps  上图可以看到容器的简写ID，容器的源镜像，创建时间，状态，端口映射信息，容器名字等。\n第三步，修改mysql登录权限 docker exec -it xgmysql /bin/bash  进入mysql命令 通过mysql -uroot -p进入mysql的命令行模式 修改mysql登录权限\nALTER USER 'root'@'localhost' IDENTIFIED BY 'password'  PASSWORD EXPIRE NEVER;这里的password是你正在使用的密码\nALTER USER 'root'@'localhost' IDENTIFIED WITH  mysql_native_password BY \u0026lsquo;password\u0026rsquo;;#更新一下用户的密码这里的password为你修改的新密码。\nFLUSH PRIVILEGES;  刷新权限，使自己的修改生效。\nalter user 'root'@'%' identified by 'password' password expire never; alter user 'root'@'%' identified with mysql_native_password by 'why';//why是自己新修改的密码。 flush privileges;再次刷新一下权限配置。  三． redis安装（6379） docker pull redis docker run -d --name myredis -p 6379:6379 redis --requirepass \u0026quot;mypassword\u0026quot; 加密码  四． RabbitMq docker pull rabbitmq: 3-management  默认端口 5672\u0026frasl;15672 默认密码 guest/guest\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/ffmpeg/",
	"title": "ffmpeg 使用",
	"tags": [],
	"description": "",
	"content": " 1. 获取视频信息 import java.io.*; import java.util.regex.Matcher; import java.util.regex.Pattern; /** * 获取视频的信息 */ public class VideoInfo { //视频路径 private String ffmpegApp; //视频时 private int hours; //视频分 private int minutes; //视频秒 private float seconds; //视频width private int width; //视频height private int heigt; public VideoInfo() {} public VideoInfo(String ffmpegApp) { this.ffmpegApp = ffmpegApp; } public String toString() { return \u0026quot;time: \u0026quot; + hours + \u0026quot;:\u0026quot; + minutes + \u0026quot;:\u0026quot; + seconds + \u0026quot;, width = \u0026quot; + width + \u0026quot;, height= \u0026quot; + heigt; } public void getInfo(String videoFilename) throws IOException, InterruptedException { String tmpFile = videoFilename + \u0026quot;.tmp.png\u0026quot;; ProcessBuilder processBuilder = new ProcessBuilder(ffmpegApp, \u0026quot;-y\u0026quot;, \u0026quot;-i\u0026quot;, videoFilename, \u0026quot;-vframes\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;-ss\u0026quot;, \u0026quot;0:0:0\u0026quot;, \u0026quot;-an\u0026quot;, \u0026quot;-vcodec\u0026quot;, \u0026quot;png\u0026quot;, \u0026quot;-f\u0026quot;, \u0026quot;rawvideo\u0026quot;, \u0026quot;-s\u0026quot;, \u0026quot;100*100\u0026quot;, tmpFile); Process process = processBuilder.start(); InputStream stderr = process.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line; //打印 sb，获取更多信息。 如 bitrate、width、heigt StringBuffer sb = new StringBuffer(); while ((line = br.readLine()) != null) { sb.append(line); } new File(tmpFile).delete(); System.out.println(\u0026quot;video info:\\n\u0026quot; + sb); Pattern pattern = Pattern.compile(\u0026quot;Duration: (.*?),\u0026quot;); Matcher matcher = pattern.matcher(sb); if (matcher.find()) { String time = matcher.group(1); calcTime(time); } pattern = Pattern.compile(\u0026quot;w:\\\\d+ h:\\\\d+\u0026quot;); matcher = pattern.matcher(sb); if (matcher.find()) { String wh = matcher.group(); //w:100 h:100 String[] strs = wh.split(\u0026quot;\\\\s+\u0026quot;); if(strs != null \u0026amp;\u0026amp; strs.length == 2) { width = Integer.parseInt(strs[0].split(\u0026quot;:\u0026quot;)[1]); heigt = Integer.parseInt(strs[1].split(\u0026quot;:\u0026quot;)[1]); } } process.waitFor(); if(br != null) br.close(); if(isr != null) isr.close(); if(stderr != null) stderr.close(); } private void calcTime(String timeStr) { String[] parts = timeStr.split(\u0026quot;:\u0026quot;); hours = Integer.parseInt(parts[0]); minutes = Integer.parseInt(parts[1]); seconds = Float.parseFloat(parts[2]); } public String getFfmpegApp() { return ffmpegApp; } public void setFfmpegApp(String ffmpegApp) { this.ffmpegApp = ffmpegApp; } public int getHours() { return hours; } public void setHours(int hours) { this.hours = hours; } public int getMinutes() { return minutes; } public void setMinutes(int minutes) { this.minutes = minutes; } public float getSeconds() { return seconds; } public void setSeconds(float seconds) { this.seconds = seconds; } public int getWidth() { return width; } public void setWidth(int width) { this.width = width; } public int getHeigt() { return heigt; } public void setHeigt(int heigt) { this.heigt = heigt; } public static void main(String[] args) { VideoInfo videoInfo = new VideoInfo(\u0026quot;H:\\\\ffmpeg-20180808-af4c2ac-win64-static\\\\bin\\\\ffmpeg.exe\u0026quot;); try { videoInfo.getInfo(\u0026quot;h:/1532786415142.mp4\u0026quot;); System.out.println(videoInfo); } catch (Exception e) { e.printStackTrace(); } } }  2.获取截图 import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; public class VideoThumbTaker { protected String ffmpegApp; public VideoThumbTaker(String ffmpegApp) { this.ffmpegApp = ffmpegApp; } @SuppressWarnings(\u0026quot;unused\u0026quot;) /**** * 获取指定时间内的图片 * @param videoFilename:视频路径 * @param thumbFilename:图片保存路径 * @param width:图片长 * @param height:图片宽 * @param hour:指定时 * @param min:指定分 * @param sec:指定秒 * @throws IOException * @throws InterruptedException */ public void getThumb(String videoFilename, String thumbFilename, int width, int height, int hour, int min, float sec) throws IOException, InterruptedException { ProcessBuilder processBuilder = new ProcessBuilder(ffmpegApp, \u0026quot;-y\u0026quot;, \u0026quot;-i\u0026quot;, videoFilename, \u0026quot;-vframes\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;-ss\u0026quot;, hour + \u0026quot;:\u0026quot; + min + \u0026quot;:\u0026quot; + sec, \u0026quot;-f\u0026quot;, \u0026quot;mjpeg\u0026quot;, \u0026quot;-s\u0026quot;, width + \u0026quot;*\u0026quot; + height, \u0026quot;-an\u0026quot;, thumbFilename); Process process = processBuilder.start(); InputStream stderr = process.getErrorStream(); InputStreamReader isr = new InputStreamReader(stderr); BufferedReader br = new BufferedReader(isr); String line; while ((line = br.readLine()) != null) ; process.waitFor(); if(br != null) br.close(); if(isr != null) isr.close(); if(stderr != null) stderr.close(); } public static void main(String[] args) { VideoThumbTaker videoThumbTaker = new VideoThumbTaker(\u0026quot;H:\\\\ffmpeg-20180808-af4c2ac-win64-static\\\\bin\\\\ffmpeg.exe\u0026quot;); try { videoThumbTaker.getThumb(\u0026quot;C:/java/apache-tomcat-7.0.54/apache-tomcat-7.0.54/webapps/zhsqData/tempFile/25a464df-735c-4321-b60b-bd1faae2b127_src.mp4\u0026quot;, \u0026quot;C:/java/apache-tomcat-7.0.54/apache-tomcat-7.0.54/webapps/zhsqData/tempFile/thumbTest2.png\u0026quot;, 800, 600, 0, 0, 9); System.out.println(\u0026quot;over\u0026quot;); } catch (Exception e) { e.printStackTrace(); } } }  3. 合成视频 合成视频有很多方式，多次试验，以下方法最好用 生成txt文件\nfile 'input1.mkv' file 'input2.mkv' file 'input3.mkv'  private static void createMp4(String txtFilePath, String filePath) throws IOException { List\u0026lt;String\u0026gt; s = new ArrayList\u0026lt;\u0026gt;(); s.add(\u0026quot;H:\\\\ffmpeg-20180808-af4c2ac-win64-static\\\\bin\\\\ffmpeg.exe\u0026quot;); s.add(\u0026quot;-f\u0026quot;); s.add(\u0026quot;concat\u0026quot;); s.add(\u0026quot;-safe\u0026quot;); s.add(\u0026quot;0\u0026quot;); s.add(\u0026quot;-i\u0026quot;); s.add(txtFilePath); s.add(\u0026quot;-c\u0026quot;); s.add(\u0026quot;copy\u0026quot;); s.add(filePath); ProcessBuilder builder = new ProcessBuilder(); builder.command(s); builder.start(); }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/ffmpeg/",
	"title": "ffmpeg 安装",
	"tags": [],
	"description": "",
	"content": " 　ffmpeg是一个很强大的音视频处理工具，官网是：http://ffmpeg.org/ 官网介绍ffmpeg是：一个完整的、跨平台的解决方案，可以记录、转换和传输音频和视频。ffmpeg既可以播放视频，也提供命令行工具来处理视频，另外还有强大的视频处理库用于开发。\n1.windows版本 下载解压即可使用链接： 下载地址 提取码：bqi9\n2.linux版本 下载地址 提取码：gtv9\n2.1 解压 tar -xjvf ffmpeg-3.3.1.tar.bz2 cd ffmpeg-4.0.2/  2.2 安装yasm 如果现在直接执行configure配置的话，可能会报如下的错误：\n错误的意思是 yasm/nasm 包不存在或者很旧，可以使用\u0026ndash;disable-yasm禁用这个选项编译，yasm是一款汇编器，并且是完全重写了nasm的汇编环境，接收nasm和gas语法，支持x86和amd64指令集，所以这里安装一下yasm即可，下载地址，提取码：sg9d。 执行下面命令安装：\ntar -xvzf yasm-1.3.0.tar.gz cd yasm-1.3.0/ ./configure make make install  编译参数都是默认的，直接安装到系统中即可。\n2.3 安装ffmpeg ./configure --enable-shared --prefix=/monchickey/ffmpeg make make install  编译过程有点长，耐心等待完成之后执行\n cd /monchickey/ffmpeg/bin  进入安装目录，查看一下发现有bin,include,lib,share这4个目录，其中bin是ffmpeg主程序二进制目录，include是C/C++头文件目录，lib是编译好的库文件目录，share是文档目录，然后进入bin目录，执行\n./ffmpeg -version  查看当前版本的详细信息，默认情况下一般会报libavdevice.so.57: cannot open shared object file: No such file or directory，原因是lib目录未加载到链接到系统库中，系统ld目录列表在/etc/ld.so.conf中，打开文件会发现，里面引用了/etc/ld.so.conf.d/下面所有的.conf文件，比如mariadb-x86_64.conf我们只需要创建一个文件并写入lib路径即可，执行命令：\nvim /etc/ld.so.conf.d/ffmpeg.conf  然后添加一行内容：\n/monchickey/ffmpeg/lib  之后保存并退出，然后执行\nldconfig  使配置生效，现在再次执行\n./ffmpeg -version  显示就正常了\n然后可以根据需要将bin目录添加至环境变量中以保证任何时候都能使用ffmpeg命令，下面测试一下对视频进行转码： 首先由一个avi格式的视频文件，大小是37M，现在使用ffmpeg转换为mp4格式，执行下面命令：\nffmpeg -i test.avi out.mp4  确认之后，看到屏幕滚动开始处理，大约半分钟之后视频就转换完毕了，转换后mp4视频大小是17M，具体可以下载下来看一下 java使用\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/gitlab/",
	"title": "gitlab 离线安装",
	"tags": [],
	"description": "",
	"content": " 1. 配置本地yum源 需要准备CentOs-Everything的iso作为本地yum源。一下以/root/CentOs-7-x86_64-DVD-1708.iso为例。\n2. 挂载镜像 mount -o loop /root/CentOs-7-x86_64-DVD-1708.iso /mnt/yum-iso  如果文件夹不存在可以提前mkdir\n3. 启动httpd服务 systemctl start httpd.service  4. 检查httpd服务状态 systemctl status httpd.service  如果状态正常，通过“http://服务器IP:80/”应该可以访问到http的欢迎页，如果开启防火墙，要开放80端口。\n5. 添加软链接 ln -s /mnt/yum-ios/ /var/www/html/CentOS-7-x86_64  如果顺利，通过“http://服务器IP:80/CentOS-7-x86_64”可以访问到iso中的文件。\n6. 准备配置本地yum源 cd /etc/yum.repos.d  7. 备份其他 repo:tar zcvf repo-bk.tar.gz CentOS-*  8. 移除其他 repo:rm -rf ./CentOS-*  9. 配置本地 repo:vi CentOS-Media.repo  内容如下\nname=CentOS-$releasever - Media baseurl=file:///yum/yum-iso/ gpgcheck=0 enable=1 gpgkey=file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7  10. 制作cashe yum clear all yum makecache  11. 上传gitlab-ee文件 12. 跳转到gitlab-ee文件夹位置 13.安装 yum localinstall ./gitlab-ee-11.0.rpm  一路y知道成功\n14. 配置 主要修改各端口配置，避免端口占用 其中externam_url \u0026ldquo;服务器ip:端口\u0026rdquo; 为主界面ip及端口\n15. 更新配置 gitlab-ctl reconfigure  16. 启动git gitlab-car restart  如果出现502，检查端口号是否占用，然后调用步骤15,16重新访问。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/hugo/",
	"title": "hugo 搭建个人博客",
	"tags": [],
	"description": "",
	"content": " 1.准备工作 1.1 msysGit客户端 在Windows下默认是没有预装Git的，如果你是Mac和Linux的用户则没有这个烦恼，因此我们首先需要在Windows系统下安装一个Git软件，笔者使用的是msysGit，截止发文最新的版本是2.6.3，官网Download会自动识别系统（32位和64位）下载，之后一个个步骤按照向导安装就行，上面英文写的很清楚，基本可以按照默认的来，但是到了Ajusting your PATH environment（即设置环境变量）这一步时，建议还是勾选第二项Run Git from Windows Command Prompt，这样在Windows命令行中就可以全局使用Git相关命令。\n1.2 注册Github 点击Github官网进入Github首页，这样你能够进行注册，输入用户名、Email地址、密码即可进行注册，我们选择不需要花钱的Free类型用户，点击Finish sign up，这样即可完成注册，此时在页面顶部Bootcamp系统会提示你接下来可以做哪些事情，而我们首先需要做的就是Create Repositories，我们可以点击这一项进去看看教程，当然也可以根据我下面的提示直接开始： 1. 点击右侧New repository（新建仓库），此时系统会提示你验证邮箱，你需要去刚刚注册用的邮箱验证地址； 2. 验证完毕即可重新New reository，用户名一定要用：你的注册用户名.github.io，其他无需修改，然后点击Create repository即可; 3. 下面自动进入一个快速设置页面，告诉我们如何在仓库内添加东西，这就需要在Windows本地设置了。\n1.3 Windows本地配置Git 本文开篇就说了Windows下的Git程序，但是没有做配置，还是不能用的，这里解说下基本的配置： 1. 首先打开Git Bash做些全局设置： 1. git config \u0026ndash;global user.name \u0026ldquo;你的注册用户名\u0026rdquo; 2. git config \u0026ndash;global user.email \u0026ldquo;你的邮箱\u0026rdquo; 3. git config \u0026ndash;global color.ui auto 2. 设置SSH Key： 3. ssh-keygen -t rsa -C \u0026ldquo;你的邮箱\u0026rdquo; 然后会要求输入存储id_rsa的目录，接着是输入密码，这个密码可以与github的不同，过程中确认即可，最后会出现一个随机图形，说明生成SSH密匙成功，这样我们需要到刚刚的存储目录下打开id_rsa.pub复制里面的内容，到你的github页面上-\u0026gt;点击右上角头像旁三角-\u0026gt;settings-\u0026gt;SSH keys-\u0026gt;add SSH key-\u0026gt;黏贴刚刚复制的内容保存。\n1.4 使用hugo hugo是一个快速的静态网站引擎，使用Go语言开发，可以用Markdown格式的文章生成一个完整的静态网站，然后托管到自己的用户名.Github.io的Github仓库中，实现一个静态站点，一般用于博客或者项目主页等。那么我们先来了解下如何获取和使用： 1. 先从官网下载相关的版本，比如我是32位windows系统的，我下载hugo_0.14_windows_386.zip； 2. 解压缩后，将里面的exe文件重命名为hugo.exe，并放在C:\\hugo\\hugo.exe即可； 3. 添加环境变量：我的电脑-属性-高级系统设置-环境变量，编辑PATH，加入;C:\\hugo,用英文分号与之前的内容分割开。 这样我们可以测试下环境是否正常： 使用Windows命令行（Win+R输入cmd）输入下列命令：\ncd C:\\hugo hugo new site www  进入hugo目录下可以看到一个www的文件夹，就是刚刚新建的站点，目录的结构是： 1. ▸ archetypes/ 2. ▸ content/ 3. ▸ layouts/ 4. ▸ static/ 5. config.toml 尽管里面没有任何内容，但是恭喜你，说明程序可以正常使用了。\n2.正式建立静态网站 2.1 新建文章 首先需要先命令行进入www文件夹下，然后输入以下命令，创建一个关于页面：\nhugo new about.md  这样就生成楼www/content/about.md，打开该文件可以看到以下信息： 1. +++ 2. date = \u0026ldquo;2015-11-15T10:42:51+08:00\u0026rdquo; 3. draft = true 4. title = \u0026ldquo;about\u0026rdquo; 5.\n6. +++ 文件是md的，但是+++之间的内容是用TOML编写的文档信息，date代表文档创建的时间，后面的+08：00代表的时区，draft代表草稿，如果生成网站时不加入特殊说明是不生成该页的，title是这篇文章的标题，因此正文中不需要自己再写标题了。 为了方便之后生成聚合页面，我们继续在www/content/post/目录生成第一篇文章： hugo new post/first.md 打开first.md文件可以看到以下内容，跟上面的about.md差不多，我们在+++后面编辑一点内容并保存： 1. +++ 2. date = \u0026ldquo;2015-11-15T10:48:56+08:00\u0026rdquo; 3. draft = true 4. title = \u0026ldquo;first\u0026rdquo; 5.\n6. +++ 7. # My first blog 8. 1. aaa 9. 2. bbb 10. 3. ccc\n2.2 安装皮肤 hugo有很多皮肤(Github),也可以看这里(中文),可以找到喜欢的皮肤地址，然后在www文件夹下创建一个themes文件夹，在命令行中进入该文件夹后用git的方法获得皮肤(笔者这里使用hyde这个简单点的皮肤主题)：\ngit clone http://github.com/spf13/hyde.git  2.3 运行hugo 在站点根目录www文件夹下运行hugo调试命令： hugo server \u0026ndash;theme=hyde \u0026ndash;buildDrafts \u0026ndash;watch theme指明使用的主题名称（themes文件夹下的主题文件夹名称），buildDrafts指出编译草稿部分（即draft=true的文件），watch参数可以在文件修改时实时自动刷新页面。生成后我们可以在按照命令行提示在浏览器中输入http://127.0.0.1:1313查看页面，正常的话显示如下： 2.4 简单配置 目前为止，已经生成一个简单的静态站点，但是还有很多地方需要修改，以适应每个人的需求，可以在www站点根目录下看到一个config.toml配置文件，该文件使用TOML语法编写，基本内容如下：\nbaseurl = \u0026quot;http://replace-this-with-your-hugo-site.com/\u0026quot; languageCode = \u0026quot;en-us\u0026quot; title = \u0026quot;My New Hugo Site\u0026quot;  4.将本地站点上传 之前第一节已经注册好Github并创建软件仓库，现在我们需要生成最终的页面并上传到自己的Github仓库中，完成站点的最终部署，只需要在www根目录输入：\nhugo  或没有配置好config.toml文件的话用：\nhugo --thmem=hyde --baseUrl=\u0026quot;http://用户名.github.io\u0026quot;  这样在www目录下会生成一个public文件夹用于发布正式的站点，进行下列操作上传所有文件：\ncd public git init git remote add origin https://github.com/用户名/用户名.github.io.git git add -A git commit -m \u0026quot;first commit\u0026quot; git push -u origin master  过程中会要求用户输入github的用户名和密码，密码是隐式的，所以别以为没输入。上传成功后，只要在浏览器中输入http://用户名.github.io即可访问你自己的站点了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/java/",
	"title": "java",
	"tags": [],
	"description": "",
	"content": " java相关资料 "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/gis/jstutil/",
	"title": "java几何运算工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.vividsolutions\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jts\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.13\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  任意多边形相交面积\npublic static void main(String[] args) { // TODO Auto-generated method stub Coordinate[] coordinates1 = new Coordinate[]{ new Coordinate(125.72447156,39.82054423),new Coordinate(125.72447156,39.76282084), new Coordinate(125.77791891,39.76282084),new Coordinate(125.77791891,39.82054423), new Coordinate(125.72447156,39.82054423) }; Coordinate[] coordinates2 = new Coordinate[]{ new Coordinate(125.164119759729,40.0612609250715),new Coordinate(126.100803385316,39.9877343597289), new Coordinate(126.174165535013,39.2037784330532),new Coordinate(125.396225932331,39.2476580006858), new Coordinate(124.902255206616,39.7014452467443),new Coordinate(124.902267040602,39.7014536164514), new Coordinate(124.902267040602,39.7014536164514),new Coordinate(125.164119759729,40.0612609250715) }; /* Coordinate[] coordinates2 = new Coordinate[]{ new Coordinate(125,40),new Coordinate(125,38), new Coordinate(125.75,38),new Coordinate(125.75,40), new Coordinate(125,40) };*/ Geometry g1 = new GeometryFactory().createPolygon(coordinates1); Geometry g2 = new GeometryFactory().createPolygon(coordinates2); boolean isIter = g1.intersects(g2); if(isIter)System.out.println(\u0026quot;相交\u0026quot;); else System.out.println(\u0026quot;不相交\u0026quot;); Geometry g3 = g1.intersection(g2); Coordinate[] coordinates = g3.getCoordinates(); /* for(int i=0;i\u0026lt;coordinates.length;i++){ System.out.print(coordinates[i]); }*/ Geometry g4 = new GeometryFactory().createPolygon(coordinates); System.out.print(\u0026quot;g1-\u0026quot;+g1.getArea()); System.out.print(\u0026quot;g2-\u0026quot;+g2.getArea()); System.out.print(\u0026quot;g4-\u0026quot;+g4.getArea()); }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/",
	"title": "java工具类",
	"tags": [],
	"description": "",
	"content": " java工具类 "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/nexus3/",
	"title": "nexus3安装及使用",
	"tags": [],
	"description": "",
	"content": " Nexus3 安装：  Nexus3 运行时需要java8以上的环境，官方说不支持openjdk，但是我使用目前没有发现问题；\nNexus3允许为程序配置专用的jre环境，这样的话不会影响外部程序的运行。版本不一样也没问题。\n 只需要修改启动文件，/bin/nexus。 INSTALL4J_JAVA_HOME_OVERRIDE=/usr/lib/jvm/java-8-oracle\n 在linux安装 两种方式：docker安装，和包安装\n以下介绍包安装方式，nexus3没有硬编码目录，在任何目录下都可以运行，只需要解压tar包\n解压命令：\ntar -zxvf 包名  Nexus3开机自启动： 两种方式：主要区别是在linux系统的区别CentOS6,7\n6采用init.d,chkconfig的方式\nsudo ln -s $ NEXUS_HOME / bin / nexus /etc/init.d/nexus cd /etc/init.d sudo chkconfig --add nexus sudo chkconfig --levels 345 nexus on sudo service nexus start  第二种方式CentOS7，以服务 的方式运行\n编写nexus.service文件 ：\nvi /etc/systemd/system/nexus.service [Unit] Description=nexus service After=network.target [Service] Type=forking LimitNOFILE=65536 ExecStart=/opt/nexus/bin/nexus start ExecStop=/opt/nexus/bin/nexus stop User=nexus Restart=on-abort [Install] WantedBy=multi-user.target ：wq sudo systemctl daemon-reload sudo systemctl enable nexus.service sudo systemctl start nexus.service   之后就可以启动了\ntail -f /自定义目录/sonatype-work/nexus3/log/nexus.log\n可以看到启动成功的日志\n其他默认就好；\n此时，应该都已经设置好了：访问web界面：Ip：8081。 默认端口是8081.可以自定义修改\n它的用户名是 admin ，密码是 admin123。您可以使用用户界面右上角的按钮登录。\n 如果你只是安装自己玩玩，到这里就结束了。如果是实际使用，那就需要看下面的部分\n在服务器上，程序有两个目录\n安装目录。数据目录。\n安装目录\n $ ls -1 nexus-\u0026lt;version\u0026gt; LICENSE.txt NOTICE.txt bin deploy etc lib public system   LICENSE.txt 和 NOTICE.txt\n这些文件包含有关许可和版权声明的法律详细信息\nbin\n此目录包含 nexus 启动脚本本身以及与启动相关的配置文件\netc\n该目录包含配置文件\nlib\n该目录包含与Apache Karaf相关的二进制库\npublic\n该目录包含应用程序的公共资源\nsystem\n该目录包含构成应用程序的所有组件和插件\n数据目录 默认情况下找到的数据目录 ../sonatype-work/nexus3包含子目录，这些子目录包含存储库管理器提供的所有组件，存储库，配置和其他数据。子目录列为：\nblobs/\n这是blob存储的默认位置。如果在创建新的Blob存储库时提供了完全限定的路径，则它可能不会在此目录中结束。\ncache/\n此目录包含有关当前缓存的Karaf捆绑包的信息\ndb/\n此目录包含OrientDB数据库，它是存储库管理器元数据的主存储\nelasticsearch/\n此目录包含当前配置的Elasticsearch状态\netc/\n此目录包含存储库管理器的主运行时配置和自定义。配置运行时环境中进一步说明了这些文件 。\nhealth-check/\n此目录包含来自存储库运行状况检查功能的缓存报告\nkeystores/\n它包含用于标识存储库管理器的自动生成的密钥\nlog/\n此目录包含几个日志文件，用于捕获有关正在运行的存储库管理器的各个方面的信 在 nexus.log 和 request.log 文件旋转，所以每天这个目录也包含这些文件的归档副本。要回收磁盘空间，可以从logs目录中删除旧的日志文件。在此目录中找到的日志文件包括： nexus.log - 主存储库管理器应用程序日志。日志消息包含标准日志输出字段，包括日期/时间，日志级别，关联的线程，类和消息。\nrequest.log - 用于将http访问请求记录到正在运行的存储库管理器。日志消息包含客户端主机，用户和HTTP请求属性等信息，包括状态代码，字节和用户代理标头。\njvm.log - 包含JVM标准输出，stderr和线程转储消息\nkaraf.log - 这是Apache Karaf容器日志文件，其中包含特定于存储库管理器启动的消息\n该 log 目录还包含一个tasks 子目录，该 子目录包含运行的每个任务的单独的，唯一命名的（按日期，时间和任务名称）日志输出文件。有关 这些文件的命名策略和内容的更多详细信息，请参阅 任务日志记录。\ntmp/ -该目录用于临时存储\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/pm20/",
	"title": "pm2常用 命令",
	"tags": [],
	"description": "",
	"content": " 1. 启动 pm2 start app.js pm2 start app.js --name my-api #my-api为PM2进程名称 pm2 start app.js -i 0 #根据CPU核数启动进程个数 pm2 start app.js --watch #实时监控app.js的方式启动，当app.js文件有变动时，pm2会自动reload  2. 查看进程 pm2 list pm2 show 0 或者 # pm2 info 0 #查看进程详细信息，0为PM2进程id  3. 监控 pm2 monit  4. 停止 pm2 stop all #停止PM2列表中所有的进程 pm2 stop 0 #停止PM2列表中进程为0的进程  5. 重载 pm2 reload all #重载PM2列表中所有的进程 pm2 reload 0 #重载PM2列表中进程为0的进程  6. 重启 pm2 restart all #重启PM2列表中所有的进程 pm2 restart 0 #重启PM2列表中进程为0的进程  7. 删除PM2进程 pm2 delete 0 #删除PM2列表中进程为0的进程 pm2 delete all #删除PM2列表中所有的进程  8. 日志操作 pm2 logs [--raw] #Display all processes logs in streaming pm2 flush #Empty all log file pm2 reloadLogs #Reload all logs  9. 升级PM2 npm install pm2@lastest -g #安装最新的PM2版本 pm2 updatePM2 #升级pm2  10. 更多命令参数请查看帮助 pm2 --help  "
},
{
	"uri": "https://peterhan-enjoy.github.com/utils/verdaccio/",
	"title": "内网搭建npm私服",
	"tags": [],
	"description": "",
	"content": " 1、下载verdaccio 从github下载verdaccio，得到下载的包，之后拷贝到内网环境，在verdaccio文件目录下\nnpm install -g verdaccio --unsafe-perm  2、配置 C:\\Users\\用户名\\AppData\\Roaming\\verdaccio\\config.yaml 在末尾加listen: 0.0.0.0:4873，不配置的话只能本机访问。\n内网环境下将uplinks部分去掉或注释。\n3、启动 verdaccio  4、托管启动 安装pm2 从github下载pm2，得到下载的包，之后拷贝到内网环境，在pm2文件目录下\nnpm install npm link  使用pm2启动 pm2 start verdaccio  Pm2常用命令\n5、访问 访问localhost:4873,可以看到登录页面\n6、注册及登录 npm adduser –registry http://localhost:4873  如果已经配置了地址，则不需要\u0026ndash;registry部分，按照提示输入username，psd。\n7、公共组件打包 将写好的组件通过 npm run build打包，生成dist文件夹。 将路径切换到项目的dist的文件夹下，执行命令npm init，生成package.json,里面包含了版本，组件名等信息： 之后在npm上发布\nnpm publish --registry http://localhost:4873  之后在需要使用的项目下载\nnpm install table-two --registry=http://localhost:4873  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/decryptionziputil/",
	"title": "加密解压缩工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.lingala.zip4j\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;zip4j\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;   import net.lingala.zip4j.core.ZipFile; import net.lingala.zip4j.exception.ZipException; import net.lingala.zip4j.model.ZipParameters; import net.lingala.zip4j.util.Zip4jConstants; import java.io.File; /** * 压缩指定文件或目录为ZIP格式压缩文件 * 支持中文(修改源码后) * 支持密码(仅支持256bit的AES加密解密) * 依赖bcprov项目(bcprov-jdk16-140.jar) * * @author zyh */ public class DecryptionZipUtil { private static void zipFile() throws ZipException { // 生成的压缩文件 ZipFile zipFile = new ZipFile(\u0026quot;D:\\\\test.zip\u0026quot;); ZipParameters parameters = new ZipParameters(); // 压缩方式 parameters.setCompressionMethod(Zip4jConstants.COMP_DEFLATE); // 压缩级别 parameters.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL); parameters.setEncryptFiles( true ); parameters.setEncryptionMethod(Zip4jConstants.ENC_METHOD_AES); parameters.setAesKeyStrength(Zip4jConstants.AES_STRENGTH_256); parameters.setPassword(\u0026quot;111\u0026quot;); // 要打包的文件夹 File currentFile = new File(\u0026quot;D:\\\\test\u0026quot;); File[] fs = currentFile.listFiles(); // 遍历test文件夹下所有的文件、文件夹 for (File f : fs) { if (f.isDirectory()) { zipFile.addFolder(f.getPath(), parameters); } else { zipFile.addFile(f, parameters); } } } private static void unzip() { try { ZipFile zipFile = new ZipFile(\u0026quot;D:\\\\test.zip\u0026quot;); // 如果解压需要密码 if(zipFile.isEncrypted()) { zipFile.setPassword(\u0026quot;111\u0026quot;); } zipFile.extractAll(\u0026quot;D:\\\\test\u0026quot;); } catch (ZipException e) { e.printStackTrace(); } } /** * 测试 * @param args */ public static void main(String[] args) { try { DecryptionZipUtil.unzip(); }catch (Exception e){ e.printStackTrace(); } } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/singletonpattern/",
	"title": "单例模式",
	"tags": [],
	"description": "",
	"content": " 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。\n注意：\n1、单例类只能有一个实例。\n2、单例类必须自己创建自己的唯一实例。\n3、单例类必须给所有其他对象提供这一实例。\n介绍 意图：保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n主要解决：一个全局使用的类频繁地创建与销毁。\n何时使用：当您想控制实例数目，节省系统资源的时候。\n如何解决：判断系统是否已经有这个单例，如果有则返回，如果没有则创建。\n关键代码：构造函数是私有的。\n应用实例：\n1、一个班级只有一个班主任。\n2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。\n3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。\n优点：\n1、在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。\n2、避免对资源的多重占用（比如写文件操作）。\n缺点：没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。\n使用场景：\n1、要求生产唯一序列号。\n2、WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。\n3、创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。 注意事项：getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。\n实现 我们将创建一个 SingleObject 类。SingleObject 类有它的私有构造函数和本身的一个静态实例。\nSingleObject 类提供了一个静态方法，供外界获取它的静态实例。SingletonPatternDemo，我们的演示类使用 SingleObject 类来获取 SingleObject 对象。 步骤 1 public class SingleObject { //创建 SingleObject 的一个对象 private static SingleObject instance = new SingleObject(); //让构造函数为 private，这样该类就不会被实例化 private SingleObject(){} //获取唯一可用的对象 public static SingleObject getInstance(){ return instance; } public void showMessage(){ System.out.println(\u0026quot;Hello World!\u0026quot;); } }  步骤 2 创建 Observer 类。\npublic class SingletonPatternDemo { public static void main(String[] args) { //不合法的构造函数 //编译时错误：构造函数 SingleObject() 是不可见的 //SingleObject object = new SingleObject(); //获取唯一可用的对象 SingleObject object = SingleObject.getInstance(); //显示消息 object.showMessage(); } }  步骤 3 Hello World!  单例模式的几种实现方式 1、懒汉式，线程不安全 是否 Lazy 初始化：是\n是否多线程安全：否\n实现难度：易\n描述：这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。 这种方式 lazy loading 很明显，不要求线程安全，在多线程不能正常工作。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  接下来介绍的几种实现方式都支持多线程，但是在性能上有所差异。\n2、懒汉式，线程安全 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：易\n描述：这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。 优点：第一次调用才初始化，避免内存浪费。 缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。 getInstance() 的性能对应用程序不是很关键（该方法使用不太频繁）。\n实例\npublic class Singleton { private static Singleton instance; private Singleton (){} public static synchronized Singleton getInstance() { if (instance == null) { instance = new Singleton(); } return instance; } }  3、饿汉式 是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种方式比较常用，但容易产生垃圾对象。 优点：没有加锁，执行效率会提高。 缺点：类加载时就初始化，浪费内存。 它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。\n实例\npublic class Singleton { private static Singleton instance = new Singleton(); private Singleton (){} public static Singleton getInstance() { return instance; } }  4、双检锁/双重校验锁（DCL，即 double-checked locking） JDK 版本：JDK1.5 起\n是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：较复杂\n描述：这种方式采用双锁机制，安全且在多线程情况下能保持高性能。 getInstance() 的性能对应用程序很关键。\n实例\npublic class Singleton { private volatile static Singleton singleton; private Singleton (){} public static Singleton getSingleton() { if (singleton == null) { synchronized (Singleton.class) { if (singleton == null) { singleton = new Singleton(); } } } return singleton; } }  5、登记式/静态内部类 是否 Lazy 初始化：是\n是否多线程安全：是\n实现难度：一般\n描述：这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。 这种方式同样利用了 classloader 机制来保证初始化 instance 时只有一个线程，它跟第 3 种方式不同的是：第 3 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 3 种方式就显得很合理。\n实例\npublic class Singleton { private static class SingletonHolder { private static final Singleton INSTANCE = new Singleton(); } private Singleton (){} public static final Singleton getInstance() { return SingletonHolder.INSTANCE; } }  6、枚举 JDK 版本：JDK1.5 起\n是否 Lazy 初始化：否\n是否多线程安全：是\n实现难度：易\n描述：这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。 这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。 不能通过 reflection attack 来调用私有构造方法。\n实例\npublic enum Singleton { INSTANCE; public void whateverMethod() { } }  经验之谈：一般情况下，不建议使用第 1 种和第 2 种懒汉方式，建议使用第 3 种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用第 5 种登记方式。如果涉及到反序列化创建对象时，可以尝试使用第 6 种枚举方式。如果有其他特殊的需求，可以考虑使用第 4 种双检锁方式。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/commandpattern/",
	"title": "命令模式",
	"tags": [],
	"description": "",
	"content": " 命令模式（Command Pattern）是一种数据驱动的设计模式，它属于行为型模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。\n介绍 意图：将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。\n主要解决：在软件系统中，行为请求者与行为实现者通常是一种紧耦合的关系，但某些场合，比如需要对行为进行记录、撤销或重做、事务等处理时，这种无法抵御变化的紧耦合的设计就不太合适。\n何时使用：在某些场合，比如要对行为进行\u0026rdquo;记录、撤销/重做、事务\u0026rdquo;等处理，这种无法抵御变化的紧耦合是不合适的。在这种情况下，如何将\u0026rdquo;行为请求者\u0026rdquo;与\u0026rdquo;行为实现者\u0026rdquo;解耦？将一组行为抽象为对象，可以实现二者之间的松耦合。\n如何解决：通过调用者调用接受者执行命令，顺序：调用者→接受者→命令。\n关键代码：定义三个角色：1、received 真正的命令执行对象 2、Command 3、invoker 使用命令对象的入口\n应用实例：struts 1 中的 action 核心控制器 ActionServlet 只有一个，相当于 Invoker，而模型层的类会随着不同的应用有不同的模型类，相当于具体的 Command。\n优点： 1、降低了系统耦合度。 2、新的命令可以很容易添加到系统中去。\n缺点：使用命令模式可能会导致某些系统有过多的具体命令类。\n使用场景：认为是命令的地方都可以使用命令模式，比如： 1、GUI 中每一个按钮都是一条命令。 2、模拟 CMD。\n注意事项：系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作，也可以考虑使用命令模式，见命令模式的扩展。\n实现 我们首先创建作为命令的接口 Order，然后创建作为请求的 Stock 类。实体命令类 BuyStock 和 SellStock，实现了 Order 接口，将执行实际的命令处理。创建作为调用对象的类 Broker，它接受订单并能下订单。\nBroker 对象使用命令模式，基于命令的类型确定哪个对象执行哪个命令。CommandPatternDemo，我们的演示类使用 Broker 类来演示命令模式。 步骤 1 创建一个接口：\npublic interface Order { void execute(); }  步骤 2 创建一个请求类。\npublic class Stock { private String name = \u0026quot;ABC\u0026quot;; private int quantity = 10; public void buy(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] bought\u0026quot;); } public void sell(){ System.out.println(\u0026quot;Stock [ Name: \u0026quot;+name+\u0026quot;, Quantity: \u0026quot; + quantity +\u0026quot; ] sold\u0026quot;); } }  步骤 3 创建实现了 Order 接口的实体类。\npublic class BuyStock implements Order { private Stock abcStock; public BuyStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.buy(); } }  public class SellStock implements Order { private Stock abcStock; public SellStock(Stock abcStock){ this.abcStock = abcStock; } public void execute() { abcStock.sell(); } }  步骤 4 创建命令调用类。\nimport java.util.ArrayList; import java.util.List; public class Broker { private List\u0026lt;Order\u0026gt; orderList = new ArrayList\u0026lt;Order\u0026gt;(); public void takeOrder(Order order){ orderList.add(order); } public void placeOrders(){ for (Order order : orderList) { order.execute(); } orderList.clear(); } }  步骤 5 使用 Broker 类来接受并执行命令。\npublic class CommandPatternDemo { public static void main(String[] args) { Stock abcStock = new Stock(); BuyStock buyStockOrder = new BuyStock(abcStock); SellStock sellStockOrder = new SellStock(abcStock); Broker broker = new Broker(); broker.takeOrder(buyStockOrder); broker.takeOrder(sellStockOrder); broker.placeOrders(); } }  步骤 6 执行程序，输出结果：\nStock [ Name: ABC, Quantity: 10 ] bought Stock [ Name: ABC, Quantity: 10 ] sold  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/base64util/",
	"title": "图片base64转换工具类",
	"tags": [],
	"description": "",
	"content": " import java.io.ByteArrayOutputStream; public class Base64Util { private static byte[] base64DecodeChars = new byte[] { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, -1, -1, -1, -1, -1 }; private static char[] codec_table = { 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '/' }; public static byte[] decode(String str) { byte[] data = str.getBytes(); int len = data.length; ByteArrayOutputStream buf = new ByteArrayOutputStream(len); int i = 0; int b1, b2, b3, b4; while (i \u0026lt; len) { do { b1 = base64DecodeChars[data[i++]]; } while (i \u0026lt; len \u0026amp;\u0026amp; b1 == -1); if (b1 == -1) { break; } do { b2 = base64DecodeChars[data[i++]]; } while (i \u0026lt; len \u0026amp;\u0026amp; b2 == -1); if (b2 == -1) { break; } buf.write((int) ((b1 \u0026lt;\u0026lt; 2) | ((b2 \u0026amp; 0x30) \u0026gt;\u0026gt;\u0026gt; 4))); do { b3 = data[i++]; if (b3 == 61) { return buf.toByteArray(); } b3 = base64DecodeChars[b3]; } while (i \u0026lt; len \u0026amp;\u0026amp; b3 == -1); if (b3 == -1) { break; } buf.write((int) (((b2 \u0026amp; 0x0f) \u0026lt;\u0026lt; 4) | ((b3 \u0026amp; 0x3c) \u0026gt;\u0026gt;\u0026gt; 2))); do { b4 = data[i++]; if (b4 == 61) { return buf.toByteArray(); } b4 = base64DecodeChars[b4]; } while (i \u0026lt; len \u0026amp;\u0026amp; b4 == -1); if (b4 == -1) { break; } buf.write((int) (((b3 \u0026amp; 0x03) \u0026lt;\u0026lt; 6) | b4)); } return buf.toByteArray(); } public static String encode(byte[] a) { int totalBits = a.length * 8; int nn = totalBits % 6; int curPos = 0; StringBuffer toReturn = new StringBuffer(); while(curPos \u0026lt; totalBits) { int bytePos = curPos / 8; switch (curPos % 8) { case 0: toReturn.append(codec_table[(a[bytePos] \u0026amp; 0xfc) \u0026gt;\u0026gt; 2]); break; case 2: toReturn.append(codec_table[(a[bytePos] \u0026amp; 0x3f)]); break; case 4: if (bytePos == a.length - 1) { toReturn.append(codec_table[((a[bytePos] \u0026amp; 0x0f) \u0026lt;\u0026lt; 2) \u0026amp; 0x3f]); } else { int pos = (((a[bytePos] \u0026amp; 0x0f) \u0026lt;\u0026lt; 2) | ((a[bytePos + 1] \u0026amp; 0xc0) \u0026gt;\u0026gt; 6)) \u0026amp; 0x3f; toReturn.append(codec_table[pos]); } break; case 6: if (bytePos == a.length - 1) { toReturn.append(codec_table[((a[bytePos] \u0026amp; 0x03) \u0026lt;\u0026lt; 4) \u0026amp; 0x3f]); } else { int pos = (((a[bytePos] \u0026amp; 0x03) \u0026lt;\u0026lt; 4) | ((a[bytePos + 1] \u0026amp; 0xf0) \u0026gt;\u0026gt; 4)) \u0026amp; 0x3f; toReturn.append(codec_table[pos]); } break; default: break; } curPos += 6; } if(nn == 2) { toReturn.append(\u0026quot;==\u0026quot;); }else if(nn == 4) { toReturn.append(\u0026quot;=\u0026quot;); } return toReturn.toString(); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/factorypattern/",
	"title": "工厂模式",
	"tags": [],
	"description": "",
	"content": " 工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。\n在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。\n介绍 意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。\n主要解决：主要解决接口选择的问题。\n何时使用：我们明确地计划不同条件下创建不同实例时。\n如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。\n关键代码：创建过程在其子类执行。\n应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。\n优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。\n缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。\n使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，\u0026rdquo;POP3\u0026rdquo;、\u0026rdquo;IMAP\u0026rdquo;、\u0026rdquo;HTTP\u0026rdquo;，可以把这三个作为产品类，共同实现一个接口。\n注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。\n实现 简单工厂模式 一个栗子： 我喜欢吃面条，抽象一个面条基类，(接口也可以)，这是产品的抽象类。\npublic abstract class INoodles { /** * 描述每种面条啥样的 */ public abstract void desc(); }  先来一份兰州拉面（具体的产品类）：\npublic class LzNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;兰州拉面 上海的好贵 家里才5 6块钱一碗\u0026quot;); } }  程序员加班必备也要吃泡面（具体的产品类）：\npublic class PaoNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;泡面好吃 可不要贪杯\u0026quot;); } }  还有我最爱吃的家乡的干扣面（具体的产品类）：\npublic class GankouNoodles extends INoodles { @Override public void desc() { System.out.println(\u0026quot;还是家里的干扣面好吃 6块一碗\u0026quot;); } }  准备工作做完了，我们来到一家“简单面馆”（简单工厂类），菜单如下：\npublic class SimpleNoodlesFactory { public static final int TYPE_LZ = 1;//兰州拉面 public static final int TYPE_PM = 2;//泡面 public static final int TYPE_GK = 3;//干扣面 public static INoodles createNoodles(int type) { switch (type) { case TYPE_LZ: return new LzNoodles(); case TYPE_PM: return new PaoNoodles(); case TYPE_GK: default: return new GankouNoodles(); } } }  简单面馆就提供三种面条（产品），你说你要啥，他就给你啥。这里我点了一份干扣面:\n/** * 简单工厂模式 */ INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK); noodles.desc();  输出：\n还是家里的干扣面好吃 6块一碗  特点\n1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。\n2 create()方法通常是静态的，所以也称之为静态工厂。\n缺点 1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）\n2 不同的产品需要不同额外参数的时候 不支持。\n二、工厂方法模式\n1.模式描述 提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。\n2.模式作用 可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。\n可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。 可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。 等等。 另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。\n3.适用场景 消费者不关心它所要创建对象的类(产品类)的时候。\n消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。\n等等。\n例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。\n####### 4.模式要素 提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。 提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。 由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。\n5.模式实例代码 工厂：\npackage com.demoFound.factoryMethod.factory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_工厂接口 * * @author popkidorc * */ public interface IMyMessageFactory { public IMyMessage createMessage(String messageType); }  package com.demoFound.factoryMethod.factory; import java.util.HashMap; import java.util.Map; import com.demoFound.factoryMethod.message.IMyMessage; import com.demoFound.factoryMethod.message.MyMessageEmail; import com.demoFound.factoryMethod.message.MyMessageOaTodo; import com.demoFound.factoryMethod.message.MyMessageSms; /** * 工厂方法模式_工厂实现 * * @author popkidorc * */ public class MyMessageFactory implements IMyMessageFactory { @Override public IMyMessage createMessage(String messageType) { // 这里的方式是：消费者知道自己想要什么产品；若生产何种产品完全由工厂决定，则这里不应该传入控制生产的参数。 IMyMessage myMessage; Map\u0026lt;String, Object\u0026gt; messageParam = new HashMap\u0026lt;String, Object\u0026gt;(); // 根据某些条件去选择究竟创建哪一个具体的实现对象，条件可以传入的，也可以从其它途径获取。 // sms if (\u0026quot;SMS\u0026quot;.equals(messageType)) { myMessage = new MyMessageSms(); messageParam.put(\u0026quot;PHONENUM\u0026quot;, \u0026quot;123456789\u0026quot;); } else // OA待办 if (\u0026quot;OA\u0026quot;.equals(messageType)) { myMessage = new MyMessageOaTodo(); messageParam.put(\u0026quot;OAUSERNAME\u0026quot;, \u0026quot;testUser\u0026quot;); } else // email if (\u0026quot;EMAIL\u0026quot;.equals(messageType)) { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } else // 默认生产email这个产品 { myMessage = new MyMessageEmail(); messageParam.put(\u0026quot;EMAIL\u0026quot;, \u0026quot;test@test.com\u0026quot;); } myMessage.setMessageParam(messageParam); return myMessage; } }  产品：\npackage com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_产品接口 * * @author popkidorc * */ public interface IMyMessage { public Map\u0026lt;String, Object\u0026gt; getMessageParam(); public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam); public void sendMesage() throws Exception;// 发送通知/消息 }  package com.demoFound.factoryMethod.message; import java.util.Map; /** * 工厂方法模式_虚拟产品类 * * @author popkidorc * */ public abstract class MyAbstractMessage implements IMyMessage { private Map\u0026lt;String, Object\u0026gt; messageParam;// 这里可以理解为生产产品所需要的原材料库。最好是个自定义的对象，这里为了不引起误解使用Map。 @Override public Map\u0026lt;String, Object\u0026gt; getMessageParam() { return messageParam; } @Override public void setMessageParam(Map\u0026lt;String, Object\u0026gt; messageParam) { this.messageParam = messageParam; } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_email产品 * * @author popkidorc * */ public class MyMessageEmail extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;EMAIL\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;EMAIL\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入EMAIL参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外邮件内容，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是邮件，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;EMAIL\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_oa待办产品 * * @author popkidorc * */ public class MyMessageOaTodo extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;))) { throw new Exception(\u0026quot;发送OA待办,需要传入OAUSERNAME参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 这里的参数需求就比较多了不一一处理了 System.out .println(\u0026quot;我是OA待办，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;OAUSERNAME\u0026quot;)); } }  package com.demoFound.factoryMethod.message; /** * 工厂方法模式_sms产品 * * @author popkidorc * */ public class MyMessageSms extends MyAbstractMessage { @Override public void sendMesage() throws Exception { // TODO Auto-generated method stub if (null == getMessageParam() || null == getMessageParam().get(\u0026quot;PHONENUM\u0026quot;) || \u0026quot;\u0026quot;.equals(getMessageParam().get(\u0026quot;PHONENUM\u0026quot;))) { throw new Exception(\u0026quot;发送短信,需要传入PHONENUM参数\u0026quot;);// 为了简单起见异常也不自定义了 }// 另外短信信息，以及其他各种协议参数等等都要处理 System.out.println(\u0026quot;我是短信，发送通知给\u0026quot; + getMessageParam().get(\u0026quot;PHONENUM\u0026quot;)); } }  消费者：\npackage com.demoFound.factoryMethod; import com.demoFound.factoryMethod.factory.IMyMessageFactory; import com.demoFound.factoryMethod.factory.MyMessageFactory; import com.demoFound.factoryMethod.message.IMyMessage; /** * 工厂方法模式_消费者类 * * @author popkidorc * */ public class MyFactoryMethodMain { public static void main(String[] args) { IMyMessageFactory myMessageFactory = new MyMessageFactory(); IMyMessage myMessage; // 对于这个消费者来说，不用知道如何生产message这个产品，耦合度降低 try { // 先来一个短信通知 myMessage = myMessageFactory.createMessage(\u0026quot;SMS\u0026quot;); myMessage.sendMesage(); // 来一个oa待办 myMessage = myMessageFactory.createMessage(\u0026quot;OA\u0026quot;); myMessage.sendMesage(); // 来一个邮件通知 myMessage = myMessageFactory.createMessage(\u0026quot;EMAIL\u0026quot;); myMessage.sendMesage(); } catch (Exception e) { e.printStackTrace(); } } }  三、抽象工厂模式\n定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。\n类型：创建类模式\n类图：\n抽象工厂模式与工厂方法模式的区别\n抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。\n在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。\n在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。\n明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。\n抽象工厂模式代码\ninterface IProduct1 { public void show(); } interface IProduct2 { public void show(); } class Product1 implements IProduct1 { public void show() { System.out.println(\u0026quot;这是1型产品\u0026quot;); } } class Product2 implements IProduct2 { public void show() { System.out.println(\u0026quot;这是2型产品\u0026quot;); } } interface IFactory { public IProduct1 createProduct1(); public IProduct2 createProduct2(); } class Factory implements IFactory{ public IProduct1 createProduct1() { return new Product1(); } public IProduct2 createProduct2() { return new Product2(); } } public class Client { public static void main(String[] args){ IFactory factory = new Factory(); factory.createProduct1().show(); factory.createProduct2().show(); } }  抽象工厂模式的优点\n抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。\n抽象工厂模式的缺点 产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。\n适用场景 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。\n总结 无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。 所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。\n"
},
{
	"uri": "https://peterhan-enjoy.github.com/design/strategypattern/",
	"title": "策略模式",
	"tags": [],
	"description": "",
	"content": " 在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。这种类型的设计模式属于行为型模式。\n在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。\n介绍 意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。\n主要解决：在有多种算法相似的情况下，使用 if\u0026hellip;else 所带来的复杂和难以维护。\n何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。\n如何解决：将这些算法封装成一个一个的类，任意地替换。\n关键代码：实现同一个接口。\n应用实例： 1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。 2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。 3、JAVA AWT 中的 LayoutManager。\n优点： 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。\n缺点： 1、策略类会增多。 2、所有策略类都需要对外暴露。\n使用场景： 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。\n注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。\n实现 我们将创建一个定义活动的 Strategy 接口和实现了 Strategy 接口的实体策略类。Context 是一个使用了某种策略的类。\nStrategyPatternDemo，我们的演示类使用 Context 和策略对象来演示 Context 在它所配置或使用的策略改变时的行为变化。 步骤 1 创建一个接口。Strategy.java\npublic interface Strategy { public int doOperation(int num1, int num2); }  步骤 2 创建实现接口的实体类。OperationAdd.java\npublic class OperationAdd implements Strategy{ @Override public int doOperation(int num1, int num2) { return num1 + num2; } }  步骤 3 创建 Context 类。Context.java\npublic class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeStrategy(int num1, int num2){ return strategy.doOperation(num1, num2); } }  步骤 4 使用 Context 来查看当它改变策略 Strategy 时的行为变化。StrategyPatternDemo\npublic class StrategyPatternDemo { public static void main(String[] args) { Context context = new Context(new OperationAdd()); System.out.println(\u0026quot;10 + 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationSubstract()); System.out.println(\u0026quot;10 - 5 = \u0026quot; + context.executeStrategy(10, 5)); context = new Context(new OperationMultiply()); System.out.println(\u0026quot;10 * 5 = \u0026quot; + context.executeStrategy(10, 5)); } }  步骤 5 执行程序，输出结果：\n10 + 5 = 15 10 - 5 = 5 10 * 5 = 50  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/decoratorpattern/",
	"title": "装饰器模式",
	"tags": [],
	"description": "",
	"content": " 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。\n这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。\n我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。\n介绍 意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。\n主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。\n何时使用：在不想增加很多子类的情况下扩展类。\n如何解决：将具体功能职责划分，同时继承装饰者模式。\n关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。\n应用实例： 1、孙悟空有 72 变，当他变成\u0026rdquo;庙宇\u0026rdquo;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。\n优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。\n缺点：多层装饰比较复杂。\n使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。\n注意事项：可代替继承。\n实现 我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。\nRedShapeDecorator 是实现了 ShapeDecorator 的实体类。\nDecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。 步骤 1 创建一个接口：\npublic interface Shape { void draw(); }  步骤 2 创建实现接口的实体类。\npublic class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Rectangle\u0026quot;); } }  public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026quot;Shape: Circle\u0026quot;); } }  步骤 3 创建实现了 Shape 接口的抽象装饰类。\npublic abstract class ShapeDecorator implements Shape { protected Shape decoratedShape; public ShapeDecorator(Shape decoratedShape){ this.decoratedShape = decoratedShape; } public void draw(){ decoratedShape.draw(); } }  步骤 4 创建扩展了 ShapeDecorator 类的实体装饰类。\npublic class RedShapeDecorator extends ShapeDecorator { public RedShapeDecorator(Shape decoratedShape) { super(decoratedShape); } @Override public void draw() { decoratedShape.draw(); setRedBorder(decoratedShape); } private void setRedBorder(Shape decoratedShape){ System.out.println(\u0026quot;Border Color: Red\u0026quot;); } }  步骤 5 使用 RedShapeDecorator 来装饰 Shape 对象。\npublic class DecoratorPatternDemo { public static void main(String[] args) { Shape circle = new Circle(); ShapeDecorator redCircle = new RedShapeDecorator(new Circle()); ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle()); //Shape redCircle = new RedShapeDecorator(new Circle()); //Shape redRectangle = new RedShapeDecorator(new Rectangle()); System.out.println(\u0026quot;Circle with normal border\u0026quot;); circle.draw(); System.out.println(\u0026quot;\\nCircle of red border\u0026quot;); redCircle.draw(); System.out.println(\u0026quot;\\nRectangle of red border\u0026quot;); redRectangle.draw(); } }  步骤 6 执行程序，输出结果：\nCircle with normal border Shape: Circle Circle of red border Shape: Circle Border Color: Red Rectangle of red border Shape: Rectangle Border Color: Red  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/observerpattern/",
	"title": "观察者模式",
	"tags": [],
	"description": "",
	"content": " 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。\n介绍 意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。\n主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。\n何时使用：一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。\n如何解决：使用面向对象技术，可以将这种依赖关系弱化。\n关键代码：在抽象类里有一个 ArrayList 存放观察者们。\n应用实例： 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。\n优点： 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。\n缺点： 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。\n使用场景：\n一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。 一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。 一个对象必须通知其他对象，而并不知道这些对象是谁。 需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。 注意事项： 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。\n实现 观察者模式使用三个类 Subject、Observer 和 Client。Subject 对象带有绑定观察者到 Client 对象和从 Client 对象解绑观察者的方法。我们创建 Subject 类、Observer 抽象类和扩展了抽象类 Observer 的实体类。\nObserverPatternDemo，我们的演示类使用 Subject 和实体类对象来演示观察者模式。 步骤 1 创建 Subject 类。\nimport java.util.ArrayList; import java.util.List; public class Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; notifyAllObservers(); } public void attach(Observer observer){ observers.add(observer); } public void notifyAllObservers(){ for (Observer observer : observers) { observer.update(); } } }  步骤 2 创建 Observer 类。\npublic abstract class Observer { protected Subject subject; public abstract void update(); }  步骤 3 创建实体观察者类。\npublic class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Binary String: \u0026quot; + Integer.toBinaryString( subject.getState() ) ); } }  public class OctalObserver extends Observer{ public OctalObserver(Subject subject){ this.subject = subject; this.subject.attach(this); } @Override public void update() { System.out.println( \u0026quot;Octal String: \u0026quot; + Integer.toOctalString( subject.getState() ) ); } }  步骤 4 使用 Subject 和实体观察者对象。\npublic class ObserverPatternDemo { public static void main(String[] args) { Subject subject = new Subject(); new HexaObserver(subject); new OctalObserver(subject); new BinaryObserver(subject); System.out.println(\u0026quot;First state change: 15\u0026quot;); subject.setState(15); System.out.println(\u0026quot;Second state change: 10\u0026quot;); subject.setState(10); } }  步骤 5 执行程序，输出结果：\nFirst state change: 15 Hex String: F Octal String: 17 Binary String: 1111 Second state change: 10 Hex String: A Octal String: 12 Binary String: 1010  java内置观察者 实现观察者模式 实现观察者模式非常简单， [1]创建被观察者类，它继承自java.util.Observable类； [2]创建观察者类，它实现java.util.Observer接口；\n对于被观察者类： 添加它的观察者： void addObserver(Observer o) addObserver()方法把观察者对象添加到观察者对象列表中\n当被观察者中的事件发生变化时，执行 setChanged(); notifyObservers(); setChange()方法用来设置一个内部标志位注明数据发生了变化；notifyObservers()方法会去调用观察者对象列表中所有的Observer的update()方法，通知它们数据发生了变化。 只有在setChange()被调用后，notifyObservers()才会去调用update()。\n对于观察者类，实现Observer接口的唯一方法update void update(Observable o, Object arg)\n形参Object arg，对应一个由notifyObservers(Object arg);传递来的参数，当执行的是notifyObservers();时，arg为null。\n被观察者 package com.test.observer; import java.util.Observable; public class ServerManager extends Observable { private int data = 0; public int getData(){ return data; } public void setData(int i){ if(this.data != i){ this.data = i;setChanged();} notifyObservers(); //只有在setChange()被调用后，notifyObservers()才会去调用update()，否则什么都不干。 } } } }  观察者1 import java.util.Observable; import java.util.Observer; public class AObserver implements Observer { public AObserver(ServerManager sm) { super(); // TODO Auto-generated constructor stub sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable arg0, Object arg1) { System.out.println(\u0026quot;AObserver receive:Data has changed to \u0026quot;+((ServerManager) arg0).getData()); } }  观察者2 import java.util.Observable; import java.util.Observer; public class BObserver implements Observer { public BObserver(ServerManager sm) { super(); sm.addObserver(this);　//注册加入观察者 } @Override public void update(Observable o, Object arg) { // TODO Auto-generated method stub System.out.println(\u0026quot;BObserver receive:Data has changed to \u0026quot;+((ServerManager) o).getData()); } }  测试 public class TestDemo { public static void main(String[] args) { // TODO Auto-generated method stub ServerManager sm = new ServerManager(); AObserver a = new AObserver(sm); BObserver b = new BObserver(sm); sm.setData(5); sm.deleteObserver(a);　//注销观察者，以后被观察者有数据变化就不再通知这个已注销的观察者 sm.setData(10); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/java/javautils/zipfileutil/",
	"title": "解压缩工具类",
	"tags": [],
	"description": "",
	"content": "\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.axet\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-unrar\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.7.0-8\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-logging\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-logging\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  import java.io.*; import java.util.ArrayList; import java.util.List; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream; import de.innosystec.unrar.NativeStorage; import org.apache.tools.ant.Project; import org.apache.tools.ant.taskdefs.Expand; import de.innosystec.unrar.Archive; import de.innosystec.unrar.rarfile.FileHeader; public class ZipFileUtil { private static final int BUFFER_SIZE = 2 * 1024; /** * 解压zip格式压缩包 * 对应的是ant.jar */ private static void unzip(String sourceZip,String destDir) throws Exception{ try{ Project p = new Project(); Expand e = new Expand(); e.setProject(p); e.setSrc(new File(sourceZip)); e.setOverwrite(false); e.setDest(new File(destDir)); /* ant下的zip工具默认压缩编码为UTF-8编码， 而winRAR软件压缩是用的windows默认的GBK或者GB2312编码 所以解压缩时要制定编码格式 */ e.setEncoding(\u0026quot;gbk\u0026quot;); e.execute(); }catch(Exception e){ throw e; } } /** * 解压rar格式压缩包。 * 对应的是java-unrar-0.3.jar，但是java-unrar-0.3.jar又会用到commons-logging-1.1.1.jar */ private static void unrar(String sourceRar,String destDir) throws Exception{ Archive a = null; FileOutputStream fos = null; try{ NativeStorage nativeStorage = new NativeStorage(new File(sourceRar)); a = new Archive(nativeStorage); FileHeader fh = a.nextFileHeader(); while(fh!=null){ if(!fh.isDirectory()){ //1 根据不同的操作系统拿到相应的 destDirName 和 destFileName String compressFileName = fh.getFileNameString().trim(); String destFileName = \u0026quot;\u0026quot;; String destDirName = \u0026quot;\u0026quot;; //非windows系统 if(File.separator.equals(\u0026quot;/\u0026quot;)){ destFileName = destDir + compressFileName.replaceAll(\u0026quot;\\\\\\\\\u0026quot;, \u0026quot;/\u0026quot;); destDirName = destFileName.substring(0, destFileName.lastIndexOf(\u0026quot;/\u0026quot;)); //windows系统 }else{ destFileName = destDir + compressFileName.replaceAll(\u0026quot;/\u0026quot;, \u0026quot;\\\\\\\\\u0026quot;); destDirName = destFileName.substring(0, destFileName.lastIndexOf(\u0026quot;\\\\\u0026quot;)); } //2创建文件夹 File dir = new File(destDirName); if(!dir.exists()||!dir.isDirectory()){ dir.mkdirs(); } //3解压缩文件 fos = new FileOutputStream(new File(destFileName)); a.extractFile(fh, fos); fos.close(); fos = null; } fh = a.nextFileHeader(); } a.close(); a = null; }catch(Exception e){ throw e; }finally{ if(fos!=null){ try{fos.close();fos=null;}catch(Exception e){e.printStackTrace();} } if(a!=null){ try{a.close();a=null;}catch(Exception e){e.printStackTrace();} } } } /** * 解压缩 */ public static void deCompress(String sourceFile,String destDir) throws Exception{ //保证文件夹路径最后是\u0026quot;/\u0026quot;或者\u0026quot;\\\u0026quot; char lastChar = destDir.charAt(destDir.length()-1); if(lastChar!='/'\u0026amp;\u0026amp;lastChar!='\\\\'){ destDir += File.separator; } //根据类型，进行相应的解压缩 String type = sourceFile.substring(sourceFile.lastIndexOf(\u0026quot;.\u0026quot;)+1); if(type.equals(\u0026quot;zip\u0026quot;)){ ZipFileUtil.unzip(sourceFile, destDir); }else if(type.equals(\u0026quot;rar\u0026quot;)){ ZipFileUtil.unrar(sourceFile, destDir); }else{ throw new Exception(\u0026quot;只支持zip和rar格式的压缩包！\u0026quot;); } } /** * 压缩成ZIP 方法1 * @param srcDir 压缩文件夹路径 * @param out 压缩文件输出流 * @param KeepDirStructure 是否保留原来的目录结构,true:保留目录结构; * false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败) * @throws RuntimeException 压缩失败会抛出运行时异常 */ public static void toZip(String srcDir, OutputStream out, boolean KeepDirStructure) throws RuntimeException{ long start = System.currentTimeMillis(); ZipOutputStream zos = null ; try { zos = new ZipOutputStream(out); File sourceFile = new File(srcDir); compress(sourceFile,zos,sourceFile.getName(),KeepDirStructure); long end = System.currentTimeMillis(); System.out.println(\u0026quot;压缩完成，耗时：\u0026quot; + (end - start) +\u0026quot; ms\u0026quot;); } catch (Exception e) { throw new RuntimeException(\u0026quot;zip error from ZipUtils\u0026quot;,e); }finally{ if(zos != null){ try { zos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 压缩成ZIP 方法2 * @param srcFiles 需要压缩的文件列表 * @param out 压缩文件输出流 * @throws RuntimeException 压缩失败会抛出运行时异常 */ public static void toZip(List\u0026lt;File\u0026gt; srcFiles , OutputStream out)throws RuntimeException { long start = System.currentTimeMillis(); ZipOutputStream zos = null ; try { zos = new ZipOutputStream(out); for (File srcFile : srcFiles) { byte[] buf = new byte[BUFFER_SIZE]; zos.putNextEntry(new ZipEntry(srcFile.getName())); int len; FileInputStream in = new FileInputStream(srcFile); while ((len = in.read(buf)) != -1){ zos.write(buf, 0, len); } zos.closeEntry(); in.close(); } long end = System.currentTimeMillis(); System.out.println(\u0026quot;压缩完成，耗时：\u0026quot; + (end - start) +\u0026quot; ms\u0026quot;); } catch (Exception e) { throw new RuntimeException(\u0026quot;zip error from ZipUtils\u0026quot;,e); }finally{ if(zos != null){ try { zos.close(); } catch (IOException e) { e.printStackTrace(); } } } } /** * 递归压缩方法 * @param sourceFile 源文件 * @param zos zip输出流 * @param name 压缩后的名称 * @param KeepDirStructure 是否保留原来的目录结构,true:保留目录结构; * false:所有文件跑到压缩包根目录下(注意：不保留目录结构可能会出现同名文件,会压缩失败) * @throws Exception */ private static void compress(File sourceFile, ZipOutputStream zos, String name, boolean KeepDirStructure) throws Exception{ byte[] buf = new byte[BUFFER_SIZE]; if(sourceFile.isFile()){ // 向zip输出流中添加一个zip实体，构造器中name为zip实体的文件的名字 zos.putNextEntry(new ZipEntry(name)); // copy文件到zip输出流中 int len; FileInputStream in = new FileInputStream(sourceFile); while ((len = in.read(buf)) != -1){ zos.write(buf, 0, len); } // Complete the entry zos.closeEntry(); in.close(); } else { File[] listFiles = sourceFile.listFiles(); if(listFiles == null || listFiles.length == 0){ // 需要保留原来的文件结构时,需要对空文件夹进行处理 if(KeepDirStructure){ // 空文件夹的处理 zos.putNextEntry(new ZipEntry(name + \u0026quot;/\u0026quot;)); // 没有文件，不需要文件的copy zos.closeEntry(); } }else { for (File file : listFiles) { // 判断是否需要保留原来的文件结构 if (KeepDirStructure) { // 注意：file.getName()前面需要带上父文件夹的名字加一斜杠, // 不然最后压缩包中就不能保留原来的文件结构,即：所有文件都跑到压缩包根目录下了 compress(file, zos, name + \u0026quot;/\u0026quot; + file.getName(),KeepDirStructure); } else { compress(file, zos, file.getName(),KeepDirStructure); } } } } } public static void main(String[] args) throws FileNotFoundException { /* try { ZipFileUtil.deCompress(\u0026quot;H:\\\\test\\\\1.rar\u0026quot;,\u0026quot;H:\\\\test\u0026quot;); } catch (Exception e) { e.printStackTrace(); }*/ File file = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); File file2 = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); File file3 = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); File file4 = new File(\u0026quot;D:\\\\PeterHan\\\\test.shp\u0026quot;); List\u0026lt;File\u0026gt; files = new ArrayList\u0026lt;\u0026gt;(); files.add(file); files.add(file2); files.add(file3); files.add(file4); FileOutputStream fos = new FileOutputStream(new File(\u0026quot;D:\\\\PeterHan\\\\test.zip\u0026quot;);); toZip(files,fos); } }  "
},
{
	"uri": "https://peterhan-enjoy.github.com/design/",
	"title": "设计模式",
	"tags": [],
	"description": "",
	"content": "设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。\n"
}]
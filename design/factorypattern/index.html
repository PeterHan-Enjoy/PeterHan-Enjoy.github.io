<!DOCTYPE html>
<html>
  <head>
    <title>PerHan_Enjoy</title>
    
      <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="revised" content="2019-07-19T16:48:14 CST">
<title>工厂模式 :: PerHan_Enjoy</title>
<link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />
<link href="/css/font-awesome.min.css" rel="stylesheet">
<link href="/css/nucleus.css" rel="stylesheet">
<link href="/theme-flex/style.css" rel="stylesheet">

<link rel="stylesheet" href="/css/bootstrap.min.css">
<script src="/js/jquery-2.x.min.js"></script>
<script type="text/javascript">
      var baseurl = "https:\/\/peterhan-enjoy.github.com\/";
</script>
<meta name="description" content="">



    
  </head>
  <body data-url="/design/factorypattern/">
    
      <header>
  <div class="logo">
    
	
  
    <a class="baselink" href="https://peterhan-enjoy.github.com/">PerHan_Enjoy</a>
  


  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>

</header>
<article>
  <aside>
    <ul class="menu">
          <li data-nav-id="/" class="dd-item">
          <a href="/">
            <i class="fa fa-fw fa-home"></i>
          </a>
          </li>
    <li data-nav-id="/utils/" class="dd-item haschildren
        ">
      <div>
      <a href="/utils/">工具类</a><i class="fa fa-angle-right fa-lg category-icon"></i><i class="fa fa-circle-thin read-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/utils/markdown/" class="dd-item">
        <div>
          <a href="/utils/markdown/">
            Markdown使用
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/docker/" class="dd-item">
        <div>
          <a href="/utils/docker/">
            docker 基本使用
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/gitlab/" class="dd-item">
        <div>
          <a href="/utils/gitlab/">
            gitlab 离线安装
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/hugo/" class="dd-item">
        <div>
          <a href="/utils/hugo/">
            hugo 搭建个人博客
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/nexus3/" class="dd-item">
        <div>
          <a href="/utils/nexus3/">
            nexus3安装及使用
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/pm20/" class="dd-item">
        <div>
          <a href="/utils/pm20/">
            pm2常用 命令
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/verdaccio/" class="dd-item">
        <div>
          <a href="/utils/verdaccio/">
            内网搭建npm私服
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/design/" class="dd-item parent haschildren
        ">
      <div>
      <a href="/design/">设计模式</a>
            <i class="fa fa-angle-down fa-lg category-icon"></i><i class="fa fa-circle-thin read-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/design/singletonpattern/" class="dd-item">
        <div>
          <a href="/design/singletonpattern/">
            单例模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/commandpattern/" class="dd-item">
        <div>
          <a href="/design/commandpattern/">
            命令模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/factorypattern/" class="dd-item active">
        <div>
          <a href="/design/factorypattern/">
            工厂模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/strategypattern/" class="dd-item">
        <div>
          <a href="/design/strategypattern/">
            策略模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/decoratorpattern/" class="dd-item">
        <div>
          <a href="/design/decoratorpattern/">
            装饰器模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/observerpattern/" class="dd-item">
        <div>
          <a href="/design/observerpattern/">
            观察者模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
        </ul>
    </li>




    </ul>
    <section>
    </section>
  </aside>
  <section class="page">

    <div class="nav-select">
      <center>Navigation :
        <select onchange="javascript:location.href = this.value;">
          
    <option value="/utils/" >
   工具类</option>
    <option value="/design/" >
   设计模式</option> 
      <option value="/design/singletonpattern/" >- 单例模式</option>
      <option value="/design/commandpattern/" >- 命令模式</option>
      <option value="/design/factorypattern/"  selected>- 工厂模式</option>
      <option value="/design/strategypattern/" >- 策略模式</option>
      <option value="/design/decoratorpattern/" >- 装饰器模式</option>
      <option value="/design/observerpattern/" >- 观察者模式</option>
  



        </select>
      </center>
    </div>
      <div>
        <div class="searchbox">
          <input data-search-input id="search-by" type="text" placeholder="Search...">
        </div>
        <script type="text/javascript" src="/js/lunr.min.js"></script>
        <script type="text/javascript" src="/js/auto-complete.js"></script>
        <link href="/css/auto-complete.css" rel="stylesheet">
        <script type="text/javascript">
          
              var baseurl = "https:\/\/peterhan-enjoy.github.com\/";
          
        </script>
        <script type="text/javascript" src="/js/search.js"></script>
      </div>


    <h1>工厂模式</h1>

    
    
    
    

<p>工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>

<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>

<hr />

<h4 id="介绍">介绍</h4>

<p>意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>

<p>主要解决：主要解决接口选择的问题。</p>

<p>何时使用：我们明确地计划不同条件下创建不同实例时。</p>

<p>如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。</p>

<p>关键代码：创建过程在其子类执行。</p>

<p>应用实例： 1、您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。 2、Hibernate 换数据库只需换方言和驱动就可以。</p>

<p>优点： 1、一个调用者想创建一个对象，只要知道其名称就可以了。 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 3、屏蔽产品的具体实现，调用者只关心产品的接口。</p>

<p>缺点：每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>

<p>使用场景： 1、日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 2、数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 3、设计一个连接服务器的框架，需要三个协议，&rdquo;POP3&rdquo;、&rdquo;IMAP&rdquo;、&rdquo;HTTP&rdquo;，可以把这三个作为产品类，共同实现一个接口。</p>

<p>注意事项：作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。</p>

<hr />

<h4 id="实现">实现</h4>

<h5 id="简单工厂模式">简单工厂模式</h5>

<p>一个栗子：
我喜欢吃面条，抽象一个面条基类，(接口也可以)，这是产品的抽象类。</p>

<pre><code>public abstract class INoodles {
    /**
     * 描述每种面条啥样的
     */
    public abstract void desc();
}
</code></pre>

<p>先来一份兰州拉面（具体的产品类）：</p>

<pre><code>public class LzNoodles extends INoodles {
    @Override
    public void desc() {
        System.out.println(&quot;兰州拉面 上海的好贵 家里才5 6块钱一碗&quot;);
    }
}
</code></pre>

<p>程序员加班必备也要吃泡面（具体的产品类）：</p>

<pre><code>public class PaoNoodles extends INoodles {
    @Override
    public void desc() {
        System.out.println(&quot;泡面好吃 可不要贪杯&quot;);
    }
}
</code></pre>

<p>还有我最爱吃的家乡的干扣面（具体的产品类）：</p>

<pre><code>public class GankouNoodles extends INoodles {
    @Override
    public void desc() {
        System.out.println(&quot;还是家里的干扣面好吃 6块一碗&quot;);
    }
}
</code></pre>

<p>准备工作做完了，我们来到一家“简单面馆”（简单工厂类），菜单如下：</p>

<pre><code>public class SimpleNoodlesFactory {
    public static final int TYPE_LZ = 1;//兰州拉面
    public static final int TYPE_PM = 2;//泡面
    public static final int TYPE_GK = 3;//干扣面

    public static INoodles createNoodles(int type) {
        switch (type) {
            case TYPE_LZ:
                return new LzNoodles();
            case TYPE_PM:
                return new PaoNoodles();
            case TYPE_GK:
            default:
                return new GankouNoodles();
        }
    }
}
</code></pre>

<p>简单面馆就提供三种面条（产品），你说你要啥，他就给你啥。这里我点了一份干扣面:</p>

<pre><code>/**
 * 简单工厂模式
 */
 INoodles noodles = SimpleNoodlesFactory.createNoodles(SimpleNoodlesFactory.TYPE_GK);
 noodles.desc();
</code></pre>

<p>输出：</p>

<pre><code>还是家里的干扣面好吃 6块一碗
</code></pre>

<p>特点<br />
1 它是一个具体的类，非接口 抽象类。有一个重要的create()方法，利用if或者 switch创建产品并返回。</p>

<p>2 create()方法通常是静态的，所以也称之为静态工厂。</p>

<p>缺点
1 扩展性差（我想增加一种面条，除了新增一个面条产品类，还需要修改工厂类方法）</p>

<p>2 不同的产品需要不同额外参数的时候 不支持。</p>

<p>二、工厂方法模式</p>

<h6 id="1-模式描述">1.模式描述</h6>

<p>提供一个用于创建对象的接口(工厂接口)，让其实现类(工厂实现类)决定实例化哪一个类(产品类)，并且由该实现类创建对应类的实例。</p>

<h6 id="2-模式作用">2.模式作用</h6>

<p>可以一定程度上解耦，消费者和产品实现类隔离开，只依赖产品接口(抽象产品)，产品实现类如何改动与消费者完全无关。</p>

<p>可以一定程度增加扩展性，若增加一个产品实现，只需要实现产品接口，修改工厂创建产品的方法，消费者可以无感知（若消费者不关心具体产品是什么的情况）。
可以一定程度增加代码的封装性、可读性。清楚的代码结构，对于消费者来说很少的代码量就可以完成很多工作。
等等。
另外，抽象工厂才是实际意义的工厂模式，工厂方法只是抽象工厂的一个比较常见的情况。</p>

<h6 id="3-适用场景">3.适用场景</h6>

<p>消费者不关心它所要创建对象的类(产品类)的时候。</p>

<p>消费者知道它所要创建对象的类(产品类)，但不关心如何创建的时候。</p>

<p>等等。</p>

<p>例如：hibernate里通过sessionFactory创建session、通过代理方式生成ws客户端时，通过工厂构建报文中格式化数据的对象。</p>

<p>####### 4.模式要素
提供一个产品类的接口。产品类均要实现这个接口(也可以是abstract类，即抽象产品)。
提供一个工厂类的接口。工厂类均要实现这个接口(即抽象工厂)。
由工厂实现类创建产品类的实例。工厂实现类应有一个方法，用来实例化产品类。</p>

<h6 id="5-模式实例代码">5.模式实例代码</h6>

<p>工厂：</p>

<pre><code>package com.demoFound.factoryMethod.factory;  

import com.demoFound.factoryMethod.message.IMyMessage;  

/**
 * 工厂方法模式_工厂接口
 *  
 * @author popkidorc
 *  
 */  
public interface IMyMessageFactory {  

    public IMyMessage createMessage(String messageType);  
}  
</code></pre>

<pre><code>package com.demoFound.factoryMethod.factory;  

import java.util.HashMap;  
import java.util.Map;  

import com.demoFound.factoryMethod.message.IMyMessage;  
import com.demoFound.factoryMethod.message.MyMessageEmail;  
import com.demoFound.factoryMethod.message.MyMessageOaTodo;  
import com.demoFound.factoryMethod.message.MyMessageSms;  

/**
 * 工厂方法模式_工厂实现
 *  
 * @author popkidorc
 *  
 */  
public class MyMessageFactory implements IMyMessageFactory {  

    @Override  
    public IMyMessage createMessage(String messageType) {  
        // 这里的方式是：消费者知道自己想要什么产品；若生产何种产品完全由工厂决定，则这里不应该传入控制生产的参数。  
        IMyMessage myMessage;  
        Map&lt;String, Object&gt; messageParam = new HashMap&lt;String, Object&gt;();  
        // 根据某些条件去选择究竟创建哪一个具体的实现对象，条件可以传入的，也可以从其它途径获取。  
        // sms  
        if (&quot;SMS&quot;.equals(messageType)) {  
            myMessage = new MyMessageSms();  
            messageParam.put(&quot;PHONENUM&quot;, &quot;123456789&quot;);  
        } else  
        // OA待办  
        if (&quot;OA&quot;.equals(messageType)) {  
            myMessage = new MyMessageOaTodo();  
            messageParam.put(&quot;OAUSERNAME&quot;, &quot;testUser&quot;);  
        } else  
        // email  
        if (&quot;EMAIL&quot;.equals(messageType)) {  
            myMessage = new MyMessageEmail();  
            messageParam.put(&quot;EMAIL&quot;, &quot;test@test.com&quot;);  
        } else  
        // 默认生产email这个产品  
        {  
            myMessage = new MyMessageEmail();  
            messageParam.put(&quot;EMAIL&quot;, &quot;test@test.com&quot;);  
        }  
        myMessage.setMessageParam(messageParam);  
        return myMessage;  
    }  
}
</code></pre>

<p>产品：</p>

<pre><code>package com.demoFound.factoryMethod.message;  

import java.util.Map;  

/**
 * 工厂方法模式_产品接口
 *  
 * @author popkidorc
 *  
 */  
public interface IMyMessage {  

    public Map&lt;String, Object&gt; getMessageParam();  

    public void setMessageParam(Map&lt;String, Object&gt; messageParam);  

    public void sendMesage() throws Exception;// 发送通知/消息  

}  
</code></pre>

<pre><code>package com.demoFound.factoryMethod.message;  

import java.util.Map;  

/**
 * 工厂方法模式_虚拟产品类
 *  
 * @author popkidorc
 *  
 */  
public abstract class MyAbstractMessage implements IMyMessage {  

    private Map&lt;String, Object&gt; messageParam;// 这里可以理解为生产产品所需要的原材料库。最好是个自定义的对象，这里为了不引起误解使用Map。  

    @Override  
    public Map&lt;String, Object&gt; getMessageParam() {  
        return messageParam;  
    }  

    @Override  
    public void setMessageParam(Map&lt;String, Object&gt; messageParam) {  
        this.messageParam = messageParam;  
    }  
}  
</code></pre>

<pre><code>package com.demoFound.factoryMethod.message;  

/**
 * 工厂方法模式_email产品
 *  
 * @author popkidorc
 *  
 */  
public class MyMessageEmail extends MyAbstractMessage {  

    @Override  
    public void sendMesage() throws Exception {  
        // TODO Auto-generated method stub  
        if (null == getMessageParam() || null == getMessageParam().get(&quot;EMAIL&quot;)  
                || &quot;&quot;.equals(getMessageParam().get(&quot;EMAIL&quot;))) {  
            throw new Exception(&quot;发送短信,需要传入EMAIL参数&quot;);// 为了简单起见异常也不自定义了  
        }// 另外邮件内容，以及其他各种协议参数等等都要处理  

        System.out.println(&quot;我是邮件，发送通知给&quot; + getMessageParam().get(&quot;EMAIL&quot;));  
    }  

}  
</code></pre>

<pre><code>package com.demoFound.factoryMethod.message;  

/**
 * 工厂方法模式_oa待办产品
 *  
 * @author popkidorc
 *  
 */  
public class MyMessageOaTodo extends MyAbstractMessage {  

    @Override  
    public void sendMesage() throws Exception {  
        // TODO Auto-generated method stub  
        if (null == getMessageParam()  
                || null == getMessageParam().get(&quot;OAUSERNAME&quot;)  
                || &quot;&quot;.equals(getMessageParam().get(&quot;OAUSERNAME&quot;))) {  
            throw new Exception(&quot;发送OA待办,需要传入OAUSERNAME参数&quot;);// 为了简单起见异常也不自定义了  
        }// 这里的参数需求就比较多了不一一处理了  

        System.out  
                .println(&quot;我是OA待办，发送通知给&quot; + getMessageParam().get(&quot;OAUSERNAME&quot;));  
    }  

}  
</code></pre>

<pre><code>package com.demoFound.factoryMethod.message;  

/**
 * 工厂方法模式_sms产品
 *  
 * @author popkidorc
 *  
 */  
public class MyMessageSms extends MyAbstractMessage {  

    @Override  
    public void sendMesage() throws Exception {  
        // TODO Auto-generated method stub  
        if (null == getMessageParam()  
                || null == getMessageParam().get(&quot;PHONENUM&quot;)  
                || &quot;&quot;.equals(getMessageParam().get(&quot;PHONENUM&quot;))) {  
            throw new Exception(&quot;发送短信,需要传入PHONENUM参数&quot;);// 为了简单起见异常也不自定义了  
        }// 另外短信信息，以及其他各种协议参数等等都要处理  

        System.out.println(&quot;我是短信，发送通知给&quot; + getMessageParam().get(&quot;PHONENUM&quot;));  
    }  

}
</code></pre>

<p>消费者：</p>

<pre><code>package com.demoFound.factoryMethod;  

import com.demoFound.factoryMethod.factory.IMyMessageFactory;  
import com.demoFound.factoryMethod.factory.MyMessageFactory;  
import com.demoFound.factoryMethod.message.IMyMessage;  

/**
 * 工厂方法模式_消费者类
 *  
 * @author popkidorc
 *  
 */  
public class MyFactoryMethodMain {  

    public static void main(String[] args) {  
        IMyMessageFactory myMessageFactory = new MyMessageFactory();  
        IMyMessage myMessage;  
        // 对于这个消费者来说，不用知道如何生产message这个产品，耦合度降低  
        try {  
            // 先来一个短信通知  
            myMessage = myMessageFactory.createMessage(&quot;SMS&quot;);  
            myMessage.sendMesage();  

            // 来一个oa待办  
            myMessage = myMessageFactory.createMessage(&quot;OA&quot;);  
            myMessage.sendMesage();  

            // 来一个邮件通知  
            myMessage = myMessageFactory.createMessage(&quot;EMAIL&quot;);  
            myMessage.sendMesage();  
        } catch (Exception e) {  
            e.printStackTrace();  
        }  
    }  
}  
</code></pre>

<p>三、抽象工厂模式</p>

<p>定义：为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。</p>

<p>类型：创建类模式</p>

<p>类图：</p>

<p>抽象工厂模式与工厂方法模式的区别</p>

<p>抽象工厂模式是工厂方法模式的升级版本，他用来创建一组相关或者相互依赖的对象。他与工厂方法模式的区别就在于，工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则是针对的多个产品等级结构。在编程中，通常一个产品结构，表现为一个接口或者抽象类，也就是说，工厂方法模式提供的所有产品都是衍生自同一个接口或抽象类，而抽象工厂模式所提供的产品则是衍生自不同的接口或抽象类。</p>

<p>在抽象工厂模式中，有一个产品族的概念：所谓的产品族，是指位于不同产品等级结构中功能相关联的产品组成的家族。抽象工厂模式所提供的一系列产品就组成一个产品族；而工厂方法提供的一系列产品称为一个等级结构。我们依然拿生产汽车的例子来说明他们之间的区别。</p>

<p>在上面的类图中，两厢车和三厢车称为两个不同的等级结构；而2.0排量车和2.4排量车则称为两个不同的产品族。再具体一点，2.0排量两厢车和2.4排量两厢车属于同一个等级结构，2.0排量三厢车和2.4排量三厢车属于另一个等级结构；而2.0排量两厢车和2.0排量三厢车属于同一个产品族，2.4排量两厢车和2.4排量三厢车属于另一个产品族。</p>

<p>明白了等级结构和产品族的概念，就理解工厂方法模式和抽象工厂模式的区别了，如果工厂的产品全部属于同一个等级结构，则属于工厂方法模式；如果工厂的产品来自多个等级结构，则属于抽象工厂模式。在本例中，如果一个工厂模式提供2.0排量两厢车和2.4排量两厢车，那么他属于工厂方法模式；如果一个工厂模式是提供2.4排量两厢车和2.4排量三厢车两个产品，那么这个工厂模式就是抽象工厂模式，因为他提供的产品是分属两个不同的等级结构。当然，如果一个工厂提供全部四种车型的产品，因为产品分属两个等级结构，他当然也属于抽象工厂模式了。</p>

<p>抽象工厂模式代码</p>

<pre><code>interface IProduct1 {  
    public void show();  
}  
interface IProduct2 {  
    public void show();  
}  

class Product1 implements IProduct1 {  
    public void show() {  
        System.out.println(&quot;这是1型产品&quot;);  
    }  
}  
class Product2 implements IProduct2 {  
    public void show() {  
        System.out.println(&quot;这是2型产品&quot;);  
    }  
}  

interface IFactory {  
    public IProduct1 createProduct1();  
    public IProduct2 createProduct2();  
}  
class Factory implements IFactory{  
    public IProduct1 createProduct1() {  
        return new Product1();  
    }  
    public IProduct2 createProduct2() {  
        return new Product2();  
    }  
}  

public class Client {  
    public static void main(String[] args){  
        IFactory factory = new Factory();  
        factory.createProduct1().show();  
        factory.createProduct2().show();  
    }  
}
</code></pre>

<p>抽象工厂模式的优点</p>

<p>抽象工厂模式除了具有工厂方法模式的优点外，最主要的优点就是可以在类的内部对产品族进行约束。所谓的产品族，一般或多或少的都存在一定的关联，抽象工厂模式就可以在类内部对产品族的关联关系进行定义和描述，而不必专门引入一个新的类来进行管理。</p>

<p>抽象工厂模式的缺点
产品族的扩展将是一件十分费力的事情，假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。所以使用抽象工厂模式时，对产品等级结构的划分是非常重要的。</p>

<p>适用场景
 当需要创建的对象是一系列相互关联或相互依赖的产品族时，便可以使用抽象工厂模式。说的更明白一点，就是一个继承体系中，如果存在着多个等级结构（即存在着多个抽象类），并且分属各个等级结构中的实现类之间存在着一定的关联或者约束，就可以使用抽象工厂模式。假如各个等级结构中的实现类之间不存在关联或约束，则使用多个独立的工厂来对产品进行创建，则更合适一点。</p>

<p>总结
无论是简单工厂模式，工厂方法模式，还是抽象工厂模式，他们都属于工厂模式，在形式和特点上也是极为相似的，他们的最终目的都是为了解耦。在使用时，我们不必去在意这个模式到底工厂方法模式还是抽象工厂模式，因为他们之间的演变常常是令人琢磨不透的。经常你会发现，明明使用的工厂方法模式，当新需求来临，稍加修改，加入了一个新方法后，由于类中的产品构成了不同等级结构中的产品族，它就变成抽象工厂模式了；而对于抽象工厂模式，当减少一个方法使的提供的产品不再构成产品族之后，它就演变成了工厂方法模式。
所以，在使用工厂模式时，只需要关心降低耦合度的目的是否达到了。</p>


    
    
        <div class="chevrons">
    <div id="navigation">
<a class="nav nav-prev" href="/design/commandpattern/" title="命令模式"> <i class="fa fa-chevron-left"></i><label>命令模式</label></a>
    <a class="nav nav-next" href="/design/strategypattern/" title="策略模式" style="margin-right: 0px;"><label>策略模式</label><i class="fa fa-chevron-right"></i></a></div>
  </div>

  </section>
</article>

<footer>

<div class="footline">
    

    

    

    
    <div class="github-link">

    </div>
    
  </div>


	<div>



	</div>
</footer>

<script src="/js/clipboard.min.js"></script>

<link href="/css/featherlight.min.css" rel="stylesheet">
<script src="/js/featherlight.min.js"></script>



<script src="/theme-flex/script.js"></script>


    

    
    

    
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <title>PerHan_Enjoy</title>
    
      <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="revised" content="2019-07-19T15:21:54 CST">
<title>装饰器模式 :: PerHan_Enjoy</title>
<link rel="shortcut icon" href="/images/favicon.png" type="image/x-icon" />
<link href="/css/font-awesome.min.css" rel="stylesheet">
<link href="/css/nucleus.css" rel="stylesheet">
<link href="/theme-flex/style.css" rel="stylesheet">

<link rel="stylesheet" href="/css/bootstrap.min.css">
<script src="/js/jquery-2.x.min.js"></script>
<script type="text/javascript">
      var baseurl = "https:\/\/peterhan-enjoy.github.com\/";
</script>
<meta name="description" content="">



    
  </head>
  <body data-url="/design/decoratorpattern/">
    
      <header>
  <div class="logo">
    
	
  
    <a class="baselink" href="https://peterhan-enjoy.github.com/">PerHan_Enjoy</a>
  


  </div>
  <div class="burger"><a href="javascript:void(0);" style="font-size:15px;">&#9776;</a></div>

</header>
<article>
  <aside>
    <ul class="menu">
          <li data-nav-id="/" class="dd-item">
          <a href="/">
            <i class="fa fa-fw fa-home"></i>
          </a>
          </li>
    <li data-nav-id="/utils/" class="dd-item haschildren
        ">
      <div>
      <a href="/utils/">工具类</a><i class="fa fa-angle-right fa-lg category-icon"></i><i class="fa fa-circle-thin read-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/utils/git/" class="dd-item">
        <div>
          <a href="/utils/git/">
            Git使用
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/markdown/" class="dd-item">
        <div>
          <a href="/utils/markdown/">
            Markdown使用
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/utils/maven/" class="dd-item">
        <div>
          <a href="/utils/maven/">
            Maven使用
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
        </ul>
    </li>
    <li data-nav-id="/design/" class="dd-item parent haschildren
        ">
      <div>
      <a href="/design/">设计模式</a>
            <i class="fa fa-angle-down fa-lg category-icon"></i><i class="fa fa-circle-thin read-icon"></i>
      </div>
        <ul>
      <li data-nav-id="/design/singletonpattern/" class="dd-item">
        <div>
          <a href="/design/singletonpattern/">
            单例模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/commandpattern/" class="dd-item">
        <div>
          <a href="/design/commandpattern/">
            命令模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/factorypattern/" class="dd-item">
        <div>
          <a href="/design/factorypattern/">
            工厂模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/strategypattern/" class="dd-item">
        <div>
          <a href="/design/strategypattern/">
            策略模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/decoratorpattern/" class="dd-item active">
        <div>
          <a href="/design/decoratorpattern/">
            装饰器模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
      <li data-nav-id="/design/observerpattern/" class="dd-item">
        <div>
          <a href="/design/observerpattern/">
            观察者模式
          </a><i class="fa fa-circle-thin read-icon"></i>
        </div>
    </li>
        </ul>
    </li>




    </ul>
    <section>
    </section>
  </aside>
  <section class="page">

    <div class="nav-select">
      <center>Navigation :
        <select onchange="javascript:location.href = this.value;">
          
    <option value="/utils/" >
   工具类</option>
    <option value="/design/" >
   设计模式</option> 
      <option value="/design/singletonpattern/" >- 单例模式</option>
      <option value="/design/commandpattern/" >- 命令模式</option>
      <option value="/design/factorypattern/" >- 工厂模式</option>
      <option value="/design/strategypattern/" >- 策略模式</option>
      <option value="/design/decoratorpattern/"  selected>- 装饰器模式</option>
      <option value="/design/observerpattern/" >- 观察者模式</option>
  



        </select>
      </center>
    </div>
      <div>
        <div class="searchbox">
          <input data-search-input id="search-by" type="text" placeholder="Search...">
        </div>
        <script type="text/javascript" src="/js/lunr.min.js"></script>
        <script type="text/javascript" src="/js/auto-complete.js"></script>
        <link href="/css/auto-complete.css" rel="stylesheet">
        <script type="text/javascript">
          
              var baseurl = "https:\/\/peterhan-enjoy.github.com\/";
          
        </script>
        <script type="text/javascript" src="/js/search.js"></script>
      </div>


    <h1>装饰器模式</h1>

    
    
    
    

<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p>

<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>

<p>我们通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。</p>

<hr />

<h4 id="介绍">介绍</h4>

<p>意图：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>

<p>主要解决：一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p>

<p>何时使用：在不想增加很多子类的情况下扩展类。</p>

<p>如何解决：将具体功能职责划分，同时继承装饰者模式。</p>

<p>关键代码： 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p>

<p>应用实例： 1、孙悟空有 72 变，当他变成&rdquo;庙宇&rdquo;后，他的根本还是一只猴子，但是他又有了庙宇的功能。 2、不论一幅画有没有画框都可以挂在墙上，但是通常都是有画框的，并且实际上是画框被挂在墙上。在挂在墙上之前，画可以被蒙上玻璃，装到框子里；这时画、玻璃和画框形成了一个物体。</p>

<p>优点：装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>

<p>缺点：多层装饰比较复杂。</p>

<p>使用场景： 1、扩展一个类的功能。 2、动态增加功能，动态撤销。</p>

<p>注意事项：可代替继承。</p>

<hr />

<h4 id="实现">实现</h4>

<p>我们将创建一个 Shape 接口和实现了 Shape 接口的实体类。然后我们创建一个实现了 Shape 接口的抽象装饰类 ShapeDecorator，并把 Shape 对象作为它的实例变量。</p>

<p>RedShapeDecorator 是实现了 ShapeDecorator 的实体类。</p>

<p>DecoratorPatternDemo，我们的演示类使用 RedShapeDecorator 来装饰 Shape 对象。
<img src="/image/decorator_pattern_uml_diagram.jpg" alt="装饰器模式" /></p>

<h5 id="步骤-1">步骤 1</h5>

<p>创建一个接口：</p>

<pre><code>public interface Shape {
   void draw();
}
</code></pre>

<h5 id="步骤-2">步骤 2</h5>

<p>创建实现接口的实体类。</p>

<pre><code>public class Rectangle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Shape: Rectangle&quot;);
   }
}
</code></pre>

<pre><code>public class Circle implements Shape {

   @Override
   public void draw() {
      System.out.println(&quot;Shape: Circle&quot;);
   }
}
</code></pre>

<h5 id="步骤-3">步骤 3</h5>

<p>创建实现了 Shape 接口的抽象装饰类。</p>

<pre><code>public abstract class ShapeDecorator implements Shape {
   protected Shape decoratedShape;

   public ShapeDecorator(Shape decoratedShape){
      this.decoratedShape = decoratedShape;
   }

   public void draw(){
      decoratedShape.draw();
   }  
}
</code></pre>

<h5 id="步骤-4">步骤 4</h5>

<p>创建扩展了 ShapeDecorator 类的实体装饰类。</p>

<pre><code>public class RedShapeDecorator extends ShapeDecorator {

   public RedShapeDecorator(Shape decoratedShape) {
      super(decoratedShape);     
   }

   @Override
   public void draw() {
      decoratedShape.draw();         
      setRedBorder(decoratedShape);
   }

   private void setRedBorder(Shape decoratedShape){
      System.out.println(&quot;Border Color: Red&quot;);
   }
}
</code></pre>

<h5 id="步骤-5">步骤 5</h5>

<p>使用 RedShapeDecorator 来装饰 Shape 对象。</p>

<pre><code>public class DecoratorPatternDemo {
   public static void main(String[] args) {

      Shape circle = new Circle();
      ShapeDecorator redCircle = new RedShapeDecorator(new Circle());
      ShapeDecorator redRectangle = new RedShapeDecorator(new Rectangle());
      //Shape redCircle = new RedShapeDecorator(new Circle());
      //Shape redRectangle = new RedShapeDecorator(new Rectangle());
      System.out.println(&quot;Circle with normal border&quot;);
      circle.draw();

      System.out.println(&quot;\nCircle of red border&quot;);
      redCircle.draw();

      System.out.println(&quot;\nRectangle of red border&quot;);
      redRectangle.draw();
   }
}
</code></pre>

<h5 id="步骤-6">步骤 6</h5>

<p>执行程序，输出结果：</p>

<pre><code>Circle with normal border
Shape: Circle

Circle of red border
Shape: Circle
Border Color: Red

Rectangle of red border
Shape: Rectangle
Border Color: Red
</code></pre>


    
    
        <div class="chevrons">
    <div id="navigation">
<a class="nav nav-prev" href="/design/strategypattern/" title="策略模式"> <i class="fa fa-chevron-left"></i><label>策略模式</label></a>
    <a class="nav nav-next" href="/design/observerpattern/" title="观察者模式" style="margin-right: 0px;"><label>观察者模式</label><i class="fa fa-chevron-right"></i></a></div>
  </div>

  </section>
</article>

<footer>

<div class="footline">
    

    

    

    
    <div class="github-link">

    </div>
    
  </div>


	<div>



	</div>
</footer>

<script src="/js/clipboard.min.js"></script>

<link href="/css/featherlight.min.css" rel="stylesheet">
<script src="/js/featherlight.min.js"></script>



<script src="/theme-flex/script.js"></script>


    

    
    

    
  </body>
</html>